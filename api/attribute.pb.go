// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: attribute.proto

package gobgpapi

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/gogo/protobuf/types"

import binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type OriginAttribute struct {
	Origin uint32 `protobuf:"varint,1,opt,name=origin,proto3" json:"origin,omitempty"`
}

func (m *OriginAttribute) Reset()                    { *m = OriginAttribute{} }
func (m *OriginAttribute) String() string            { return proto.CompactTextString(m) }
func (*OriginAttribute) ProtoMessage()               {}
func (*OriginAttribute) Descriptor() ([]byte, []int) { return fileDescriptorAttribute, []int{0} }

func (m *OriginAttribute) GetOrigin() uint32 {
	if m != nil {
		return m.Origin
	}
	return 0
}

type AsSegment struct {
	Type    uint32   `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	Numbers []uint32 `protobuf:"varint,2,rep,packed,name=numbers" json:"numbers,omitempty"`
}

func (m *AsSegment) Reset()                    { *m = AsSegment{} }
func (m *AsSegment) String() string            { return proto.CompactTextString(m) }
func (*AsSegment) ProtoMessage()               {}
func (*AsSegment) Descriptor() ([]byte, []int) { return fileDescriptorAttribute, []int{1} }

func (m *AsSegment) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *AsSegment) GetNumbers() []uint32 {
	if m != nil {
		return m.Numbers
	}
	return nil
}

type AsPathAttribute struct {
	Segments []*AsSegment `protobuf:"bytes,1,rep,name=segments" json:"segments,omitempty"`
}

func (m *AsPathAttribute) Reset()                    { *m = AsPathAttribute{} }
func (m *AsPathAttribute) String() string            { return proto.CompactTextString(m) }
func (*AsPathAttribute) ProtoMessage()               {}
func (*AsPathAttribute) Descriptor() ([]byte, []int) { return fileDescriptorAttribute, []int{2} }

func (m *AsPathAttribute) GetSegments() []*AsSegment {
	if m != nil {
		return m.Segments
	}
	return nil
}

type NextHopAttribute struct {
	NextHop string `protobuf:"bytes,1,opt,name=next_hop,json=nextHop,proto3" json:"next_hop,omitempty"`
}

func (m *NextHopAttribute) Reset()                    { *m = NextHopAttribute{} }
func (m *NextHopAttribute) String() string            { return proto.CompactTextString(m) }
func (*NextHopAttribute) ProtoMessage()               {}
func (*NextHopAttribute) Descriptor() ([]byte, []int) { return fileDescriptorAttribute, []int{3} }

func (m *NextHopAttribute) GetNextHop() string {
	if m != nil {
		return m.NextHop
	}
	return ""
}

type MultiExitDiscAttribute struct {
	Med uint32 `protobuf:"varint,1,opt,name=med,proto3" json:"med,omitempty"`
}

func (m *MultiExitDiscAttribute) Reset()                    { *m = MultiExitDiscAttribute{} }
func (m *MultiExitDiscAttribute) String() string            { return proto.CompactTextString(m) }
func (*MultiExitDiscAttribute) ProtoMessage()               {}
func (*MultiExitDiscAttribute) Descriptor() ([]byte, []int) { return fileDescriptorAttribute, []int{4} }

func (m *MultiExitDiscAttribute) GetMed() uint32 {
	if m != nil {
		return m.Med
	}
	return 0
}

type LocalPrefAttribute struct {
	LocalPref uint32 `protobuf:"varint,1,opt,name=local_pref,json=localPref,proto3" json:"local_pref,omitempty"`
}

func (m *LocalPrefAttribute) Reset()                    { *m = LocalPrefAttribute{} }
func (m *LocalPrefAttribute) String() string            { return proto.CompactTextString(m) }
func (*LocalPrefAttribute) ProtoMessage()               {}
func (*LocalPrefAttribute) Descriptor() ([]byte, []int) { return fileDescriptorAttribute, []int{5} }

func (m *LocalPrefAttribute) GetLocalPref() uint32 {
	if m != nil {
		return m.LocalPref
	}
	return 0
}

type AtomicAggregateAttribute struct {
}

func (m *AtomicAggregateAttribute) Reset()         { *m = AtomicAggregateAttribute{} }
func (m *AtomicAggregateAttribute) String() string { return proto.CompactTextString(m) }
func (*AtomicAggregateAttribute) ProtoMessage()    {}
func (*AtomicAggregateAttribute) Descriptor() ([]byte, []int) {
	return fileDescriptorAttribute, []int{6}
}

type AggregatorAttribute struct {
	As      uint32 `protobuf:"varint,2,opt,name=as,proto3" json:"as,omitempty"`
	Address string `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *AggregatorAttribute) Reset()                    { *m = AggregatorAttribute{} }
func (m *AggregatorAttribute) String() string            { return proto.CompactTextString(m) }
func (*AggregatorAttribute) ProtoMessage()               {}
func (*AggregatorAttribute) Descriptor() ([]byte, []int) { return fileDescriptorAttribute, []int{7} }

func (m *AggregatorAttribute) GetAs() uint32 {
	if m != nil {
		return m.As
	}
	return 0
}

func (m *AggregatorAttribute) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type CommunitiesAttribute struct {
	Communities []uint32 `protobuf:"varint,1,rep,packed,name=communities" json:"communities,omitempty"`
}

func (m *CommunitiesAttribute) Reset()                    { *m = CommunitiesAttribute{} }
func (m *CommunitiesAttribute) String() string            { return proto.CompactTextString(m) }
func (*CommunitiesAttribute) ProtoMessage()               {}
func (*CommunitiesAttribute) Descriptor() ([]byte, []int) { return fileDescriptorAttribute, []int{8} }

func (m *CommunitiesAttribute) GetCommunities() []uint32 {
	if m != nil {
		return m.Communities
	}
	return nil
}

type OriginatorIdAttribute struct {
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *OriginatorIdAttribute) Reset()                    { *m = OriginatorIdAttribute{} }
func (m *OriginatorIdAttribute) String() string            { return proto.CompactTextString(m) }
func (*OriginatorIdAttribute) ProtoMessage()               {}
func (*OriginatorIdAttribute) Descriptor() ([]byte, []int) { return fileDescriptorAttribute, []int{9} }

func (m *OriginatorIdAttribute) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type ClusterListAttribute struct {
	Ids []string `protobuf:"bytes,1,rep,name=ids" json:"ids,omitempty"`
}

func (m *ClusterListAttribute) Reset()                    { *m = ClusterListAttribute{} }
func (m *ClusterListAttribute) String() string            { return proto.CompactTextString(m) }
func (*ClusterListAttribute) ProtoMessage()               {}
func (*ClusterListAttribute) Descriptor() ([]byte, []int) { return fileDescriptorAttribute, []int{10} }

func (m *ClusterListAttribute) GetIds() []string {
	if m != nil {
		return m.Ids
	}
	return nil
}

// IPAddressPrefix represents the NLRI for:
// - AFI=1, SAFI=1
// - AFI=2, SAFI=1
type IPAddressPrefix struct {
	PrefixLen uint32 `protobuf:"varint,1,opt,name=prefix_len,json=prefixLen,proto3" json:"prefix_len,omitempty"`
	Prefix    string `protobuf:"bytes,2,opt,name=prefix,proto3" json:"prefix,omitempty"`
}

func (m *IPAddressPrefix) Reset()                    { *m = IPAddressPrefix{} }
func (m *IPAddressPrefix) String() string            { return proto.CompactTextString(m) }
func (*IPAddressPrefix) ProtoMessage()               {}
func (*IPAddressPrefix) Descriptor() ([]byte, []int) { return fileDescriptorAttribute, []int{11} }

func (m *IPAddressPrefix) GetPrefixLen() uint32 {
	if m != nil {
		return m.PrefixLen
	}
	return 0
}

func (m *IPAddressPrefix) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

// LabeledIPAddressPrefix represents the NLRI for:
// - AFI=1, SAFI=4
// - AFI=2, SAFI=4
type LabeledIPAddressPrefix struct {
	Labels    []uint32 `protobuf:"varint,1,rep,packed,name=labels" json:"labels,omitempty"`
	PrefixLen uint32   `protobuf:"varint,2,opt,name=prefix_len,json=prefixLen,proto3" json:"prefix_len,omitempty"`
	Prefix    string   `protobuf:"bytes,3,opt,name=prefix,proto3" json:"prefix,omitempty"`
}

func (m *LabeledIPAddressPrefix) Reset()                    { *m = LabeledIPAddressPrefix{} }
func (m *LabeledIPAddressPrefix) String() string            { return proto.CompactTextString(m) }
func (*LabeledIPAddressPrefix) ProtoMessage()               {}
func (*LabeledIPAddressPrefix) Descriptor() ([]byte, []int) { return fileDescriptorAttribute, []int{12} }

func (m *LabeledIPAddressPrefix) GetLabels() []uint32 {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *LabeledIPAddressPrefix) GetPrefixLen() uint32 {
	if m != nil {
		return m.PrefixLen
	}
	return 0
}

func (m *LabeledIPAddressPrefix) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

// EncapsulationNLRI represents the NLRI for:
// - AFI=1, SAFI=7
// - AFI=2, SAFI=7
type EncapsulationNLRI struct {
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *EncapsulationNLRI) Reset()                    { *m = EncapsulationNLRI{} }
func (m *EncapsulationNLRI) String() string            { return proto.CompactTextString(m) }
func (*EncapsulationNLRI) ProtoMessage()               {}
func (*EncapsulationNLRI) Descriptor() ([]byte, []int) { return fileDescriptorAttribute, []int{13} }

func (m *EncapsulationNLRI) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type RouteDistinguisherTwoOctetAS struct {
	Admin    uint32 `protobuf:"varint,1,opt,name=admin,proto3" json:"admin,omitempty"`
	Assigned uint32 `protobuf:"varint,2,opt,name=assigned,proto3" json:"assigned,omitempty"`
}

func (m *RouteDistinguisherTwoOctetAS) Reset()         { *m = RouteDistinguisherTwoOctetAS{} }
func (m *RouteDistinguisherTwoOctetAS) String() string { return proto.CompactTextString(m) }
func (*RouteDistinguisherTwoOctetAS) ProtoMessage()    {}
func (*RouteDistinguisherTwoOctetAS) Descriptor() ([]byte, []int) {
	return fileDescriptorAttribute, []int{14}
}

func (m *RouteDistinguisherTwoOctetAS) GetAdmin() uint32 {
	if m != nil {
		return m.Admin
	}
	return 0
}

func (m *RouteDistinguisherTwoOctetAS) GetAssigned() uint32 {
	if m != nil {
		return m.Assigned
	}
	return 0
}

type RouteDistinguisherIPAddress struct {
	Admin    string `protobuf:"bytes,1,opt,name=admin,proto3" json:"admin,omitempty"`
	Assigned uint32 `protobuf:"varint,2,opt,name=assigned,proto3" json:"assigned,omitempty"`
}

func (m *RouteDistinguisherIPAddress) Reset()         { *m = RouteDistinguisherIPAddress{} }
func (m *RouteDistinguisherIPAddress) String() string { return proto.CompactTextString(m) }
func (*RouteDistinguisherIPAddress) ProtoMessage()    {}
func (*RouteDistinguisherIPAddress) Descriptor() ([]byte, []int) {
	return fileDescriptorAttribute, []int{15}
}

func (m *RouteDistinguisherIPAddress) GetAdmin() string {
	if m != nil {
		return m.Admin
	}
	return ""
}

func (m *RouteDistinguisherIPAddress) GetAssigned() uint32 {
	if m != nil {
		return m.Assigned
	}
	return 0
}

type RouteDistinguisherFourOctetAS struct {
	Admin    uint32 `protobuf:"varint,1,opt,name=admin,proto3" json:"admin,omitempty"`
	Assigned uint32 `protobuf:"varint,2,opt,name=assigned,proto3" json:"assigned,omitempty"`
}

func (m *RouteDistinguisherFourOctetAS) Reset()         { *m = RouteDistinguisherFourOctetAS{} }
func (m *RouteDistinguisherFourOctetAS) String() string { return proto.CompactTextString(m) }
func (*RouteDistinguisherFourOctetAS) ProtoMessage()    {}
func (*RouteDistinguisherFourOctetAS) Descriptor() ([]byte, []int) {
	return fileDescriptorAttribute, []int{16}
}

func (m *RouteDistinguisherFourOctetAS) GetAdmin() uint32 {
	if m != nil {
		return m.Admin
	}
	return 0
}

func (m *RouteDistinguisherFourOctetAS) GetAssigned() uint32 {
	if m != nil {
		return m.Assigned
	}
	return 0
}

type EthernetSegmentIdentifier struct {
	Type  uint32 `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	Value []byte `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *EthernetSegmentIdentifier) Reset()         { *m = EthernetSegmentIdentifier{} }
func (m *EthernetSegmentIdentifier) String() string { return proto.CompactTextString(m) }
func (*EthernetSegmentIdentifier) ProtoMessage()    {}
func (*EthernetSegmentIdentifier) Descriptor() ([]byte, []int) {
	return fileDescriptorAttribute, []int{17}
}

func (m *EthernetSegmentIdentifier) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *EthernetSegmentIdentifier) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

// EVPNEthernetAutoDiscoveryRoute represents the NLRI for:
// - AFI=25, SAFI=70, RouteType=1
type EVPNEthernetAutoDiscoveryRoute struct {
	// One of:
	// - RouteDistinguisherTwoOctetAS
	// - RouteDistinguisherIPAddressAS
	// - RouteDistinguisherFourOctetAS
	Rd          *google_protobuf.Any       `protobuf:"bytes,1,opt,name=rd" json:"rd,omitempty"`
	Esi         *EthernetSegmentIdentifier `protobuf:"bytes,2,opt,name=esi" json:"esi,omitempty"`
	EthernetTag uint32                     `protobuf:"varint,3,opt,name=ethernet_tag,json=ethernetTag,proto3" json:"ethernet_tag,omitempty"`
	Label       uint32                     `protobuf:"varint,4,opt,name=label,proto3" json:"label,omitempty"`
}

func (m *EVPNEthernetAutoDiscoveryRoute) Reset()         { *m = EVPNEthernetAutoDiscoveryRoute{} }
func (m *EVPNEthernetAutoDiscoveryRoute) String() string { return proto.CompactTextString(m) }
func (*EVPNEthernetAutoDiscoveryRoute) ProtoMessage()    {}
func (*EVPNEthernetAutoDiscoveryRoute) Descriptor() ([]byte, []int) {
	return fileDescriptorAttribute, []int{18}
}

func (m *EVPNEthernetAutoDiscoveryRoute) GetRd() *google_protobuf.Any {
	if m != nil {
		return m.Rd
	}
	return nil
}

func (m *EVPNEthernetAutoDiscoveryRoute) GetEsi() *EthernetSegmentIdentifier {
	if m != nil {
		return m.Esi
	}
	return nil
}

func (m *EVPNEthernetAutoDiscoveryRoute) GetEthernetTag() uint32 {
	if m != nil {
		return m.EthernetTag
	}
	return 0
}

func (m *EVPNEthernetAutoDiscoveryRoute) GetLabel() uint32 {
	if m != nil {
		return m.Label
	}
	return 0
}

// EVPNMACIPAdvertisementRoute represents the NLRI for:
// - AFI=25, SAFI=70, RouteType=2
type EVPNMACIPAdvertisementRoute struct {
	// One of:
	// - RouteDistinguisherTwoOctetAS
	// - RouteDistinguisherIPAddressAS
	// - RouteDistinguisherFourOctetAS
	Rd          *google_protobuf.Any       `protobuf:"bytes,1,opt,name=rd" json:"rd,omitempty"`
	Esi         *EthernetSegmentIdentifier `protobuf:"bytes,2,opt,name=esi" json:"esi,omitempty"`
	EthernetTag uint32                     `protobuf:"varint,3,opt,name=ethernet_tag,json=ethernetTag,proto3" json:"ethernet_tag,omitempty"`
	MacAddress  string                     `protobuf:"bytes,4,opt,name=mac_address,json=macAddress,proto3" json:"mac_address,omitempty"`
	IpAddress   string                     `protobuf:"bytes,5,opt,name=ip_address,json=ipAddress,proto3" json:"ip_address,omitempty"`
	Labels      []uint32                   `protobuf:"varint,6,rep,packed,name=labels" json:"labels,omitempty"`
}

func (m *EVPNMACIPAdvertisementRoute) Reset()         { *m = EVPNMACIPAdvertisementRoute{} }
func (m *EVPNMACIPAdvertisementRoute) String() string { return proto.CompactTextString(m) }
func (*EVPNMACIPAdvertisementRoute) ProtoMessage()    {}
func (*EVPNMACIPAdvertisementRoute) Descriptor() ([]byte, []int) {
	return fileDescriptorAttribute, []int{19}
}

func (m *EVPNMACIPAdvertisementRoute) GetRd() *google_protobuf.Any {
	if m != nil {
		return m.Rd
	}
	return nil
}

func (m *EVPNMACIPAdvertisementRoute) GetEsi() *EthernetSegmentIdentifier {
	if m != nil {
		return m.Esi
	}
	return nil
}

func (m *EVPNMACIPAdvertisementRoute) GetEthernetTag() uint32 {
	if m != nil {
		return m.EthernetTag
	}
	return 0
}

func (m *EVPNMACIPAdvertisementRoute) GetMacAddress() string {
	if m != nil {
		return m.MacAddress
	}
	return ""
}

func (m *EVPNMACIPAdvertisementRoute) GetIpAddress() string {
	if m != nil {
		return m.IpAddress
	}
	return ""
}

func (m *EVPNMACIPAdvertisementRoute) GetLabels() []uint32 {
	if m != nil {
		return m.Labels
	}
	return nil
}

// EVPNInclusiveMulticastEthernetTagRoute represents the NLRI for:
// - AFI=25, SAFI=70, RouteType=3
type EVPNInclusiveMulticastEthernetTagRoute struct {
	// One of:
	// - RouteDistinguisherTwoOctetAS
	// - RouteDistinguisherIPAddressAS
	// - RouteDistinguisherFourOctetAS
	Rd          *google_protobuf.Any `protobuf:"bytes,1,opt,name=rd" json:"rd,omitempty"`
	EthernetTag uint32               `protobuf:"varint,2,opt,name=ethernet_tag,json=ethernetTag,proto3" json:"ethernet_tag,omitempty"`
	IpAddress   string               `protobuf:"bytes,3,opt,name=ip_address,json=ipAddress,proto3" json:"ip_address,omitempty"`
}

func (m *EVPNInclusiveMulticastEthernetTagRoute) Reset() {
	*m = EVPNInclusiveMulticastEthernetTagRoute{}
}
func (m *EVPNInclusiveMulticastEthernetTagRoute) String() string { return proto.CompactTextString(m) }
func (*EVPNInclusiveMulticastEthernetTagRoute) ProtoMessage()    {}
func (*EVPNInclusiveMulticastEthernetTagRoute) Descriptor() ([]byte, []int) {
	return fileDescriptorAttribute, []int{20}
}

func (m *EVPNInclusiveMulticastEthernetTagRoute) GetRd() *google_protobuf.Any {
	if m != nil {
		return m.Rd
	}
	return nil
}

func (m *EVPNInclusiveMulticastEthernetTagRoute) GetEthernetTag() uint32 {
	if m != nil {
		return m.EthernetTag
	}
	return 0
}

func (m *EVPNInclusiveMulticastEthernetTagRoute) GetIpAddress() string {
	if m != nil {
		return m.IpAddress
	}
	return ""
}

// EVPNEthernetSegmentRoute represents the NLRI for:
// - AFI=25, SAFI=70, RouteType=4
type EVPNEthernetSegmentRoute struct {
	// One of:
	// - RouteDistinguisherTwoOctetAS
	// - RouteDistinguisherIPAddressAS
	// - RouteDistinguisherFourOctetAS
	Rd        *google_protobuf.Any       `protobuf:"bytes,1,opt,name=rd" json:"rd,omitempty"`
	Esi       *EthernetSegmentIdentifier `protobuf:"bytes,2,opt,name=esi" json:"esi,omitempty"`
	IpAddress string                     `protobuf:"bytes,3,opt,name=ip_address,json=ipAddress,proto3" json:"ip_address,omitempty"`
}

func (m *EVPNEthernetSegmentRoute) Reset()         { *m = EVPNEthernetSegmentRoute{} }
func (m *EVPNEthernetSegmentRoute) String() string { return proto.CompactTextString(m) }
func (*EVPNEthernetSegmentRoute) ProtoMessage()    {}
func (*EVPNEthernetSegmentRoute) Descriptor() ([]byte, []int) {
	return fileDescriptorAttribute, []int{21}
}

func (m *EVPNEthernetSegmentRoute) GetRd() *google_protobuf.Any {
	if m != nil {
		return m.Rd
	}
	return nil
}

func (m *EVPNEthernetSegmentRoute) GetEsi() *EthernetSegmentIdentifier {
	if m != nil {
		return m.Esi
	}
	return nil
}

func (m *EVPNEthernetSegmentRoute) GetIpAddress() string {
	if m != nil {
		return m.IpAddress
	}
	return ""
}

// EVPNIPPrefixRoute represents the NLRI for:
// - AFI=25, SAFI=70, RouteType=5
type EVPNIPPrefixRoute struct {
	// One of:
	// - RouteDistinguisherTwoOctetAS
	// - RouteDistinguisherIPAddressAS
	// - RouteDistinguisherFourOctetAS
	Rd          *google_protobuf.Any       `protobuf:"bytes,1,opt,name=rd" json:"rd,omitempty"`
	Esi         *EthernetSegmentIdentifier `protobuf:"bytes,2,opt,name=esi" json:"esi,omitempty"`
	EthernetTag uint32                     `protobuf:"varint,3,opt,name=ethernet_tag,json=ethernetTag,proto3" json:"ethernet_tag,omitempty"`
	IpPrefix    string                     `protobuf:"bytes,4,opt,name=ip_prefix,json=ipPrefix,proto3" json:"ip_prefix,omitempty"`
	IpPrefixLen uint32                     `protobuf:"varint,5,opt,name=ip_prefix_len,json=ipPrefixLen,proto3" json:"ip_prefix_len,omitempty"`
	GwAddress   string                     `protobuf:"bytes,6,opt,name=gw_address,json=gwAddress,proto3" json:"gw_address,omitempty"`
	Label       uint32                     `protobuf:"varint,7,opt,name=label,proto3" json:"label,omitempty"`
}

func (m *EVPNIPPrefixRoute) Reset()                    { *m = EVPNIPPrefixRoute{} }
func (m *EVPNIPPrefixRoute) String() string            { return proto.CompactTextString(m) }
func (*EVPNIPPrefixRoute) ProtoMessage()               {}
func (*EVPNIPPrefixRoute) Descriptor() ([]byte, []int) { return fileDescriptorAttribute, []int{22} }

func (m *EVPNIPPrefixRoute) GetRd() *google_protobuf.Any {
	if m != nil {
		return m.Rd
	}
	return nil
}

func (m *EVPNIPPrefixRoute) GetEsi() *EthernetSegmentIdentifier {
	if m != nil {
		return m.Esi
	}
	return nil
}

func (m *EVPNIPPrefixRoute) GetEthernetTag() uint32 {
	if m != nil {
		return m.EthernetTag
	}
	return 0
}

func (m *EVPNIPPrefixRoute) GetIpPrefix() string {
	if m != nil {
		return m.IpPrefix
	}
	return ""
}

func (m *EVPNIPPrefixRoute) GetIpPrefixLen() uint32 {
	if m != nil {
		return m.IpPrefixLen
	}
	return 0
}

func (m *EVPNIPPrefixRoute) GetGwAddress() string {
	if m != nil {
		return m.GwAddress
	}
	return ""
}

func (m *EVPNIPPrefixRoute) GetLabel() uint32 {
	if m != nil {
		return m.Label
	}
	return 0
}

// LabeledVPNIPAddressPrefix represents the NLRI for:
// - AFI=1, SAFI=128
// - AFI=2, SAFI=128
type LabeledVPNIPAddressPrefix struct {
	Labels []uint32 `protobuf:"varint,1,rep,packed,name=labels" json:"labels,omitempty"`
	// One of:
	// - TwoOctetAsSpecificExtended
	// - IPv4AddressSpecificExtended
	// - FourOctetAsSpecificExtended
	Rd        *google_protobuf.Any `protobuf:"bytes,2,opt,name=rd" json:"rd,omitempty"`
	PrefixLen uint32               `protobuf:"varint,3,opt,name=prefix_len,json=prefixLen,proto3" json:"prefix_len,omitempty"`
	Prefix    string               `protobuf:"bytes,4,opt,name=prefix,proto3" json:"prefix,omitempty"`
}

func (m *LabeledVPNIPAddressPrefix) Reset()         { *m = LabeledVPNIPAddressPrefix{} }
func (m *LabeledVPNIPAddressPrefix) String() string { return proto.CompactTextString(m) }
func (*LabeledVPNIPAddressPrefix) ProtoMessage()    {}
func (*LabeledVPNIPAddressPrefix) Descriptor() ([]byte, []int) {
	return fileDescriptorAttribute, []int{23}
}

func (m *LabeledVPNIPAddressPrefix) GetLabels() []uint32 {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *LabeledVPNIPAddressPrefix) GetRd() *google_protobuf.Any {
	if m != nil {
		return m.Rd
	}
	return nil
}

func (m *LabeledVPNIPAddressPrefix) GetPrefixLen() uint32 {
	if m != nil {
		return m.PrefixLen
	}
	return 0
}

func (m *LabeledVPNIPAddressPrefix) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

// RouteTargetMembershipNLRI represents the NLRI for:
// - AFI=1, SAFI=132
type RouteTargetMembershipNLRI struct {
	As uint32 `protobuf:"varint,1,opt,name=as,proto3" json:"as,omitempty"`
	// One of:
	// - TwoOctetAsSpecificExtended
	// - IPv4AddressSpecificExtended
	// - FourOctetAsSpecificExtended
	Rt *google_protobuf.Any `protobuf:"bytes,2,opt,name=rt" json:"rt,omitempty"`
}

func (m *RouteTargetMembershipNLRI) Reset()         { *m = RouteTargetMembershipNLRI{} }
func (m *RouteTargetMembershipNLRI) String() string { return proto.CompactTextString(m) }
func (*RouteTargetMembershipNLRI) ProtoMessage()    {}
func (*RouteTargetMembershipNLRI) Descriptor() ([]byte, []int) {
	return fileDescriptorAttribute, []int{24}
}

func (m *RouteTargetMembershipNLRI) GetAs() uint32 {
	if m != nil {
		return m.As
	}
	return 0
}

func (m *RouteTargetMembershipNLRI) GetRt() *google_protobuf.Any {
	if m != nil {
		return m.Rt
	}
	return nil
}

type FlowSpecIPPrefix struct {
	Type      uint32 `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	PrefixLen uint32 `protobuf:"varint,2,opt,name=prefix_len,json=prefixLen,proto3" json:"prefix_len,omitempty"`
	Prefix    string `protobuf:"bytes,3,opt,name=prefix,proto3" json:"prefix,omitempty"`
	// IPv6 only
	Offset uint32 `protobuf:"varint,4,opt,name=offset,proto3" json:"offset,omitempty"`
}

func (m *FlowSpecIPPrefix) Reset()                    { *m = FlowSpecIPPrefix{} }
func (m *FlowSpecIPPrefix) String() string            { return proto.CompactTextString(m) }
func (*FlowSpecIPPrefix) ProtoMessage()               {}
func (*FlowSpecIPPrefix) Descriptor() ([]byte, []int) { return fileDescriptorAttribute, []int{25} }

func (m *FlowSpecIPPrefix) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *FlowSpecIPPrefix) GetPrefixLen() uint32 {
	if m != nil {
		return m.PrefixLen
	}
	return 0
}

func (m *FlowSpecIPPrefix) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

func (m *FlowSpecIPPrefix) GetOffset() uint32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

type FlowSpecMAC struct {
	Type    uint32 `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	Address string `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *FlowSpecMAC) Reset()                    { *m = FlowSpecMAC{} }
func (m *FlowSpecMAC) String() string            { return proto.CompactTextString(m) }
func (*FlowSpecMAC) ProtoMessage()               {}
func (*FlowSpecMAC) Descriptor() ([]byte, []int) { return fileDescriptorAttribute, []int{26} }

func (m *FlowSpecMAC) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *FlowSpecMAC) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type FlowSpecComponentItem struct {
	// Operator for Numeric type, Operand for Bitmask type
	Op    uint32 `protobuf:"varint,1,opt,name=op,proto3" json:"op,omitempty"`
	Value uint64 `protobuf:"varint,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *FlowSpecComponentItem) Reset()                    { *m = FlowSpecComponentItem{} }
func (m *FlowSpecComponentItem) String() string            { return proto.CompactTextString(m) }
func (*FlowSpecComponentItem) ProtoMessage()               {}
func (*FlowSpecComponentItem) Descriptor() ([]byte, []int) { return fileDescriptorAttribute, []int{27} }

func (m *FlowSpecComponentItem) GetOp() uint32 {
	if m != nil {
		return m.Op
	}
	return 0
}

func (m *FlowSpecComponentItem) GetValue() uint64 {
	if m != nil {
		return m.Value
	}
	return 0
}

type FlowSpecComponent struct {
	Type  uint32                   `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	Items []*FlowSpecComponentItem `protobuf:"bytes,2,rep,name=items" json:"items,omitempty"`
}

func (m *FlowSpecComponent) Reset()                    { *m = FlowSpecComponent{} }
func (m *FlowSpecComponent) String() string            { return proto.CompactTextString(m) }
func (*FlowSpecComponent) ProtoMessage()               {}
func (*FlowSpecComponent) Descriptor() ([]byte, []int) { return fileDescriptorAttribute, []int{28} }

func (m *FlowSpecComponent) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *FlowSpecComponent) GetItems() []*FlowSpecComponentItem {
	if m != nil {
		return m.Items
	}
	return nil
}

// FlowSpecNLRI represents the NLRI for:
// - AFI=1, SAFI=133
// - AFI=2, SAFI=133
type FlowSpecNLRI struct {
	// One of:
	// - FlowSpecIPPrefix
	// - FlowSpecMAC
	// - FlowSpecComponent
	Rules []*google_protobuf.Any `protobuf:"bytes,1,rep,name=rules" json:"rules,omitempty"`
}

func (m *FlowSpecNLRI) Reset()                    { *m = FlowSpecNLRI{} }
func (m *FlowSpecNLRI) String() string            { return proto.CompactTextString(m) }
func (*FlowSpecNLRI) ProtoMessage()               {}
func (*FlowSpecNLRI) Descriptor() ([]byte, []int) { return fileDescriptorAttribute, []int{29} }

func (m *FlowSpecNLRI) GetRules() []*google_protobuf.Any {
	if m != nil {
		return m.Rules
	}
	return nil
}

// VPNFlowSpecNLRI represents the NLRI for:
// - AFI=1, SAFI=134
// - AFI=2, SAFI=134
// - AFI=25, SAFI=134
type VPNFlowSpecNLRI struct {
	// One of:
	// - RouteDistinguisherTwoOctetAS
	// - RouteDistinguisherIPAddressAS
	// - RouteDistinguisherFourOctetAS
	Rd *google_protobuf.Any `protobuf:"bytes,1,opt,name=rd" json:"rd,omitempty"`
	// One of:
	// - FlowSpecIPPrefix
	// - FlowSpecMAC
	// - FlowSpecComponent
	Rules []*google_protobuf.Any `protobuf:"bytes,2,rep,name=rules" json:"rules,omitempty"`
}

func (m *VPNFlowSpecNLRI) Reset()                    { *m = VPNFlowSpecNLRI{} }
func (m *VPNFlowSpecNLRI) String() string            { return proto.CompactTextString(m) }
func (*VPNFlowSpecNLRI) ProtoMessage()               {}
func (*VPNFlowSpecNLRI) Descriptor() ([]byte, []int) { return fileDescriptorAttribute, []int{30} }

func (m *VPNFlowSpecNLRI) GetRd() *google_protobuf.Any {
	if m != nil {
		return m.Rd
	}
	return nil
}

func (m *VPNFlowSpecNLRI) GetRules() []*google_protobuf.Any {
	if m != nil {
		return m.Rules
	}
	return nil
}

// OpaqueNLRI represents the NLRI for:
// - AFI=16397, SAFI=241
type OpaqueNLRI struct {
	Key   []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value []byte `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *OpaqueNLRI) Reset()                    { *m = OpaqueNLRI{} }
func (m *OpaqueNLRI) String() string            { return proto.CompactTextString(m) }
func (*OpaqueNLRI) ProtoMessage()               {}
func (*OpaqueNLRI) Descriptor() ([]byte, []int) { return fileDescriptorAttribute, []int{31} }

func (m *OpaqueNLRI) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *OpaqueNLRI) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

type MpReachNLRIAttribute struct {
	Family   uint32   `protobuf:"varint,1,opt,name=family,proto3" json:"family,omitempty"`
	NextHops []string `protobuf:"bytes,2,rep,name=next_hops,json=nextHops" json:"next_hops,omitempty"`
	// Each NLRI must be one of:
	// - IPAddressPrefix
	// - LabeledIPAddressPrefix
	// - EncapsulationNLRI
	// - EVPNEthernetAutoDiscoveryRoute
	// - EVPNMACIPAdvertisementRoute
	// - EVPNInclusiveMulticastEthernetTagRoute
	// - EVPNEthernetSegmentRoute
	// - EVPNIPPrefixRoute
	// - LabeledVPNIPAddressPrefix
	// - RouteTargetMembershipNLRI
	// - FlowSpecNLRI
	// - VPNFlowSpecNLRI
	// - OpaqueNLRI
	Nlris []*google_protobuf.Any `protobuf:"bytes,3,rep,name=nlris" json:"nlris,omitempty"`
}

func (m *MpReachNLRIAttribute) Reset()                    { *m = MpReachNLRIAttribute{} }
func (m *MpReachNLRIAttribute) String() string            { return proto.CompactTextString(m) }
func (*MpReachNLRIAttribute) ProtoMessage()               {}
func (*MpReachNLRIAttribute) Descriptor() ([]byte, []int) { return fileDescriptorAttribute, []int{32} }

func (m *MpReachNLRIAttribute) GetFamily() uint32 {
	if m != nil {
		return m.Family
	}
	return 0
}

func (m *MpReachNLRIAttribute) GetNextHops() []string {
	if m != nil {
		return m.NextHops
	}
	return nil
}

func (m *MpReachNLRIAttribute) GetNlris() []*google_protobuf.Any {
	if m != nil {
		return m.Nlris
	}
	return nil
}

type MpUnreachNLRIAttribute struct {
	Family uint32 `protobuf:"varint,1,opt,name=family,proto3" json:"family,omitempty"`
	// The same as NLRI field of MpReachNLRIAttribute
	Nlris []*google_protobuf.Any `protobuf:"bytes,3,rep,name=nlris" json:"nlris,omitempty"`
}

func (m *MpUnreachNLRIAttribute) Reset()                    { *m = MpUnreachNLRIAttribute{} }
func (m *MpUnreachNLRIAttribute) String() string            { return proto.CompactTextString(m) }
func (*MpUnreachNLRIAttribute) ProtoMessage()               {}
func (*MpUnreachNLRIAttribute) Descriptor() ([]byte, []int) { return fileDescriptorAttribute, []int{33} }

func (m *MpUnreachNLRIAttribute) GetFamily() uint32 {
	if m != nil {
		return m.Family
	}
	return 0
}

func (m *MpUnreachNLRIAttribute) GetNlris() []*google_protobuf.Any {
	if m != nil {
		return m.Nlris
	}
	return nil
}

type TwoOctetAsSpecificExtended struct {
	IsTransitive bool   `protobuf:"varint,1,opt,name=is_transitive,json=isTransitive,proto3" json:"is_transitive,omitempty"`
	SubType      uint32 `protobuf:"varint,2,opt,name=sub_type,json=subType,proto3" json:"sub_type,omitempty"`
	As           uint32 `protobuf:"varint,3,opt,name=as,proto3" json:"as,omitempty"`
	LocalAdmin   uint32 `protobuf:"varint,4,opt,name=local_admin,json=localAdmin,proto3" json:"local_admin,omitempty"`
}

func (m *TwoOctetAsSpecificExtended) Reset()         { *m = TwoOctetAsSpecificExtended{} }
func (m *TwoOctetAsSpecificExtended) String() string { return proto.CompactTextString(m) }
func (*TwoOctetAsSpecificExtended) ProtoMessage()    {}
func (*TwoOctetAsSpecificExtended) Descriptor() ([]byte, []int) {
	return fileDescriptorAttribute, []int{34}
}

func (m *TwoOctetAsSpecificExtended) GetIsTransitive() bool {
	if m != nil {
		return m.IsTransitive
	}
	return false
}

func (m *TwoOctetAsSpecificExtended) GetSubType() uint32 {
	if m != nil {
		return m.SubType
	}
	return 0
}

func (m *TwoOctetAsSpecificExtended) GetAs() uint32 {
	if m != nil {
		return m.As
	}
	return 0
}

func (m *TwoOctetAsSpecificExtended) GetLocalAdmin() uint32 {
	if m != nil {
		return m.LocalAdmin
	}
	return 0
}

type IPv4AddressSpecificExtended struct {
	IsTransitive bool   `protobuf:"varint,1,opt,name=is_transitive,json=isTransitive,proto3" json:"is_transitive,omitempty"`
	SubType      uint32 `protobuf:"varint,2,opt,name=sub_type,json=subType,proto3" json:"sub_type,omitempty"`
	Address      string `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty"`
	LocalAdmin   uint32 `protobuf:"varint,4,opt,name=local_admin,json=localAdmin,proto3" json:"local_admin,omitempty"`
}

func (m *IPv4AddressSpecificExtended) Reset()         { *m = IPv4AddressSpecificExtended{} }
func (m *IPv4AddressSpecificExtended) String() string { return proto.CompactTextString(m) }
func (*IPv4AddressSpecificExtended) ProtoMessage()    {}
func (*IPv4AddressSpecificExtended) Descriptor() ([]byte, []int) {
	return fileDescriptorAttribute, []int{35}
}

func (m *IPv4AddressSpecificExtended) GetIsTransitive() bool {
	if m != nil {
		return m.IsTransitive
	}
	return false
}

func (m *IPv4AddressSpecificExtended) GetSubType() uint32 {
	if m != nil {
		return m.SubType
	}
	return 0
}

func (m *IPv4AddressSpecificExtended) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *IPv4AddressSpecificExtended) GetLocalAdmin() uint32 {
	if m != nil {
		return m.LocalAdmin
	}
	return 0
}

type FourOctetAsSpecificExtended struct {
	IsTransitive bool   `protobuf:"varint,1,opt,name=is_transitive,json=isTransitive,proto3" json:"is_transitive,omitempty"`
	SubType      uint32 `protobuf:"varint,2,opt,name=sub_type,json=subType,proto3" json:"sub_type,omitempty"`
	As           uint32 `protobuf:"varint,3,opt,name=as,proto3" json:"as,omitempty"`
	LocalAdmin   uint32 `protobuf:"varint,4,opt,name=local_admin,json=localAdmin,proto3" json:"local_admin,omitempty"`
}

func (m *FourOctetAsSpecificExtended) Reset()         { *m = FourOctetAsSpecificExtended{} }
func (m *FourOctetAsSpecificExtended) String() string { return proto.CompactTextString(m) }
func (*FourOctetAsSpecificExtended) ProtoMessage()    {}
func (*FourOctetAsSpecificExtended) Descriptor() ([]byte, []int) {
	return fileDescriptorAttribute, []int{36}
}

func (m *FourOctetAsSpecificExtended) GetIsTransitive() bool {
	if m != nil {
		return m.IsTransitive
	}
	return false
}

func (m *FourOctetAsSpecificExtended) GetSubType() uint32 {
	if m != nil {
		return m.SubType
	}
	return 0
}

func (m *FourOctetAsSpecificExtended) GetAs() uint32 {
	if m != nil {
		return m.As
	}
	return 0
}

func (m *FourOctetAsSpecificExtended) GetLocalAdmin() uint32 {
	if m != nil {
		return m.LocalAdmin
	}
	return 0
}

type ValidationExtended struct {
	State uint32 `protobuf:"varint,1,opt,name=state,proto3" json:"state,omitempty"`
}

func (m *ValidationExtended) Reset()                    { *m = ValidationExtended{} }
func (m *ValidationExtended) String() string            { return proto.CompactTextString(m) }
func (*ValidationExtended) ProtoMessage()               {}
func (*ValidationExtended) Descriptor() ([]byte, []int) { return fileDescriptorAttribute, []int{37} }

func (m *ValidationExtended) GetState() uint32 {
	if m != nil {
		return m.State
	}
	return 0
}

type ColorExtended struct {
	Color uint32 `protobuf:"varint,1,opt,name=color,proto3" json:"color,omitempty"`
}

func (m *ColorExtended) Reset()                    { *m = ColorExtended{} }
func (m *ColorExtended) String() string            { return proto.CompactTextString(m) }
func (*ColorExtended) ProtoMessage()               {}
func (*ColorExtended) Descriptor() ([]byte, []int) { return fileDescriptorAttribute, []int{38} }

func (m *ColorExtended) GetColor() uint32 {
	if m != nil {
		return m.Color
	}
	return 0
}

type EncapExtended struct {
	TunnelType uint32 `protobuf:"varint,1,opt,name=tunnel_type,json=tunnelType,proto3" json:"tunnel_type,omitempty"`
}

func (m *EncapExtended) Reset()                    { *m = EncapExtended{} }
func (m *EncapExtended) String() string            { return proto.CompactTextString(m) }
func (*EncapExtended) ProtoMessage()               {}
func (*EncapExtended) Descriptor() ([]byte, []int) { return fileDescriptorAttribute, []int{39} }

func (m *EncapExtended) GetTunnelType() uint32 {
	if m != nil {
		return m.TunnelType
	}
	return 0
}

type DefaultGatewayExtended struct {
}

func (m *DefaultGatewayExtended) Reset()                    { *m = DefaultGatewayExtended{} }
func (m *DefaultGatewayExtended) String() string            { return proto.CompactTextString(m) }
func (*DefaultGatewayExtended) ProtoMessage()               {}
func (*DefaultGatewayExtended) Descriptor() ([]byte, []int) { return fileDescriptorAttribute, []int{40} }

type OpaqueExtended struct {
	IsTransitive bool   `protobuf:"varint,1,opt,name=is_transitive,json=isTransitive,proto3" json:"is_transitive,omitempty"`
	Value        []byte `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *OpaqueExtended) Reset()                    { *m = OpaqueExtended{} }
func (m *OpaqueExtended) String() string            { return proto.CompactTextString(m) }
func (*OpaqueExtended) ProtoMessage()               {}
func (*OpaqueExtended) Descriptor() ([]byte, []int) { return fileDescriptorAttribute, []int{41} }

func (m *OpaqueExtended) GetIsTransitive() bool {
	if m != nil {
		return m.IsTransitive
	}
	return false
}

func (m *OpaqueExtended) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

type ESILabelExtended struct {
	IsSingleActive bool   `protobuf:"varint,1,opt,name=is_single_active,json=isSingleActive,proto3" json:"is_single_active,omitempty"`
	Label          uint32 `protobuf:"varint,2,opt,name=label,proto3" json:"label,omitempty"`
}

func (m *ESILabelExtended) Reset()                    { *m = ESILabelExtended{} }
func (m *ESILabelExtended) String() string            { return proto.CompactTextString(m) }
func (*ESILabelExtended) ProtoMessage()               {}
func (*ESILabelExtended) Descriptor() ([]byte, []int) { return fileDescriptorAttribute, []int{42} }

func (m *ESILabelExtended) GetIsSingleActive() bool {
	if m != nil {
		return m.IsSingleActive
	}
	return false
}

func (m *ESILabelExtended) GetLabel() uint32 {
	if m != nil {
		return m.Label
	}
	return 0
}

type ESImportRouteTarget struct {
	EsImport string `protobuf:"bytes,1,opt,name=es_import,json=esImport,proto3" json:"es_import,omitempty"`
}

func (m *ESImportRouteTarget) Reset()                    { *m = ESImportRouteTarget{} }
func (m *ESImportRouteTarget) String() string            { return proto.CompactTextString(m) }
func (*ESImportRouteTarget) ProtoMessage()               {}
func (*ESImportRouteTarget) Descriptor() ([]byte, []int) { return fileDescriptorAttribute, []int{43} }

func (m *ESImportRouteTarget) GetEsImport() string {
	if m != nil {
		return m.EsImport
	}
	return ""
}

type MacMobilityExtended struct {
	IsSticky    bool   `protobuf:"varint,1,opt,name=is_sticky,json=isSticky,proto3" json:"is_sticky,omitempty"`
	SequenceNum uint32 `protobuf:"varint,2,opt,name=sequence_num,json=sequenceNum,proto3" json:"sequence_num,omitempty"`
}

func (m *MacMobilityExtended) Reset()                    { *m = MacMobilityExtended{} }
func (m *MacMobilityExtended) String() string            { return proto.CompactTextString(m) }
func (*MacMobilityExtended) ProtoMessage()               {}
func (*MacMobilityExtended) Descriptor() ([]byte, []int) { return fileDescriptorAttribute, []int{44} }

func (m *MacMobilityExtended) GetIsSticky() bool {
	if m != nil {
		return m.IsSticky
	}
	return false
}

func (m *MacMobilityExtended) GetSequenceNum() uint32 {
	if m != nil {
		return m.SequenceNum
	}
	return 0
}

type RouterMacExtended struct {
	Mac string `protobuf:"bytes,1,opt,name=mac,proto3" json:"mac,omitempty"`
}

func (m *RouterMacExtended) Reset()                    { *m = RouterMacExtended{} }
func (m *RouterMacExtended) String() string            { return proto.CompactTextString(m) }
func (*RouterMacExtended) ProtoMessage()               {}
func (*RouterMacExtended) Descriptor() ([]byte, []int) { return fileDescriptorAttribute, []int{45} }

func (m *RouterMacExtended) GetMac() string {
	if m != nil {
		return m.Mac
	}
	return ""
}

type TrafficRateExtended struct {
	As   uint32  `protobuf:"varint,1,opt,name=as,proto3" json:"as,omitempty"`
	Rate float32 `protobuf:"fixed32,2,opt,name=rate,proto3" json:"rate,omitempty"`
}

func (m *TrafficRateExtended) Reset()                    { *m = TrafficRateExtended{} }
func (m *TrafficRateExtended) String() string            { return proto.CompactTextString(m) }
func (*TrafficRateExtended) ProtoMessage()               {}
func (*TrafficRateExtended) Descriptor() ([]byte, []int) { return fileDescriptorAttribute, []int{46} }

func (m *TrafficRateExtended) GetAs() uint32 {
	if m != nil {
		return m.As
	}
	return 0
}

func (m *TrafficRateExtended) GetRate() float32 {
	if m != nil {
		return m.Rate
	}
	return 0
}

type TrafficActionExtended struct {
	Terminal bool `protobuf:"varint,1,opt,name=terminal,proto3" json:"terminal,omitempty"`
	Sample   bool `protobuf:"varint,2,opt,name=sample,proto3" json:"sample,omitempty"`
}

func (m *TrafficActionExtended) Reset()                    { *m = TrafficActionExtended{} }
func (m *TrafficActionExtended) String() string            { return proto.CompactTextString(m) }
func (*TrafficActionExtended) ProtoMessage()               {}
func (*TrafficActionExtended) Descriptor() ([]byte, []int) { return fileDescriptorAttribute, []int{47} }

func (m *TrafficActionExtended) GetTerminal() bool {
	if m != nil {
		return m.Terminal
	}
	return false
}

func (m *TrafficActionExtended) GetSample() bool {
	if m != nil {
		return m.Sample
	}
	return false
}

type RedirectTwoOctetAsSpecificExtended struct {
	As         uint32 `protobuf:"varint,1,opt,name=as,proto3" json:"as,omitempty"`
	LocalAdmin uint32 `protobuf:"varint,2,opt,name=local_admin,json=localAdmin,proto3" json:"local_admin,omitempty"`
}

func (m *RedirectTwoOctetAsSpecificExtended) Reset()         { *m = RedirectTwoOctetAsSpecificExtended{} }
func (m *RedirectTwoOctetAsSpecificExtended) String() string { return proto.CompactTextString(m) }
func (*RedirectTwoOctetAsSpecificExtended) ProtoMessage()    {}
func (*RedirectTwoOctetAsSpecificExtended) Descriptor() ([]byte, []int) {
	return fileDescriptorAttribute, []int{48}
}

func (m *RedirectTwoOctetAsSpecificExtended) GetAs() uint32 {
	if m != nil {
		return m.As
	}
	return 0
}

func (m *RedirectTwoOctetAsSpecificExtended) GetLocalAdmin() uint32 {
	if m != nil {
		return m.LocalAdmin
	}
	return 0
}

type RedirectIPv4AddressSpecificExtended struct {
	Address    string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	LocalAdmin uint32 `protobuf:"varint,2,opt,name=local_admin,json=localAdmin,proto3" json:"local_admin,omitempty"`
}

func (m *RedirectIPv4AddressSpecificExtended) Reset()         { *m = RedirectIPv4AddressSpecificExtended{} }
func (m *RedirectIPv4AddressSpecificExtended) String() string { return proto.CompactTextString(m) }
func (*RedirectIPv4AddressSpecificExtended) ProtoMessage()    {}
func (*RedirectIPv4AddressSpecificExtended) Descriptor() ([]byte, []int) {
	return fileDescriptorAttribute, []int{49}
}

func (m *RedirectIPv4AddressSpecificExtended) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *RedirectIPv4AddressSpecificExtended) GetLocalAdmin() uint32 {
	if m != nil {
		return m.LocalAdmin
	}
	return 0
}

type RedirectFourOctetAsSpecificExtended struct {
	As         uint32 `protobuf:"varint,1,opt,name=as,proto3" json:"as,omitempty"`
	LocalAdmin uint32 `protobuf:"varint,2,opt,name=local_admin,json=localAdmin,proto3" json:"local_admin,omitempty"`
}

func (m *RedirectFourOctetAsSpecificExtended) Reset()         { *m = RedirectFourOctetAsSpecificExtended{} }
func (m *RedirectFourOctetAsSpecificExtended) String() string { return proto.CompactTextString(m) }
func (*RedirectFourOctetAsSpecificExtended) ProtoMessage()    {}
func (*RedirectFourOctetAsSpecificExtended) Descriptor() ([]byte, []int) {
	return fileDescriptorAttribute, []int{50}
}

func (m *RedirectFourOctetAsSpecificExtended) GetAs() uint32 {
	if m != nil {
		return m.As
	}
	return 0
}

func (m *RedirectFourOctetAsSpecificExtended) GetLocalAdmin() uint32 {
	if m != nil {
		return m.LocalAdmin
	}
	return 0
}

type TrafficRemarkExtended struct {
	Dscp uint32 `protobuf:"varint,1,opt,name=dscp,proto3" json:"dscp,omitempty"`
}

func (m *TrafficRemarkExtended) Reset()                    { *m = TrafficRemarkExtended{} }
func (m *TrafficRemarkExtended) String() string            { return proto.CompactTextString(m) }
func (*TrafficRemarkExtended) ProtoMessage()               {}
func (*TrafficRemarkExtended) Descriptor() ([]byte, []int) { return fileDescriptorAttribute, []int{51} }

func (m *TrafficRemarkExtended) GetDscp() uint32 {
	if m != nil {
		return m.Dscp
	}
	return 0
}

type UnknownExtended struct {
	Type  uint32 `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	Value []byte `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *UnknownExtended) Reset()                    { *m = UnknownExtended{} }
func (m *UnknownExtended) String() string            { return proto.CompactTextString(m) }
func (*UnknownExtended) ProtoMessage()               {}
func (*UnknownExtended) Descriptor() ([]byte, []int) { return fileDescriptorAttribute, []int{52} }

func (m *UnknownExtended) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *UnknownExtended) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

type ExtendedCommunitiesAttribute struct {
	// Each Community must be one of:
	// - TwoOctetAsSpecificExtended
	// - IPv4AddressSpecificExtended
	// - FourOctetAsSpecificExtended
	// - OpaqueExtended
	// - ESILabelExtended
	// - MacMobilityExtended
	// - RouterMacExtended
	// - TrafficRateExtended
	// - TrafficActionExtended
	// - RedirectTwoOctetAsSpecificExtended
	// - RedirectIPv4AddressSpecificExtended
	// - RedirectFourOctetAsSpecificExtended
	// - TrafficRemarkExtended
	// - UnknownExtended
	Communities []*google_protobuf.Any `protobuf:"bytes,1,rep,name=communities" json:"communities,omitempty"`
}

func (m *ExtendedCommunitiesAttribute) Reset()         { *m = ExtendedCommunitiesAttribute{} }
func (m *ExtendedCommunitiesAttribute) String() string { return proto.CompactTextString(m) }
func (*ExtendedCommunitiesAttribute) ProtoMessage()    {}
func (*ExtendedCommunitiesAttribute) Descriptor() ([]byte, []int) {
	return fileDescriptorAttribute, []int{53}
}

func (m *ExtendedCommunitiesAttribute) GetCommunities() []*google_protobuf.Any {
	if m != nil {
		return m.Communities
	}
	return nil
}

type As4PathAttribute struct {
	Segments []*AsSegment `protobuf:"bytes,1,rep,name=segments" json:"segments,omitempty"`
}

func (m *As4PathAttribute) Reset()                    { *m = As4PathAttribute{} }
func (m *As4PathAttribute) String() string            { return proto.CompactTextString(m) }
func (*As4PathAttribute) ProtoMessage()               {}
func (*As4PathAttribute) Descriptor() ([]byte, []int) { return fileDescriptorAttribute, []int{54} }

func (m *As4PathAttribute) GetSegments() []*AsSegment {
	if m != nil {
		return m.Segments
	}
	return nil
}

type As4AggregatorAttribute struct {
	As      uint32 `protobuf:"varint,2,opt,name=as,proto3" json:"as,omitempty"`
	Address string `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *As4AggregatorAttribute) Reset()                    { *m = As4AggregatorAttribute{} }
func (m *As4AggregatorAttribute) String() string            { return proto.CompactTextString(m) }
func (*As4AggregatorAttribute) ProtoMessage()               {}
func (*As4AggregatorAttribute) Descriptor() ([]byte, []int) { return fileDescriptorAttribute, []int{55} }

func (m *As4AggregatorAttribute) GetAs() uint32 {
	if m != nil {
		return m.As
	}
	return 0
}

func (m *As4AggregatorAttribute) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type PmsiTunnelAttribute struct {
	Flags uint32 `protobuf:"varint,1,opt,name=flags,proto3" json:"flags,omitempty"`
	Type  uint32 `protobuf:"varint,2,opt,name=type,proto3" json:"type,omitempty"`
	Label uint32 `protobuf:"varint,3,opt,name=label,proto3" json:"label,omitempty"`
	Id    []byte `protobuf:"bytes,4,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *PmsiTunnelAttribute) Reset()                    { *m = PmsiTunnelAttribute{} }
func (m *PmsiTunnelAttribute) String() string            { return proto.CompactTextString(m) }
func (*PmsiTunnelAttribute) ProtoMessage()               {}
func (*PmsiTunnelAttribute) Descriptor() ([]byte, []int) { return fileDescriptorAttribute, []int{56} }

func (m *PmsiTunnelAttribute) GetFlags() uint32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *PmsiTunnelAttribute) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *PmsiTunnelAttribute) GetLabel() uint32 {
	if m != nil {
		return m.Label
	}
	return 0
}

func (m *PmsiTunnelAttribute) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

type TunnelEncapSubTLVEncapsulation struct {
	Key    uint32 `protobuf:"varint,1,opt,name=key,proto3" json:"key,omitempty"`
	Cookie []byte `protobuf:"bytes,2,opt,name=cookie,proto3" json:"cookie,omitempty"`
}

func (m *TunnelEncapSubTLVEncapsulation) Reset()         { *m = TunnelEncapSubTLVEncapsulation{} }
func (m *TunnelEncapSubTLVEncapsulation) String() string { return proto.CompactTextString(m) }
func (*TunnelEncapSubTLVEncapsulation) ProtoMessage()    {}
func (*TunnelEncapSubTLVEncapsulation) Descriptor() ([]byte, []int) {
	return fileDescriptorAttribute, []int{57}
}

func (m *TunnelEncapSubTLVEncapsulation) GetKey() uint32 {
	if m != nil {
		return m.Key
	}
	return 0
}

func (m *TunnelEncapSubTLVEncapsulation) GetCookie() []byte {
	if m != nil {
		return m.Cookie
	}
	return nil
}

type TunnelEncapSubTLVProtocol struct {
	Protocol uint32 `protobuf:"varint,1,opt,name=protocol,proto3" json:"protocol,omitempty"`
}

func (m *TunnelEncapSubTLVProtocol) Reset()         { *m = TunnelEncapSubTLVProtocol{} }
func (m *TunnelEncapSubTLVProtocol) String() string { return proto.CompactTextString(m) }
func (*TunnelEncapSubTLVProtocol) ProtoMessage()    {}
func (*TunnelEncapSubTLVProtocol) Descriptor() ([]byte, []int) {
	return fileDescriptorAttribute, []int{58}
}

func (m *TunnelEncapSubTLVProtocol) GetProtocol() uint32 {
	if m != nil {
		return m.Protocol
	}
	return 0
}

type TunnelEncapSubTLVColor struct {
	Color uint32 `protobuf:"varint,1,opt,name=color,proto3" json:"color,omitempty"`
}

func (m *TunnelEncapSubTLVColor) Reset()                    { *m = TunnelEncapSubTLVColor{} }
func (m *TunnelEncapSubTLVColor) String() string            { return proto.CompactTextString(m) }
func (*TunnelEncapSubTLVColor) ProtoMessage()               {}
func (*TunnelEncapSubTLVColor) Descriptor() ([]byte, []int) { return fileDescriptorAttribute, []int{59} }

func (m *TunnelEncapSubTLVColor) GetColor() uint32 {
	if m != nil {
		return m.Color
	}
	return 0
}

type TunnelEncapSubTLVUnknown struct {
	Type  uint32 `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	Value []byte `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *TunnelEncapSubTLVUnknown) Reset()         { *m = TunnelEncapSubTLVUnknown{} }
func (m *TunnelEncapSubTLVUnknown) String() string { return proto.CompactTextString(m) }
func (*TunnelEncapSubTLVUnknown) ProtoMessage()    {}
func (*TunnelEncapSubTLVUnknown) Descriptor() ([]byte, []int) {
	return fileDescriptorAttribute, []int{60}
}

func (m *TunnelEncapSubTLVUnknown) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *TunnelEncapSubTLVUnknown) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

type TunnelEncapTLV struct {
	Type uint32 `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	// Each TLV must be one of:
	// - TunnelEncapSubTLVEncapsulation
	// - TunnelEncapSubTLVProtocol
	// - TunnelEncapSubTLVColor
	// - TunnelEncapSubTLVUnknown
	Tlvs []*google_protobuf.Any `protobuf:"bytes,2,rep,name=tlvs" json:"tlvs,omitempty"`
}

func (m *TunnelEncapTLV) Reset()                    { *m = TunnelEncapTLV{} }
func (m *TunnelEncapTLV) String() string            { return proto.CompactTextString(m) }
func (*TunnelEncapTLV) ProtoMessage()               {}
func (*TunnelEncapTLV) Descriptor() ([]byte, []int) { return fileDescriptorAttribute, []int{61} }

func (m *TunnelEncapTLV) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *TunnelEncapTLV) GetTlvs() []*google_protobuf.Any {
	if m != nil {
		return m.Tlvs
	}
	return nil
}

type TunnelEncapAttribute struct {
	Tlvs []*TunnelEncapTLV `protobuf:"bytes,1,rep,name=tlvs" json:"tlvs,omitempty"`
}

func (m *TunnelEncapAttribute) Reset()                    { *m = TunnelEncapAttribute{} }
func (m *TunnelEncapAttribute) String() string            { return proto.CompactTextString(m) }
func (*TunnelEncapAttribute) ProtoMessage()               {}
func (*TunnelEncapAttribute) Descriptor() ([]byte, []int) { return fileDescriptorAttribute, []int{62} }

func (m *TunnelEncapAttribute) GetTlvs() []*TunnelEncapTLV {
	if m != nil {
		return m.Tlvs
	}
	return nil
}

type IPv6AddressSpecificExtended struct {
	IsTransitive bool   `protobuf:"varint,1,opt,name=is_transitive,json=isTransitive,proto3" json:"is_transitive,omitempty"`
	SubType      uint32 `protobuf:"varint,2,opt,name=sub_type,json=subType,proto3" json:"sub_type,omitempty"`
	Address      string `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty"`
	LocalAdmin   uint32 `protobuf:"varint,4,opt,name=local_admin,json=localAdmin,proto3" json:"local_admin,omitempty"`
}

func (m *IPv6AddressSpecificExtended) Reset()         { *m = IPv6AddressSpecificExtended{} }
func (m *IPv6AddressSpecificExtended) String() string { return proto.CompactTextString(m) }
func (*IPv6AddressSpecificExtended) ProtoMessage()    {}
func (*IPv6AddressSpecificExtended) Descriptor() ([]byte, []int) {
	return fileDescriptorAttribute, []int{63}
}

func (m *IPv6AddressSpecificExtended) GetIsTransitive() bool {
	if m != nil {
		return m.IsTransitive
	}
	return false
}

func (m *IPv6AddressSpecificExtended) GetSubType() uint32 {
	if m != nil {
		return m.SubType
	}
	return 0
}

func (m *IPv6AddressSpecificExtended) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *IPv6AddressSpecificExtended) GetLocalAdmin() uint32 {
	if m != nil {
		return m.LocalAdmin
	}
	return 0
}

type RedirectIPv6AddressSpecificExtended struct {
	Address    string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	LocalAdmin uint32 `protobuf:"varint,2,opt,name=local_admin,json=localAdmin,proto3" json:"local_admin,omitempty"`
}

func (m *RedirectIPv6AddressSpecificExtended) Reset()         { *m = RedirectIPv6AddressSpecificExtended{} }
func (m *RedirectIPv6AddressSpecificExtended) String() string { return proto.CompactTextString(m) }
func (*RedirectIPv6AddressSpecificExtended) ProtoMessage()    {}
func (*RedirectIPv6AddressSpecificExtended) Descriptor() ([]byte, []int) {
	return fileDescriptorAttribute, []int{64}
}

func (m *RedirectIPv6AddressSpecificExtended) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *RedirectIPv6AddressSpecificExtended) GetLocalAdmin() uint32 {
	if m != nil {
		return m.LocalAdmin
	}
	return 0
}

type IP6ExtendedCommunitiesAttribute struct {
	// Each Community must be one of:
	// - IPv6AddressSpecificExtended
	// - RedirectIPv6AddressSpecificExtended
	Communities []*google_protobuf.Any `protobuf:"bytes,1,rep,name=communities" json:"communities,omitempty"`
}

func (m *IP6ExtendedCommunitiesAttribute) Reset()         { *m = IP6ExtendedCommunitiesAttribute{} }
func (m *IP6ExtendedCommunitiesAttribute) String() string { return proto.CompactTextString(m) }
func (*IP6ExtendedCommunitiesAttribute) ProtoMessage()    {}
func (*IP6ExtendedCommunitiesAttribute) Descriptor() ([]byte, []int) {
	return fileDescriptorAttribute, []int{65}
}

func (m *IP6ExtendedCommunitiesAttribute) GetCommunities() []*google_protobuf.Any {
	if m != nil {
		return m.Communities
	}
	return nil
}

type AigpTLVIGPMetric struct {
	Metric uint64 `protobuf:"varint,1,opt,name=metric,proto3" json:"metric,omitempty"`
}

func (m *AigpTLVIGPMetric) Reset()                    { *m = AigpTLVIGPMetric{} }
func (m *AigpTLVIGPMetric) String() string            { return proto.CompactTextString(m) }
func (*AigpTLVIGPMetric) ProtoMessage()               {}
func (*AigpTLVIGPMetric) Descriptor() ([]byte, []int) { return fileDescriptorAttribute, []int{66} }

func (m *AigpTLVIGPMetric) GetMetric() uint64 {
	if m != nil {
		return m.Metric
	}
	return 0
}

type AigpTLVUnknown struct {
	Type  uint32 `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	Value []byte `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *AigpTLVUnknown) Reset()                    { *m = AigpTLVUnknown{} }
func (m *AigpTLVUnknown) String() string            { return proto.CompactTextString(m) }
func (*AigpTLVUnknown) ProtoMessage()               {}
func (*AigpTLVUnknown) Descriptor() ([]byte, []int) { return fileDescriptorAttribute, []int{67} }

func (m *AigpTLVUnknown) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *AigpTLVUnknown) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

type AigpAttribute struct {
	// Each TLV must be one of:
	// - AigpTLVIGPMetric
	// - AigpTLVUnknown
	Tlvs []*google_protobuf.Any `protobuf:"bytes,1,rep,name=tlvs" json:"tlvs,omitempty"`
}

func (m *AigpAttribute) Reset()                    { *m = AigpAttribute{} }
func (m *AigpAttribute) String() string            { return proto.CompactTextString(m) }
func (*AigpAttribute) ProtoMessage()               {}
func (*AigpAttribute) Descriptor() ([]byte, []int) { return fileDescriptorAttribute, []int{68} }

func (m *AigpAttribute) GetTlvs() []*google_protobuf.Any {
	if m != nil {
		return m.Tlvs
	}
	return nil
}

type LargeCommunity struct {
	GlobalAdmin uint32 `protobuf:"varint,1,opt,name=global_admin,json=globalAdmin,proto3" json:"global_admin,omitempty"`
	LocalData1  uint32 `protobuf:"varint,2,opt,name=local_data1,json=localData1,proto3" json:"local_data1,omitempty"`
	LocalData2  uint32 `protobuf:"varint,3,opt,name=local_data2,json=localData2,proto3" json:"local_data2,omitempty"`
}

func (m *LargeCommunity) Reset()                    { *m = LargeCommunity{} }
func (m *LargeCommunity) String() string            { return proto.CompactTextString(m) }
func (*LargeCommunity) ProtoMessage()               {}
func (*LargeCommunity) Descriptor() ([]byte, []int) { return fileDescriptorAttribute, []int{69} }

func (m *LargeCommunity) GetGlobalAdmin() uint32 {
	if m != nil {
		return m.GlobalAdmin
	}
	return 0
}

func (m *LargeCommunity) GetLocalData1() uint32 {
	if m != nil {
		return m.LocalData1
	}
	return 0
}

func (m *LargeCommunity) GetLocalData2() uint32 {
	if m != nil {
		return m.LocalData2
	}
	return 0
}

type LargeCommunitiesAttribute struct {
	Communities []*LargeCommunity `protobuf:"bytes,1,rep,name=communities" json:"communities,omitempty"`
}

func (m *LargeCommunitiesAttribute) Reset()         { *m = LargeCommunitiesAttribute{} }
func (m *LargeCommunitiesAttribute) String() string { return proto.CompactTextString(m) }
func (*LargeCommunitiesAttribute) ProtoMessage()    {}
func (*LargeCommunitiesAttribute) Descriptor() ([]byte, []int) {
	return fileDescriptorAttribute, []int{70}
}

func (m *LargeCommunitiesAttribute) GetCommunities() []*LargeCommunity {
	if m != nil {
		return m.Communities
	}
	return nil
}

type UnknownAttribute struct {
	Flags uint32 `protobuf:"varint,1,opt,name=flags,proto3" json:"flags,omitempty"`
	Type  uint32 `protobuf:"varint,2,opt,name=type,proto3" json:"type,omitempty"`
	Value []byte `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *UnknownAttribute) Reset()                    { *m = UnknownAttribute{} }
func (m *UnknownAttribute) String() string            { return proto.CompactTextString(m) }
func (*UnknownAttribute) ProtoMessage()               {}
func (*UnknownAttribute) Descriptor() ([]byte, []int) { return fileDescriptorAttribute, []int{71} }

func (m *UnknownAttribute) GetFlags() uint32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *UnknownAttribute) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *UnknownAttribute) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func init() {
	proto.RegisterType((*OriginAttribute)(nil), "gobgpapi.OriginAttribute")
	proto.RegisterType((*AsSegment)(nil), "gobgpapi.AsSegment")
	proto.RegisterType((*AsPathAttribute)(nil), "gobgpapi.AsPathAttribute")
	proto.RegisterType((*NextHopAttribute)(nil), "gobgpapi.NextHopAttribute")
	proto.RegisterType((*MultiExitDiscAttribute)(nil), "gobgpapi.MultiExitDiscAttribute")
	proto.RegisterType((*LocalPrefAttribute)(nil), "gobgpapi.LocalPrefAttribute")
	proto.RegisterType((*AtomicAggregateAttribute)(nil), "gobgpapi.AtomicAggregateAttribute")
	proto.RegisterType((*AggregatorAttribute)(nil), "gobgpapi.AggregatorAttribute")
	proto.RegisterType((*CommunitiesAttribute)(nil), "gobgpapi.CommunitiesAttribute")
	proto.RegisterType((*OriginatorIdAttribute)(nil), "gobgpapi.OriginatorIdAttribute")
	proto.RegisterType((*ClusterListAttribute)(nil), "gobgpapi.ClusterListAttribute")
	proto.RegisterType((*IPAddressPrefix)(nil), "gobgpapi.IPAddressPrefix")
	proto.RegisterType((*LabeledIPAddressPrefix)(nil), "gobgpapi.LabeledIPAddressPrefix")
	proto.RegisterType((*EncapsulationNLRI)(nil), "gobgpapi.EncapsulationNLRI")
	proto.RegisterType((*RouteDistinguisherTwoOctetAS)(nil), "gobgpapi.RouteDistinguisherTwoOctetAS")
	proto.RegisterType((*RouteDistinguisherIPAddress)(nil), "gobgpapi.RouteDistinguisherIPAddress")
	proto.RegisterType((*RouteDistinguisherFourOctetAS)(nil), "gobgpapi.RouteDistinguisherFourOctetAS")
	proto.RegisterType((*EthernetSegmentIdentifier)(nil), "gobgpapi.EthernetSegmentIdentifier")
	proto.RegisterType((*EVPNEthernetAutoDiscoveryRoute)(nil), "gobgpapi.EVPNEthernetAutoDiscoveryRoute")
	proto.RegisterType((*EVPNMACIPAdvertisementRoute)(nil), "gobgpapi.EVPNMACIPAdvertisementRoute")
	proto.RegisterType((*EVPNInclusiveMulticastEthernetTagRoute)(nil), "gobgpapi.EVPNInclusiveMulticastEthernetTagRoute")
	proto.RegisterType((*EVPNEthernetSegmentRoute)(nil), "gobgpapi.EVPNEthernetSegmentRoute")
	proto.RegisterType((*EVPNIPPrefixRoute)(nil), "gobgpapi.EVPNIPPrefixRoute")
	proto.RegisterType((*LabeledVPNIPAddressPrefix)(nil), "gobgpapi.LabeledVPNIPAddressPrefix")
	proto.RegisterType((*RouteTargetMembershipNLRI)(nil), "gobgpapi.RouteTargetMembershipNLRI")
	proto.RegisterType((*FlowSpecIPPrefix)(nil), "gobgpapi.FlowSpecIPPrefix")
	proto.RegisterType((*FlowSpecMAC)(nil), "gobgpapi.FlowSpecMAC")
	proto.RegisterType((*FlowSpecComponentItem)(nil), "gobgpapi.FlowSpecComponentItem")
	proto.RegisterType((*FlowSpecComponent)(nil), "gobgpapi.FlowSpecComponent")
	proto.RegisterType((*FlowSpecNLRI)(nil), "gobgpapi.FlowSpecNLRI")
	proto.RegisterType((*VPNFlowSpecNLRI)(nil), "gobgpapi.VPNFlowSpecNLRI")
	proto.RegisterType((*OpaqueNLRI)(nil), "gobgpapi.OpaqueNLRI")
	proto.RegisterType((*MpReachNLRIAttribute)(nil), "gobgpapi.MpReachNLRIAttribute")
	proto.RegisterType((*MpUnreachNLRIAttribute)(nil), "gobgpapi.MpUnreachNLRIAttribute")
	proto.RegisterType((*TwoOctetAsSpecificExtended)(nil), "gobgpapi.TwoOctetAsSpecificExtended")
	proto.RegisterType((*IPv4AddressSpecificExtended)(nil), "gobgpapi.IPv4AddressSpecificExtended")
	proto.RegisterType((*FourOctetAsSpecificExtended)(nil), "gobgpapi.FourOctetAsSpecificExtended")
	proto.RegisterType((*ValidationExtended)(nil), "gobgpapi.ValidationExtended")
	proto.RegisterType((*ColorExtended)(nil), "gobgpapi.ColorExtended")
	proto.RegisterType((*EncapExtended)(nil), "gobgpapi.EncapExtended")
	proto.RegisterType((*DefaultGatewayExtended)(nil), "gobgpapi.DefaultGatewayExtended")
	proto.RegisterType((*OpaqueExtended)(nil), "gobgpapi.OpaqueExtended")
	proto.RegisterType((*ESILabelExtended)(nil), "gobgpapi.ESILabelExtended")
	proto.RegisterType((*ESImportRouteTarget)(nil), "gobgpapi.ESImportRouteTarget")
	proto.RegisterType((*MacMobilityExtended)(nil), "gobgpapi.MacMobilityExtended")
	proto.RegisterType((*RouterMacExtended)(nil), "gobgpapi.RouterMacExtended")
	proto.RegisterType((*TrafficRateExtended)(nil), "gobgpapi.TrafficRateExtended")
	proto.RegisterType((*TrafficActionExtended)(nil), "gobgpapi.TrafficActionExtended")
	proto.RegisterType((*RedirectTwoOctetAsSpecificExtended)(nil), "gobgpapi.RedirectTwoOctetAsSpecificExtended")
	proto.RegisterType((*RedirectIPv4AddressSpecificExtended)(nil), "gobgpapi.RedirectIPv4AddressSpecificExtended")
	proto.RegisterType((*RedirectFourOctetAsSpecificExtended)(nil), "gobgpapi.RedirectFourOctetAsSpecificExtended")
	proto.RegisterType((*TrafficRemarkExtended)(nil), "gobgpapi.TrafficRemarkExtended")
	proto.RegisterType((*UnknownExtended)(nil), "gobgpapi.UnknownExtended")
	proto.RegisterType((*ExtendedCommunitiesAttribute)(nil), "gobgpapi.ExtendedCommunitiesAttribute")
	proto.RegisterType((*As4PathAttribute)(nil), "gobgpapi.As4PathAttribute")
	proto.RegisterType((*As4AggregatorAttribute)(nil), "gobgpapi.As4AggregatorAttribute")
	proto.RegisterType((*PmsiTunnelAttribute)(nil), "gobgpapi.PmsiTunnelAttribute")
	proto.RegisterType((*TunnelEncapSubTLVEncapsulation)(nil), "gobgpapi.TunnelEncapSubTLVEncapsulation")
	proto.RegisterType((*TunnelEncapSubTLVProtocol)(nil), "gobgpapi.TunnelEncapSubTLVProtocol")
	proto.RegisterType((*TunnelEncapSubTLVColor)(nil), "gobgpapi.TunnelEncapSubTLVColor")
	proto.RegisterType((*TunnelEncapSubTLVUnknown)(nil), "gobgpapi.TunnelEncapSubTLVUnknown")
	proto.RegisterType((*TunnelEncapTLV)(nil), "gobgpapi.TunnelEncapTLV")
	proto.RegisterType((*TunnelEncapAttribute)(nil), "gobgpapi.TunnelEncapAttribute")
	proto.RegisterType((*IPv6AddressSpecificExtended)(nil), "gobgpapi.IPv6AddressSpecificExtended")
	proto.RegisterType((*RedirectIPv6AddressSpecificExtended)(nil), "gobgpapi.RedirectIPv6AddressSpecificExtended")
	proto.RegisterType((*IP6ExtendedCommunitiesAttribute)(nil), "gobgpapi.IP6ExtendedCommunitiesAttribute")
	proto.RegisterType((*AigpTLVIGPMetric)(nil), "gobgpapi.AigpTLVIGPMetric")
	proto.RegisterType((*AigpTLVUnknown)(nil), "gobgpapi.AigpTLVUnknown")
	proto.RegisterType((*AigpAttribute)(nil), "gobgpapi.AigpAttribute")
	proto.RegisterType((*LargeCommunity)(nil), "gobgpapi.LargeCommunity")
	proto.RegisterType((*LargeCommunitiesAttribute)(nil), "gobgpapi.LargeCommunitiesAttribute")
	proto.RegisterType((*UnknownAttribute)(nil), "gobgpapi.UnknownAttribute")
}
func (m *OriginAttribute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OriginAttribute) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Origin != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.Origin))
	}
	return i, nil
}

func (m *AsSegment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AsSegment) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.Type))
	}
	if len(m.Numbers) > 0 {
		dAtA2 := make([]byte, len(m.Numbers)*10)
		var j1 int
		for _, num := range m.Numbers {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	return i, nil
}

func (m *AsPathAttribute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AsPathAttribute) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Segments) > 0 {
		for _, msg := range m.Segments {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAttribute(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NextHopAttribute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NextHopAttribute) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NextHop) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(len(m.NextHop)))
		i += copy(dAtA[i:], m.NextHop)
	}
	return i, nil
}

func (m *MultiExitDiscAttribute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultiExitDiscAttribute) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Med != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.Med))
	}
	return i, nil
}

func (m *LocalPrefAttribute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocalPrefAttribute) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LocalPref != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.LocalPref))
	}
	return i, nil
}

func (m *AtomicAggregateAttribute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AtomicAggregateAttribute) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *AggregatorAttribute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AggregatorAttribute) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.As != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.As))
	}
	if len(m.Address) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	return i, nil
}

func (m *CommunitiesAttribute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommunitiesAttribute) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Communities) > 0 {
		dAtA4 := make([]byte, len(m.Communities)*10)
		var j3 int
		for _, num := range m.Communities {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(j3))
		i += copy(dAtA[i:], dAtA4[:j3])
	}
	return i, nil
}

func (m *OriginatorIdAttribute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OriginatorIdAttribute) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	return i, nil
}

func (m *ClusterListAttribute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterListAttribute) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ids) > 0 {
		for _, s := range m.Ids {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *IPAddressPrefix) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPAddressPrefix) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PrefixLen != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.PrefixLen))
	}
	if len(m.Prefix) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(len(m.Prefix)))
		i += copy(dAtA[i:], m.Prefix)
	}
	return i, nil
}

func (m *LabeledIPAddressPrefix) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LabeledIPAddressPrefix) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Labels) > 0 {
		dAtA6 := make([]byte, len(m.Labels)*10)
		var j5 int
		for _, num := range m.Labels {
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(j5))
		i += copy(dAtA[i:], dAtA6[:j5])
	}
	if m.PrefixLen != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.PrefixLen))
	}
	if len(m.Prefix) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(len(m.Prefix)))
		i += copy(dAtA[i:], m.Prefix)
	}
	return i, nil
}

func (m *EncapsulationNLRI) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncapsulationNLRI) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	return i, nil
}

func (m *RouteDistinguisherTwoOctetAS) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteDistinguisherTwoOctetAS) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Admin != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.Admin))
	}
	if m.Assigned != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.Assigned))
	}
	return i, nil
}

func (m *RouteDistinguisherIPAddress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteDistinguisherIPAddress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Admin) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(len(m.Admin)))
		i += copy(dAtA[i:], m.Admin)
	}
	if m.Assigned != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.Assigned))
	}
	return i, nil
}

func (m *RouteDistinguisherFourOctetAS) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteDistinguisherFourOctetAS) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Admin != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.Admin))
	}
	if m.Assigned != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.Assigned))
	}
	return i, nil
}

func (m *EthernetSegmentIdentifier) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EthernetSegmentIdentifier) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.Type))
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	return i, nil
}

func (m *EVPNEthernetAutoDiscoveryRoute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EVPNEthernetAutoDiscoveryRoute) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rd != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.Rd.Size()))
		n7, err := m.Rd.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.Esi != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.Esi.Size()))
		n8, err := m.Esi.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.EthernetTag != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.EthernetTag))
	}
	if m.Label != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.Label))
	}
	return i, nil
}

func (m *EVPNMACIPAdvertisementRoute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EVPNMACIPAdvertisementRoute) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rd != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.Rd.Size()))
		n9, err := m.Rd.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.Esi != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.Esi.Size()))
		n10, err := m.Esi.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.EthernetTag != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.EthernetTag))
	}
	if len(m.MacAddress) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(len(m.MacAddress)))
		i += copy(dAtA[i:], m.MacAddress)
	}
	if len(m.IpAddress) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(len(m.IpAddress)))
		i += copy(dAtA[i:], m.IpAddress)
	}
	if len(m.Labels) > 0 {
		dAtA12 := make([]byte, len(m.Labels)*10)
		var j11 int
		for _, num := range m.Labels {
			for num >= 1<<7 {
				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			dAtA12[j11] = uint8(num)
			j11++
		}
		dAtA[i] = 0x32
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(j11))
		i += copy(dAtA[i:], dAtA12[:j11])
	}
	return i, nil
}

func (m *EVPNInclusiveMulticastEthernetTagRoute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EVPNInclusiveMulticastEthernetTagRoute) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rd != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.Rd.Size()))
		n13, err := m.Rd.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.EthernetTag != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.EthernetTag))
	}
	if len(m.IpAddress) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(len(m.IpAddress)))
		i += copy(dAtA[i:], m.IpAddress)
	}
	return i, nil
}

func (m *EVPNEthernetSegmentRoute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EVPNEthernetSegmentRoute) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rd != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.Rd.Size()))
		n14, err := m.Rd.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.Esi != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.Esi.Size()))
		n15, err := m.Esi.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if len(m.IpAddress) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(len(m.IpAddress)))
		i += copy(dAtA[i:], m.IpAddress)
	}
	return i, nil
}

func (m *EVPNIPPrefixRoute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EVPNIPPrefixRoute) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rd != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.Rd.Size()))
		n16, err := m.Rd.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.Esi != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.Esi.Size()))
		n17, err := m.Esi.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.EthernetTag != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.EthernetTag))
	}
	if len(m.IpPrefix) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(len(m.IpPrefix)))
		i += copy(dAtA[i:], m.IpPrefix)
	}
	if m.IpPrefixLen != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.IpPrefixLen))
	}
	if len(m.GwAddress) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(len(m.GwAddress)))
		i += copy(dAtA[i:], m.GwAddress)
	}
	if m.Label != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.Label))
	}
	return i, nil
}

func (m *LabeledVPNIPAddressPrefix) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LabeledVPNIPAddressPrefix) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Labels) > 0 {
		dAtA19 := make([]byte, len(m.Labels)*10)
		var j18 int
		for _, num := range m.Labels {
			for num >= 1<<7 {
				dAtA19[j18] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j18++
			}
			dAtA19[j18] = uint8(num)
			j18++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(j18))
		i += copy(dAtA[i:], dAtA19[:j18])
	}
	if m.Rd != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.Rd.Size()))
		n20, err := m.Rd.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.PrefixLen != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.PrefixLen))
	}
	if len(m.Prefix) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(len(m.Prefix)))
		i += copy(dAtA[i:], m.Prefix)
	}
	return i, nil
}

func (m *RouteTargetMembershipNLRI) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteTargetMembershipNLRI) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.As != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.As))
	}
	if m.Rt != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.Rt.Size()))
		n21, err := m.Rt.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	return i, nil
}

func (m *FlowSpecIPPrefix) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowSpecIPPrefix) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.Type))
	}
	if m.PrefixLen != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.PrefixLen))
	}
	if len(m.Prefix) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(len(m.Prefix)))
		i += copy(dAtA[i:], m.Prefix)
	}
	if m.Offset != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.Offset))
	}
	return i, nil
}

func (m *FlowSpecMAC) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowSpecMAC) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.Type))
	}
	if len(m.Address) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	return i, nil
}

func (m *FlowSpecComponentItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowSpecComponentItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Op != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.Op))
	}
	if m.Value != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.Value))
	}
	return i, nil
}

func (m *FlowSpecComponent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowSpecComponent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.Type))
	}
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0x12
			i++
			i = encodeVarintAttribute(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FlowSpecNLRI) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowSpecNLRI) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Rules) > 0 {
		for _, msg := range m.Rules {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAttribute(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VPNFlowSpecNLRI) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VPNFlowSpecNLRI) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rd != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.Rd.Size()))
		n22, err := m.Rd.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if len(m.Rules) > 0 {
		for _, msg := range m.Rules {
			dAtA[i] = 0x12
			i++
			i = encodeVarintAttribute(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *OpaqueNLRI) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpaqueNLRI) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	return i, nil
}

func (m *MpReachNLRIAttribute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MpReachNLRIAttribute) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Family != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.Family))
	}
	if len(m.NextHops) > 0 {
		for _, s := range m.NextHops {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Nlris) > 0 {
		for _, msg := range m.Nlris {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintAttribute(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MpUnreachNLRIAttribute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MpUnreachNLRIAttribute) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Family != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.Family))
	}
	if len(m.Nlris) > 0 {
		for _, msg := range m.Nlris {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintAttribute(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TwoOctetAsSpecificExtended) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TwoOctetAsSpecificExtended) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IsTransitive {
		dAtA[i] = 0x8
		i++
		if m.IsTransitive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SubType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.SubType))
	}
	if m.As != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.As))
	}
	if m.LocalAdmin != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.LocalAdmin))
	}
	return i, nil
}

func (m *IPv4AddressSpecificExtended) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPv4AddressSpecificExtended) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IsTransitive {
		dAtA[i] = 0x8
		i++
		if m.IsTransitive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SubType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.SubType))
	}
	if len(m.Address) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if m.LocalAdmin != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.LocalAdmin))
	}
	return i, nil
}

func (m *FourOctetAsSpecificExtended) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FourOctetAsSpecificExtended) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IsTransitive {
		dAtA[i] = 0x8
		i++
		if m.IsTransitive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SubType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.SubType))
	}
	if m.As != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.As))
	}
	if m.LocalAdmin != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.LocalAdmin))
	}
	return i, nil
}

func (m *ValidationExtended) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidationExtended) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.State != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.State))
	}
	return i, nil
}

func (m *ColorExtended) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColorExtended) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Color != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.Color))
	}
	return i, nil
}

func (m *EncapExtended) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncapExtended) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TunnelType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.TunnelType))
	}
	return i, nil
}

func (m *DefaultGatewayExtended) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DefaultGatewayExtended) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *OpaqueExtended) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpaqueExtended) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IsTransitive {
		dAtA[i] = 0x8
		i++
		if m.IsTransitive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	return i, nil
}

func (m *ESILabelExtended) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ESILabelExtended) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IsSingleActive {
		dAtA[i] = 0x8
		i++
		if m.IsSingleActive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Label != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.Label))
	}
	return i, nil
}

func (m *ESImportRouteTarget) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ESImportRouteTarget) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.EsImport) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(len(m.EsImport)))
		i += copy(dAtA[i:], m.EsImport)
	}
	return i, nil
}

func (m *MacMobilityExtended) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MacMobilityExtended) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IsSticky {
		dAtA[i] = 0x8
		i++
		if m.IsSticky {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SequenceNum != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.SequenceNum))
	}
	return i, nil
}

func (m *RouterMacExtended) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouterMacExtended) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Mac) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(len(m.Mac)))
		i += copy(dAtA[i:], m.Mac)
	}
	return i, nil
}

func (m *TrafficRateExtended) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrafficRateExtended) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.As != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.As))
	}
	if m.Rate != 0 {
		dAtA[i] = 0x15
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Rate))))
		i += 4
	}
	return i, nil
}

func (m *TrafficActionExtended) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrafficActionExtended) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Terminal {
		dAtA[i] = 0x8
		i++
		if m.Terminal {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Sample {
		dAtA[i] = 0x10
		i++
		if m.Sample {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *RedirectTwoOctetAsSpecificExtended) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RedirectTwoOctetAsSpecificExtended) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.As != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.As))
	}
	if m.LocalAdmin != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.LocalAdmin))
	}
	return i, nil
}

func (m *RedirectIPv4AddressSpecificExtended) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RedirectIPv4AddressSpecificExtended) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if m.LocalAdmin != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.LocalAdmin))
	}
	return i, nil
}

func (m *RedirectFourOctetAsSpecificExtended) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RedirectFourOctetAsSpecificExtended) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.As != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.As))
	}
	if m.LocalAdmin != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.LocalAdmin))
	}
	return i, nil
}

func (m *TrafficRemarkExtended) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrafficRemarkExtended) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Dscp != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.Dscp))
	}
	return i, nil
}

func (m *UnknownExtended) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnknownExtended) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.Type))
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	return i, nil
}

func (m *ExtendedCommunitiesAttribute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExtendedCommunitiesAttribute) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Communities) > 0 {
		for _, msg := range m.Communities {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAttribute(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *As4PathAttribute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *As4PathAttribute) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Segments) > 0 {
		for _, msg := range m.Segments {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAttribute(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *As4AggregatorAttribute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *As4AggregatorAttribute) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.As != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.As))
	}
	if len(m.Address) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	return i, nil
}

func (m *PmsiTunnelAttribute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PmsiTunnelAttribute) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Flags != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.Flags))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.Type))
	}
	if m.Label != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.Label))
	}
	if len(m.Id) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	return i, nil
}

func (m *TunnelEncapSubTLVEncapsulation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TunnelEncapSubTLVEncapsulation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.Key))
	}
	if len(m.Cookie) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(len(m.Cookie)))
		i += copy(dAtA[i:], m.Cookie)
	}
	return i, nil
}

func (m *TunnelEncapSubTLVProtocol) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TunnelEncapSubTLVProtocol) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Protocol != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.Protocol))
	}
	return i, nil
}

func (m *TunnelEncapSubTLVColor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TunnelEncapSubTLVColor) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Color != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.Color))
	}
	return i, nil
}

func (m *TunnelEncapSubTLVUnknown) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TunnelEncapSubTLVUnknown) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.Type))
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	return i, nil
}

func (m *TunnelEncapTLV) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TunnelEncapTLV) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.Type))
	}
	if len(m.Tlvs) > 0 {
		for _, msg := range m.Tlvs {
			dAtA[i] = 0x12
			i++
			i = encodeVarintAttribute(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TunnelEncapAttribute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TunnelEncapAttribute) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Tlvs) > 0 {
		for _, msg := range m.Tlvs {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAttribute(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *IPv6AddressSpecificExtended) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPv6AddressSpecificExtended) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IsTransitive {
		dAtA[i] = 0x8
		i++
		if m.IsTransitive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SubType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.SubType))
	}
	if len(m.Address) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if m.LocalAdmin != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.LocalAdmin))
	}
	return i, nil
}

func (m *RedirectIPv6AddressSpecificExtended) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RedirectIPv6AddressSpecificExtended) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if m.LocalAdmin != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.LocalAdmin))
	}
	return i, nil
}

func (m *IP6ExtendedCommunitiesAttribute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IP6ExtendedCommunitiesAttribute) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Communities) > 0 {
		for _, msg := range m.Communities {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAttribute(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AigpTLVIGPMetric) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AigpTLVIGPMetric) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metric != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.Metric))
	}
	return i, nil
}

func (m *AigpTLVUnknown) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AigpTLVUnknown) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.Type))
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	return i, nil
}

func (m *AigpAttribute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AigpAttribute) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Tlvs) > 0 {
		for _, msg := range m.Tlvs {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAttribute(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *LargeCommunity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LargeCommunity) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GlobalAdmin != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.GlobalAdmin))
	}
	if m.LocalData1 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.LocalData1))
	}
	if m.LocalData2 != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.LocalData2))
	}
	return i, nil
}

func (m *LargeCommunitiesAttribute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LargeCommunitiesAttribute) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Communities) > 0 {
		for _, msg := range m.Communities {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAttribute(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *UnknownAttribute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnknownAttribute) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Flags != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.Flags))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(m.Type))
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAttribute(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	return i, nil
}

func encodeVarintAttribute(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *OriginAttribute) Size() (n int) {
	var l int
	_ = l
	if m.Origin != 0 {
		n += 1 + sovAttribute(uint64(m.Origin))
	}
	return n
}

func (m *AsSegment) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovAttribute(uint64(m.Type))
	}
	if len(m.Numbers) > 0 {
		l = 0
		for _, e := range m.Numbers {
			l += sovAttribute(uint64(e))
		}
		n += 1 + sovAttribute(uint64(l)) + l
	}
	return n
}

func (m *AsPathAttribute) Size() (n int) {
	var l int
	_ = l
	if len(m.Segments) > 0 {
		for _, e := range m.Segments {
			l = e.Size()
			n += 1 + l + sovAttribute(uint64(l))
		}
	}
	return n
}

func (m *NextHopAttribute) Size() (n int) {
	var l int
	_ = l
	l = len(m.NextHop)
	if l > 0 {
		n += 1 + l + sovAttribute(uint64(l))
	}
	return n
}

func (m *MultiExitDiscAttribute) Size() (n int) {
	var l int
	_ = l
	if m.Med != 0 {
		n += 1 + sovAttribute(uint64(m.Med))
	}
	return n
}

func (m *LocalPrefAttribute) Size() (n int) {
	var l int
	_ = l
	if m.LocalPref != 0 {
		n += 1 + sovAttribute(uint64(m.LocalPref))
	}
	return n
}

func (m *AtomicAggregateAttribute) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *AggregatorAttribute) Size() (n int) {
	var l int
	_ = l
	if m.As != 0 {
		n += 1 + sovAttribute(uint64(m.As))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovAttribute(uint64(l))
	}
	return n
}

func (m *CommunitiesAttribute) Size() (n int) {
	var l int
	_ = l
	if len(m.Communities) > 0 {
		l = 0
		for _, e := range m.Communities {
			l += sovAttribute(uint64(e))
		}
		n += 1 + sovAttribute(uint64(l)) + l
	}
	return n
}

func (m *OriginatorIdAttribute) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovAttribute(uint64(l))
	}
	return n
}

func (m *ClusterListAttribute) Size() (n int) {
	var l int
	_ = l
	if len(m.Ids) > 0 {
		for _, s := range m.Ids {
			l = len(s)
			n += 1 + l + sovAttribute(uint64(l))
		}
	}
	return n
}

func (m *IPAddressPrefix) Size() (n int) {
	var l int
	_ = l
	if m.PrefixLen != 0 {
		n += 1 + sovAttribute(uint64(m.PrefixLen))
	}
	l = len(m.Prefix)
	if l > 0 {
		n += 1 + l + sovAttribute(uint64(l))
	}
	return n
}

func (m *LabeledIPAddressPrefix) Size() (n int) {
	var l int
	_ = l
	if len(m.Labels) > 0 {
		l = 0
		for _, e := range m.Labels {
			l += sovAttribute(uint64(e))
		}
		n += 1 + sovAttribute(uint64(l)) + l
	}
	if m.PrefixLen != 0 {
		n += 1 + sovAttribute(uint64(m.PrefixLen))
	}
	l = len(m.Prefix)
	if l > 0 {
		n += 1 + l + sovAttribute(uint64(l))
	}
	return n
}

func (m *EncapsulationNLRI) Size() (n int) {
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovAttribute(uint64(l))
	}
	return n
}

func (m *RouteDistinguisherTwoOctetAS) Size() (n int) {
	var l int
	_ = l
	if m.Admin != 0 {
		n += 1 + sovAttribute(uint64(m.Admin))
	}
	if m.Assigned != 0 {
		n += 1 + sovAttribute(uint64(m.Assigned))
	}
	return n
}

func (m *RouteDistinguisherIPAddress) Size() (n int) {
	var l int
	_ = l
	l = len(m.Admin)
	if l > 0 {
		n += 1 + l + sovAttribute(uint64(l))
	}
	if m.Assigned != 0 {
		n += 1 + sovAttribute(uint64(m.Assigned))
	}
	return n
}

func (m *RouteDistinguisherFourOctetAS) Size() (n int) {
	var l int
	_ = l
	if m.Admin != 0 {
		n += 1 + sovAttribute(uint64(m.Admin))
	}
	if m.Assigned != 0 {
		n += 1 + sovAttribute(uint64(m.Assigned))
	}
	return n
}

func (m *EthernetSegmentIdentifier) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovAttribute(uint64(m.Type))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovAttribute(uint64(l))
	}
	return n
}

func (m *EVPNEthernetAutoDiscoveryRoute) Size() (n int) {
	var l int
	_ = l
	if m.Rd != nil {
		l = m.Rd.Size()
		n += 1 + l + sovAttribute(uint64(l))
	}
	if m.Esi != nil {
		l = m.Esi.Size()
		n += 1 + l + sovAttribute(uint64(l))
	}
	if m.EthernetTag != 0 {
		n += 1 + sovAttribute(uint64(m.EthernetTag))
	}
	if m.Label != 0 {
		n += 1 + sovAttribute(uint64(m.Label))
	}
	return n
}

func (m *EVPNMACIPAdvertisementRoute) Size() (n int) {
	var l int
	_ = l
	if m.Rd != nil {
		l = m.Rd.Size()
		n += 1 + l + sovAttribute(uint64(l))
	}
	if m.Esi != nil {
		l = m.Esi.Size()
		n += 1 + l + sovAttribute(uint64(l))
	}
	if m.EthernetTag != 0 {
		n += 1 + sovAttribute(uint64(m.EthernetTag))
	}
	l = len(m.MacAddress)
	if l > 0 {
		n += 1 + l + sovAttribute(uint64(l))
	}
	l = len(m.IpAddress)
	if l > 0 {
		n += 1 + l + sovAttribute(uint64(l))
	}
	if len(m.Labels) > 0 {
		l = 0
		for _, e := range m.Labels {
			l += sovAttribute(uint64(e))
		}
		n += 1 + sovAttribute(uint64(l)) + l
	}
	return n
}

func (m *EVPNInclusiveMulticastEthernetTagRoute) Size() (n int) {
	var l int
	_ = l
	if m.Rd != nil {
		l = m.Rd.Size()
		n += 1 + l + sovAttribute(uint64(l))
	}
	if m.EthernetTag != 0 {
		n += 1 + sovAttribute(uint64(m.EthernetTag))
	}
	l = len(m.IpAddress)
	if l > 0 {
		n += 1 + l + sovAttribute(uint64(l))
	}
	return n
}

func (m *EVPNEthernetSegmentRoute) Size() (n int) {
	var l int
	_ = l
	if m.Rd != nil {
		l = m.Rd.Size()
		n += 1 + l + sovAttribute(uint64(l))
	}
	if m.Esi != nil {
		l = m.Esi.Size()
		n += 1 + l + sovAttribute(uint64(l))
	}
	l = len(m.IpAddress)
	if l > 0 {
		n += 1 + l + sovAttribute(uint64(l))
	}
	return n
}

func (m *EVPNIPPrefixRoute) Size() (n int) {
	var l int
	_ = l
	if m.Rd != nil {
		l = m.Rd.Size()
		n += 1 + l + sovAttribute(uint64(l))
	}
	if m.Esi != nil {
		l = m.Esi.Size()
		n += 1 + l + sovAttribute(uint64(l))
	}
	if m.EthernetTag != 0 {
		n += 1 + sovAttribute(uint64(m.EthernetTag))
	}
	l = len(m.IpPrefix)
	if l > 0 {
		n += 1 + l + sovAttribute(uint64(l))
	}
	if m.IpPrefixLen != 0 {
		n += 1 + sovAttribute(uint64(m.IpPrefixLen))
	}
	l = len(m.GwAddress)
	if l > 0 {
		n += 1 + l + sovAttribute(uint64(l))
	}
	if m.Label != 0 {
		n += 1 + sovAttribute(uint64(m.Label))
	}
	return n
}

func (m *LabeledVPNIPAddressPrefix) Size() (n int) {
	var l int
	_ = l
	if len(m.Labels) > 0 {
		l = 0
		for _, e := range m.Labels {
			l += sovAttribute(uint64(e))
		}
		n += 1 + sovAttribute(uint64(l)) + l
	}
	if m.Rd != nil {
		l = m.Rd.Size()
		n += 1 + l + sovAttribute(uint64(l))
	}
	if m.PrefixLen != 0 {
		n += 1 + sovAttribute(uint64(m.PrefixLen))
	}
	l = len(m.Prefix)
	if l > 0 {
		n += 1 + l + sovAttribute(uint64(l))
	}
	return n
}

func (m *RouteTargetMembershipNLRI) Size() (n int) {
	var l int
	_ = l
	if m.As != 0 {
		n += 1 + sovAttribute(uint64(m.As))
	}
	if m.Rt != nil {
		l = m.Rt.Size()
		n += 1 + l + sovAttribute(uint64(l))
	}
	return n
}

func (m *FlowSpecIPPrefix) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovAttribute(uint64(m.Type))
	}
	if m.PrefixLen != 0 {
		n += 1 + sovAttribute(uint64(m.PrefixLen))
	}
	l = len(m.Prefix)
	if l > 0 {
		n += 1 + l + sovAttribute(uint64(l))
	}
	if m.Offset != 0 {
		n += 1 + sovAttribute(uint64(m.Offset))
	}
	return n
}

func (m *FlowSpecMAC) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovAttribute(uint64(m.Type))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovAttribute(uint64(l))
	}
	return n
}

func (m *FlowSpecComponentItem) Size() (n int) {
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovAttribute(uint64(m.Op))
	}
	if m.Value != 0 {
		n += 1 + sovAttribute(uint64(m.Value))
	}
	return n
}

func (m *FlowSpecComponent) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovAttribute(uint64(m.Type))
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovAttribute(uint64(l))
		}
	}
	return n
}

func (m *FlowSpecNLRI) Size() (n int) {
	var l int
	_ = l
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovAttribute(uint64(l))
		}
	}
	return n
}

func (m *VPNFlowSpecNLRI) Size() (n int) {
	var l int
	_ = l
	if m.Rd != nil {
		l = m.Rd.Size()
		n += 1 + l + sovAttribute(uint64(l))
	}
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovAttribute(uint64(l))
		}
	}
	return n
}

func (m *OpaqueNLRI) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovAttribute(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovAttribute(uint64(l))
	}
	return n
}

func (m *MpReachNLRIAttribute) Size() (n int) {
	var l int
	_ = l
	if m.Family != 0 {
		n += 1 + sovAttribute(uint64(m.Family))
	}
	if len(m.NextHops) > 0 {
		for _, s := range m.NextHops {
			l = len(s)
			n += 1 + l + sovAttribute(uint64(l))
		}
	}
	if len(m.Nlris) > 0 {
		for _, e := range m.Nlris {
			l = e.Size()
			n += 1 + l + sovAttribute(uint64(l))
		}
	}
	return n
}

func (m *MpUnreachNLRIAttribute) Size() (n int) {
	var l int
	_ = l
	if m.Family != 0 {
		n += 1 + sovAttribute(uint64(m.Family))
	}
	if len(m.Nlris) > 0 {
		for _, e := range m.Nlris {
			l = e.Size()
			n += 1 + l + sovAttribute(uint64(l))
		}
	}
	return n
}

func (m *TwoOctetAsSpecificExtended) Size() (n int) {
	var l int
	_ = l
	if m.IsTransitive {
		n += 2
	}
	if m.SubType != 0 {
		n += 1 + sovAttribute(uint64(m.SubType))
	}
	if m.As != 0 {
		n += 1 + sovAttribute(uint64(m.As))
	}
	if m.LocalAdmin != 0 {
		n += 1 + sovAttribute(uint64(m.LocalAdmin))
	}
	return n
}

func (m *IPv4AddressSpecificExtended) Size() (n int) {
	var l int
	_ = l
	if m.IsTransitive {
		n += 2
	}
	if m.SubType != 0 {
		n += 1 + sovAttribute(uint64(m.SubType))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovAttribute(uint64(l))
	}
	if m.LocalAdmin != 0 {
		n += 1 + sovAttribute(uint64(m.LocalAdmin))
	}
	return n
}

func (m *FourOctetAsSpecificExtended) Size() (n int) {
	var l int
	_ = l
	if m.IsTransitive {
		n += 2
	}
	if m.SubType != 0 {
		n += 1 + sovAttribute(uint64(m.SubType))
	}
	if m.As != 0 {
		n += 1 + sovAttribute(uint64(m.As))
	}
	if m.LocalAdmin != 0 {
		n += 1 + sovAttribute(uint64(m.LocalAdmin))
	}
	return n
}

func (m *ValidationExtended) Size() (n int) {
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovAttribute(uint64(m.State))
	}
	return n
}

func (m *ColorExtended) Size() (n int) {
	var l int
	_ = l
	if m.Color != 0 {
		n += 1 + sovAttribute(uint64(m.Color))
	}
	return n
}

func (m *EncapExtended) Size() (n int) {
	var l int
	_ = l
	if m.TunnelType != 0 {
		n += 1 + sovAttribute(uint64(m.TunnelType))
	}
	return n
}

func (m *DefaultGatewayExtended) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *OpaqueExtended) Size() (n int) {
	var l int
	_ = l
	if m.IsTransitive {
		n += 2
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovAttribute(uint64(l))
	}
	return n
}

func (m *ESILabelExtended) Size() (n int) {
	var l int
	_ = l
	if m.IsSingleActive {
		n += 2
	}
	if m.Label != 0 {
		n += 1 + sovAttribute(uint64(m.Label))
	}
	return n
}

func (m *ESImportRouteTarget) Size() (n int) {
	var l int
	_ = l
	l = len(m.EsImport)
	if l > 0 {
		n += 1 + l + sovAttribute(uint64(l))
	}
	return n
}

func (m *MacMobilityExtended) Size() (n int) {
	var l int
	_ = l
	if m.IsSticky {
		n += 2
	}
	if m.SequenceNum != 0 {
		n += 1 + sovAttribute(uint64(m.SequenceNum))
	}
	return n
}

func (m *RouterMacExtended) Size() (n int) {
	var l int
	_ = l
	l = len(m.Mac)
	if l > 0 {
		n += 1 + l + sovAttribute(uint64(l))
	}
	return n
}

func (m *TrafficRateExtended) Size() (n int) {
	var l int
	_ = l
	if m.As != 0 {
		n += 1 + sovAttribute(uint64(m.As))
	}
	if m.Rate != 0 {
		n += 5
	}
	return n
}

func (m *TrafficActionExtended) Size() (n int) {
	var l int
	_ = l
	if m.Terminal {
		n += 2
	}
	if m.Sample {
		n += 2
	}
	return n
}

func (m *RedirectTwoOctetAsSpecificExtended) Size() (n int) {
	var l int
	_ = l
	if m.As != 0 {
		n += 1 + sovAttribute(uint64(m.As))
	}
	if m.LocalAdmin != 0 {
		n += 1 + sovAttribute(uint64(m.LocalAdmin))
	}
	return n
}

func (m *RedirectIPv4AddressSpecificExtended) Size() (n int) {
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovAttribute(uint64(l))
	}
	if m.LocalAdmin != 0 {
		n += 1 + sovAttribute(uint64(m.LocalAdmin))
	}
	return n
}

func (m *RedirectFourOctetAsSpecificExtended) Size() (n int) {
	var l int
	_ = l
	if m.As != 0 {
		n += 1 + sovAttribute(uint64(m.As))
	}
	if m.LocalAdmin != 0 {
		n += 1 + sovAttribute(uint64(m.LocalAdmin))
	}
	return n
}

func (m *TrafficRemarkExtended) Size() (n int) {
	var l int
	_ = l
	if m.Dscp != 0 {
		n += 1 + sovAttribute(uint64(m.Dscp))
	}
	return n
}

func (m *UnknownExtended) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovAttribute(uint64(m.Type))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovAttribute(uint64(l))
	}
	return n
}

func (m *ExtendedCommunitiesAttribute) Size() (n int) {
	var l int
	_ = l
	if len(m.Communities) > 0 {
		for _, e := range m.Communities {
			l = e.Size()
			n += 1 + l + sovAttribute(uint64(l))
		}
	}
	return n
}

func (m *As4PathAttribute) Size() (n int) {
	var l int
	_ = l
	if len(m.Segments) > 0 {
		for _, e := range m.Segments {
			l = e.Size()
			n += 1 + l + sovAttribute(uint64(l))
		}
	}
	return n
}

func (m *As4AggregatorAttribute) Size() (n int) {
	var l int
	_ = l
	if m.As != 0 {
		n += 1 + sovAttribute(uint64(m.As))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovAttribute(uint64(l))
	}
	return n
}

func (m *PmsiTunnelAttribute) Size() (n int) {
	var l int
	_ = l
	if m.Flags != 0 {
		n += 1 + sovAttribute(uint64(m.Flags))
	}
	if m.Type != 0 {
		n += 1 + sovAttribute(uint64(m.Type))
	}
	if m.Label != 0 {
		n += 1 + sovAttribute(uint64(m.Label))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovAttribute(uint64(l))
	}
	return n
}

func (m *TunnelEncapSubTLVEncapsulation) Size() (n int) {
	var l int
	_ = l
	if m.Key != 0 {
		n += 1 + sovAttribute(uint64(m.Key))
	}
	l = len(m.Cookie)
	if l > 0 {
		n += 1 + l + sovAttribute(uint64(l))
	}
	return n
}

func (m *TunnelEncapSubTLVProtocol) Size() (n int) {
	var l int
	_ = l
	if m.Protocol != 0 {
		n += 1 + sovAttribute(uint64(m.Protocol))
	}
	return n
}

func (m *TunnelEncapSubTLVColor) Size() (n int) {
	var l int
	_ = l
	if m.Color != 0 {
		n += 1 + sovAttribute(uint64(m.Color))
	}
	return n
}

func (m *TunnelEncapSubTLVUnknown) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovAttribute(uint64(m.Type))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovAttribute(uint64(l))
	}
	return n
}

func (m *TunnelEncapTLV) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovAttribute(uint64(m.Type))
	}
	if len(m.Tlvs) > 0 {
		for _, e := range m.Tlvs {
			l = e.Size()
			n += 1 + l + sovAttribute(uint64(l))
		}
	}
	return n
}

func (m *TunnelEncapAttribute) Size() (n int) {
	var l int
	_ = l
	if len(m.Tlvs) > 0 {
		for _, e := range m.Tlvs {
			l = e.Size()
			n += 1 + l + sovAttribute(uint64(l))
		}
	}
	return n
}

func (m *IPv6AddressSpecificExtended) Size() (n int) {
	var l int
	_ = l
	if m.IsTransitive {
		n += 2
	}
	if m.SubType != 0 {
		n += 1 + sovAttribute(uint64(m.SubType))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovAttribute(uint64(l))
	}
	if m.LocalAdmin != 0 {
		n += 1 + sovAttribute(uint64(m.LocalAdmin))
	}
	return n
}

func (m *RedirectIPv6AddressSpecificExtended) Size() (n int) {
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovAttribute(uint64(l))
	}
	if m.LocalAdmin != 0 {
		n += 1 + sovAttribute(uint64(m.LocalAdmin))
	}
	return n
}

func (m *IP6ExtendedCommunitiesAttribute) Size() (n int) {
	var l int
	_ = l
	if len(m.Communities) > 0 {
		for _, e := range m.Communities {
			l = e.Size()
			n += 1 + l + sovAttribute(uint64(l))
		}
	}
	return n
}

func (m *AigpTLVIGPMetric) Size() (n int) {
	var l int
	_ = l
	if m.Metric != 0 {
		n += 1 + sovAttribute(uint64(m.Metric))
	}
	return n
}

func (m *AigpTLVUnknown) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovAttribute(uint64(m.Type))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovAttribute(uint64(l))
	}
	return n
}

func (m *AigpAttribute) Size() (n int) {
	var l int
	_ = l
	if len(m.Tlvs) > 0 {
		for _, e := range m.Tlvs {
			l = e.Size()
			n += 1 + l + sovAttribute(uint64(l))
		}
	}
	return n
}

func (m *LargeCommunity) Size() (n int) {
	var l int
	_ = l
	if m.GlobalAdmin != 0 {
		n += 1 + sovAttribute(uint64(m.GlobalAdmin))
	}
	if m.LocalData1 != 0 {
		n += 1 + sovAttribute(uint64(m.LocalData1))
	}
	if m.LocalData2 != 0 {
		n += 1 + sovAttribute(uint64(m.LocalData2))
	}
	return n
}

func (m *LargeCommunitiesAttribute) Size() (n int) {
	var l int
	_ = l
	if len(m.Communities) > 0 {
		for _, e := range m.Communities {
			l = e.Size()
			n += 1 + l + sovAttribute(uint64(l))
		}
	}
	return n
}

func (m *UnknownAttribute) Size() (n int) {
	var l int
	_ = l
	if m.Flags != 0 {
		n += 1 + sovAttribute(uint64(m.Flags))
	}
	if m.Type != 0 {
		n += 1 + sovAttribute(uint64(m.Type))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovAttribute(uint64(l))
	}
	return n
}

func sovAttribute(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAttribute(x uint64) (n int) {
	return sovAttribute(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *OriginAttribute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OriginAttribute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OriginAttribute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Origin", wireType)
			}
			m.Origin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Origin |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AsSegment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AsSegment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AsSegment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAttribute
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Numbers = append(m.Numbers, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAttribute
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAttribute
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAttribute
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Numbers = append(m.Numbers, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Numbers", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AsPathAttribute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AsPathAttribute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AsPathAttribute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Segments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Segments = append(m.Segments, &AsSegment{})
			if err := m.Segments[len(m.Segments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NextHopAttribute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NextHopAttribute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NextHopAttribute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextHop", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextHop = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MultiExitDiscAttribute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultiExitDiscAttribute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultiExitDiscAttribute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Med", wireType)
			}
			m.Med = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Med |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocalPrefAttribute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocalPrefAttribute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocalPrefAttribute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalPref", wireType)
			}
			m.LocalPref = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocalPref |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AtomicAggregateAttribute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AtomicAggregateAttribute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AtomicAggregateAttribute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AggregatorAttribute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AggregatorAttribute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AggregatorAttribute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field As", wireType)
			}
			m.As = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.As |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommunitiesAttribute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommunitiesAttribute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommunitiesAttribute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAttribute
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Communities = append(m.Communities, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAttribute
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAttribute
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAttribute
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Communities = append(m.Communities, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Communities", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OriginatorIdAttribute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OriginatorIdAttribute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OriginatorIdAttribute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterListAttribute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterListAttribute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterListAttribute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ids", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ids = append(m.Ids, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPAddressPrefix) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPAddressPrefix: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPAddressPrefix: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixLen", wireType)
			}
			m.PrefixLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrefixLen |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LabeledIPAddressPrefix) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LabeledIPAddressPrefix: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LabeledIPAddressPrefix: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAttribute
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Labels = append(m.Labels, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAttribute
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAttribute
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAttribute
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Labels = append(m.Labels, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixLen", wireType)
			}
			m.PrefixLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrefixLen |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncapsulationNLRI) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncapsulationNLRI: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncapsulationNLRI: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteDistinguisherTwoOctetAS) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteDistinguisherTwoOctetAS: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteDistinguisherTwoOctetAS: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			m.Admin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Admin |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assigned", wireType)
			}
			m.Assigned = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Assigned |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteDistinguisherIPAddress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteDistinguisherIPAddress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteDistinguisherIPAddress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Admin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assigned", wireType)
			}
			m.Assigned = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Assigned |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteDistinguisherFourOctetAS) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteDistinguisherFourOctetAS: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteDistinguisherFourOctetAS: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			m.Admin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Admin |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assigned", wireType)
			}
			m.Assigned = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Assigned |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EthernetSegmentIdentifier) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EthernetSegmentIdentifier: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EthernetSegmentIdentifier: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EVPNEthernetAutoDiscoveryRoute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EVPNEthernetAutoDiscoveryRoute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EVPNEthernetAutoDiscoveryRoute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rd == nil {
				m.Rd = &google_protobuf.Any{}
			}
			if err := m.Rd.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Esi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Esi == nil {
				m.Esi = &EthernetSegmentIdentifier{}
			}
			if err := m.Esi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EthernetTag", wireType)
			}
			m.EthernetTag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EthernetTag |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			m.Label = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Label |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EVPNMACIPAdvertisementRoute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EVPNMACIPAdvertisementRoute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EVPNMACIPAdvertisementRoute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rd == nil {
				m.Rd = &google_protobuf.Any{}
			}
			if err := m.Rd.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Esi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Esi == nil {
				m.Esi = &EthernetSegmentIdentifier{}
			}
			if err := m.Esi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EthernetTag", wireType)
			}
			m.EthernetTag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EthernetTag |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MacAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAttribute
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Labels = append(m.Labels, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAttribute
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAttribute
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAttribute
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Labels = append(m.Labels, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EVPNInclusiveMulticastEthernetTagRoute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EVPNInclusiveMulticastEthernetTagRoute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EVPNInclusiveMulticastEthernetTagRoute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rd == nil {
				m.Rd = &google_protobuf.Any{}
			}
			if err := m.Rd.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EthernetTag", wireType)
			}
			m.EthernetTag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EthernetTag |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EVPNEthernetSegmentRoute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EVPNEthernetSegmentRoute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EVPNEthernetSegmentRoute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rd == nil {
				m.Rd = &google_protobuf.Any{}
			}
			if err := m.Rd.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Esi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Esi == nil {
				m.Esi = &EthernetSegmentIdentifier{}
			}
			if err := m.Esi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EVPNIPPrefixRoute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EVPNIPPrefixRoute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EVPNIPPrefixRoute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rd == nil {
				m.Rd = &google_protobuf.Any{}
			}
			if err := m.Rd.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Esi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Esi == nil {
				m.Esi = &EthernetSegmentIdentifier{}
			}
			if err := m.Esi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EthernetTag", wireType)
			}
			m.EthernetTag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EthernetTag |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpPrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpPrefixLen", wireType)
			}
			m.IpPrefixLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpPrefixLen |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GwAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GwAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			m.Label = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Label |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LabeledVPNIPAddressPrefix) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LabeledVPNIPAddressPrefix: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LabeledVPNIPAddressPrefix: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAttribute
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Labels = append(m.Labels, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAttribute
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAttribute
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAttribute
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Labels = append(m.Labels, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rd == nil {
				m.Rd = &google_protobuf.Any{}
			}
			if err := m.Rd.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixLen", wireType)
			}
			m.PrefixLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrefixLen |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteTargetMembershipNLRI) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteTargetMembershipNLRI: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteTargetMembershipNLRI: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field As", wireType)
			}
			m.As = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.As |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rt == nil {
				m.Rt = &google_protobuf.Any{}
			}
			if err := m.Rt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowSpecIPPrefix) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowSpecIPPrefix: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowSpecIPPrefix: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixLen", wireType)
			}
			m.PrefixLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrefixLen |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowSpecMAC) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowSpecMAC: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowSpecMAC: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowSpecComponentItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowSpecComponentItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowSpecComponentItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowSpecComponent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowSpecComponent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowSpecComponent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &FlowSpecComponentItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowSpecNLRI) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowSpecNLRI: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowSpecNLRI: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, &google_protobuf.Any{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VPNFlowSpecNLRI) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VPNFlowSpecNLRI: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VPNFlowSpecNLRI: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rd == nil {
				m.Rd = &google_protobuf.Any{}
			}
			if err := m.Rd.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, &google_protobuf.Any{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpaqueNLRI) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpaqueNLRI: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpaqueNLRI: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MpReachNLRIAttribute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MpReachNLRIAttribute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MpReachNLRIAttribute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Family", wireType)
			}
			m.Family = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Family |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextHops", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextHops = append(m.NextHops, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nlris", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nlris = append(m.Nlris, &google_protobuf.Any{})
			if err := m.Nlris[len(m.Nlris)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MpUnreachNLRIAttribute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MpUnreachNLRIAttribute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MpUnreachNLRIAttribute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Family", wireType)
			}
			m.Family = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Family |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nlris", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nlris = append(m.Nlris, &google_protobuf.Any{})
			if err := m.Nlris[len(m.Nlris)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TwoOctetAsSpecificExtended) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TwoOctetAsSpecificExtended: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TwoOctetAsSpecificExtended: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsTransitive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsTransitive = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubType", wireType)
			}
			m.SubType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field As", wireType)
			}
			m.As = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.As |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalAdmin", wireType)
			}
			m.LocalAdmin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocalAdmin |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPv4AddressSpecificExtended) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPv4AddressSpecificExtended: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPv4AddressSpecificExtended: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsTransitive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsTransitive = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubType", wireType)
			}
			m.SubType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalAdmin", wireType)
			}
			m.LocalAdmin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocalAdmin |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FourOctetAsSpecificExtended) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FourOctetAsSpecificExtended: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FourOctetAsSpecificExtended: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsTransitive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsTransitive = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubType", wireType)
			}
			m.SubType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field As", wireType)
			}
			m.As = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.As |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalAdmin", wireType)
			}
			m.LocalAdmin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocalAdmin |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidationExtended) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidationExtended: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidationExtended: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColorExtended) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColorExtended: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColorExtended: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Color", wireType)
			}
			m.Color = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Color |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncapExtended) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncapExtended: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncapExtended: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunnelType", wireType)
			}
			m.TunnelType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TunnelType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefaultGatewayExtended) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefaultGatewayExtended: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefaultGatewayExtended: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpaqueExtended) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpaqueExtended: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpaqueExtended: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsTransitive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsTransitive = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ESILabelExtended) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ESILabelExtended: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ESILabelExtended: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSingleActive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSingleActive = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			m.Label = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Label |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ESImportRouteTarget) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ESImportRouteTarget: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ESImportRouteTarget: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EsImport", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EsImport = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MacMobilityExtended) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MacMobilityExtended: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MacMobilityExtended: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSticky", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSticky = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceNum", wireType)
			}
			m.SequenceNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceNum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouterMacExtended) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouterMacExtended: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouterMacExtended: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mac", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mac = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrafficRateExtended) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrafficRateExtended: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrafficRateExtended: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field As", wireType)
			}
			m.As = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.As |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rate", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Rate = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrafficActionExtended) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrafficActionExtended: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrafficActionExtended: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Terminal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Terminal = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sample", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Sample = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RedirectTwoOctetAsSpecificExtended) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RedirectTwoOctetAsSpecificExtended: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RedirectTwoOctetAsSpecificExtended: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field As", wireType)
			}
			m.As = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.As |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalAdmin", wireType)
			}
			m.LocalAdmin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocalAdmin |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RedirectIPv4AddressSpecificExtended) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RedirectIPv4AddressSpecificExtended: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RedirectIPv4AddressSpecificExtended: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalAdmin", wireType)
			}
			m.LocalAdmin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocalAdmin |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RedirectFourOctetAsSpecificExtended) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RedirectFourOctetAsSpecificExtended: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RedirectFourOctetAsSpecificExtended: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field As", wireType)
			}
			m.As = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.As |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalAdmin", wireType)
			}
			m.LocalAdmin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocalAdmin |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrafficRemarkExtended) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrafficRemarkExtended: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrafficRemarkExtended: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dscp", wireType)
			}
			m.Dscp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dscp |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnknownExtended) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnknownExtended: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnknownExtended: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExtendedCommunitiesAttribute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExtendedCommunitiesAttribute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExtendedCommunitiesAttribute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Communities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Communities = append(m.Communities, &google_protobuf.Any{})
			if err := m.Communities[len(m.Communities)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *As4PathAttribute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: As4PathAttribute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: As4PathAttribute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Segments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Segments = append(m.Segments, &AsSegment{})
			if err := m.Segments[len(m.Segments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *As4AggregatorAttribute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: As4AggregatorAttribute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: As4AggregatorAttribute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field As", wireType)
			}
			m.As = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.As |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PmsiTunnelAttribute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PmsiTunnelAttribute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PmsiTunnelAttribute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			m.Label = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Label |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TunnelEncapSubTLVEncapsulation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TunnelEncapSubTLVEncapsulation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TunnelEncapSubTLVEncapsulation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Key |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cookie", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cookie = append(m.Cookie[:0], dAtA[iNdEx:postIndex]...)
			if m.Cookie == nil {
				m.Cookie = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TunnelEncapSubTLVProtocol) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TunnelEncapSubTLVProtocol: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TunnelEncapSubTLVProtocol: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			m.Protocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Protocol |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TunnelEncapSubTLVColor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TunnelEncapSubTLVColor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TunnelEncapSubTLVColor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Color", wireType)
			}
			m.Color = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Color |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TunnelEncapSubTLVUnknown) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TunnelEncapSubTLVUnknown: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TunnelEncapSubTLVUnknown: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TunnelEncapTLV) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TunnelEncapTLV: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TunnelEncapTLV: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tlvs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tlvs = append(m.Tlvs, &google_protobuf.Any{})
			if err := m.Tlvs[len(m.Tlvs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TunnelEncapAttribute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TunnelEncapAttribute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TunnelEncapAttribute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tlvs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tlvs = append(m.Tlvs, &TunnelEncapTLV{})
			if err := m.Tlvs[len(m.Tlvs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPv6AddressSpecificExtended) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPv6AddressSpecificExtended: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPv6AddressSpecificExtended: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsTransitive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsTransitive = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubType", wireType)
			}
			m.SubType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalAdmin", wireType)
			}
			m.LocalAdmin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocalAdmin |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RedirectIPv6AddressSpecificExtended) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RedirectIPv6AddressSpecificExtended: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RedirectIPv6AddressSpecificExtended: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalAdmin", wireType)
			}
			m.LocalAdmin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocalAdmin |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IP6ExtendedCommunitiesAttribute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IP6ExtendedCommunitiesAttribute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IP6ExtendedCommunitiesAttribute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Communities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Communities = append(m.Communities, &google_protobuf.Any{})
			if err := m.Communities[len(m.Communities)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AigpTLVIGPMetric) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AigpTLVIGPMetric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AigpTLVIGPMetric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metric", wireType)
			}
			m.Metric = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Metric |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AigpTLVUnknown) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AigpTLVUnknown: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AigpTLVUnknown: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AigpAttribute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AigpAttribute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AigpAttribute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tlvs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tlvs = append(m.Tlvs, &google_protobuf.Any{})
			if err := m.Tlvs[len(m.Tlvs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LargeCommunity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LargeCommunity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LargeCommunity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalAdmin", wireType)
			}
			m.GlobalAdmin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GlobalAdmin |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalData1", wireType)
			}
			m.LocalData1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocalData1 |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalData2", wireType)
			}
			m.LocalData2 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocalData2 |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LargeCommunitiesAttribute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LargeCommunitiesAttribute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LargeCommunitiesAttribute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Communities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Communities = append(m.Communities, &LargeCommunity{})
			if err := m.Communities[len(m.Communities)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnknownAttribute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnknownAttribute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnknownAttribute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAttribute
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAttribute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttribute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAttribute(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAttribute
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAttribute
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthAttribute
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAttribute
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAttribute(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAttribute = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAttribute   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("attribute.proto", fileDescriptorAttribute) }

var fileDescriptorAttribute = []byte{
	// 1890 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x58, 0xdb, 0x6e, 0x1b, 0xc9,
	0x11, 0x05, 0x2f, 0x92, 0xc9, 0xa2, 0x28, 0xc9, 0x94, 0x2c, 0x50, 0xd2, 0x5a, 0x72, 0xda, 0xd9,
	0x44, 0x71, 0xb2, 0x72, 0xa2, 0xf5, 0x3a, 0xb1, 0x17, 0x41, 0x40, 0x4b, 0xda, 0x5d, 0x66, 0x45,
	0x99, 0x3b, 0x92, 0x15, 0x04, 0x08, 0xc2, 0x34, 0x67, 0x9a, 0xa3, 0x86, 0xe6, 0xb6, 0xd3, 0x3d,
	0xba, 0x7c, 0x42, 0x1e, 0x12, 0xec, 0x53, 0x90, 0x2f, 0xc9, 0x37, 0xe4, 0x31, 0x9f, 0x10, 0xf8,
	0x1f, 0xf2, 0x1e, 0xf4, 0x6d, 0x2e, 0xa2, 0xa8, 0x8b, 0x77, 0x0d, 0xf8, 0xad, 0xab, 0x59, 0x5d,
	0x55, 0x7d, 0xba, 0xea, 0x54, 0x71, 0x60, 0x0e, 0x73, 0x1e, 0xd3, 0x61, 0xc2, 0xc9, 0x66, 0x14,
	0x87, 0x3c, 0x6c, 0xd5, 0xdc, 0x70, 0xe8, 0x46, 0x38, 0xa2, 0x2b, 0xcb, 0x6e, 0x18, 0xba, 0x1e,
	0x79, 0x2a, 0xf7, 0x87, 0xc9, 0xe8, 0x29, 0x0e, 0x2e, 0x94, 0x12, 0xfa, 0x19, 0xcc, 0xbd, 0x8e,
	0xa9, 0x4b, 0x83, 0x8e, 0x39, 0xdd, 0x5a, 0x82, 0xe9, 0x50, 0x6e, 0xb5, 0x4b, 0x8f, 0x4a, 0x1b,
	0x4d, 0x4b, 0x4b, 0xe8, 0x05, 0xd4, 0x3b, 0xec, 0x80, 0xb8, 0x3e, 0x09, 0x78, 0xab, 0x05, 0x55,
	0x7e, 0x11, 0x11, 0xad, 0x22, 0xd7, 0xad, 0x36, 0xdc, 0x0b, 0x12, 0x7f, 0x48, 0x62, 0xd6, 0x2e,
	0x3f, 0xaa, 0x6c, 0x34, 0x2d, 0x23, 0xa2, 0x57, 0x30, 0xd7, 0x61, 0x7d, 0xcc, 0x8f, 0x33, 0x2f,
	0x4f, 0xa1, 0xc6, 0x94, 0x2d, 0xd6, 0x2e, 0x3d, 0xaa, 0x6c, 0x34, 0xb6, 0x16, 0x36, 0x4d, 0xc0,
	0x9b, 0xa9, 0x1f, 0x2b, 0x55, 0x42, 0x9f, 0xc0, 0xfc, 0x3e, 0x39, 0xe7, 0x5f, 0x85, 0x51, 0x66,
	0x64, 0x19, 0x6a, 0x01, 0x39, 0xe7, 0x83, 0xe3, 0x30, 0x92, 0x91, 0xd4, 0xad, 0x7b, 0x81, 0xd2,
	0x41, 0x4f, 0x60, 0xa9, 0x97, 0x78, 0x9c, 0xee, 0x9e, 0x53, 0xbe, 0x43, 0x99, 0x9d, 0x1d, 0x9a,
	0x87, 0x8a, 0x4f, 0x1c, 0x1d, 0xb9, 0x58, 0xa2, 0x4f, 0xa1, 0xb5, 0x17, 0xda, 0xd8, 0xeb, 0xc7,
	0x64, 0x94, 0xe9, 0x3d, 0x04, 0xf0, 0xc4, 0xee, 0x20, 0x8a, 0xc9, 0x48, 0xab, 0xd7, 0x3d, 0xa3,
	0x87, 0x56, 0xa0, 0xdd, 0xe1, 0xa1, 0x4f, 0xed, 0x8e, 0xeb, 0xc6, 0xc4, 0xc5, 0x9c, 0xa4, 0x47,
	0xd1, 0xef, 0x60, 0xc1, 0xec, 0x86, 0x71, 0x66, 0x71, 0x16, 0xca, 0x58, 0x60, 0x23, 0x2c, 0x95,
	0x31, 0x13, 0x80, 0x61, 0xc7, 0x89, 0x09, 0x63, 0xed, 0x8a, 0x8a, 0x5e, 0x8b, 0xe8, 0x37, 0xb0,
	0xb8, 0x1d, 0xfa, 0x7e, 0x12, 0x50, 0x4e, 0x09, 0xcb, 0x2c, 0x3c, 0x82, 0x86, 0x9d, 0xed, 0x4b,
	0xe0, 0x9a, 0x56, 0x7e, 0x0b, 0xfd, 0x14, 0x1e, 0xa8, 0x07, 0x15, 0xae, 0xbb, 0x4e, 0xc1, 0x39,
	0x75, 0x34, 0x4a, 0x65, 0xea, 0xa0, 0x0d, 0x58, 0xdc, 0xf6, 0x12, 0xc6, 0x49, 0xbc, 0x47, 0x19,
	0x2f, 0xc0, 0x43, 0x1d, 0x65, 0xba, 0x6e, 0x89, 0x25, 0xfa, 0x0a, 0xe6, 0xba, 0xfd, 0x8e, 0x8a,
	0x4c, 0x5c, 0x9d, 0x9e, 0x0b, 0x6c, 0x22, 0xb9, 0x1a, 0x78, 0xc4, 0xe4, 0x49, 0x5d, 0xed, 0xec,
	0x91, 0x40, 0xa4, 0x90, 0x12, 0xe4, 0x65, 0xeb, 0x96, 0x96, 0x90, 0x0b, 0x4b, 0x7b, 0x78, 0x48,
	0x3c, 0xe2, 0x5c, 0x36, 0xb8, 0x04, 0xd3, 0x9e, 0xf8, 0xc5, 0xdc, 0x49, 0x4b, 0x97, 0x1c, 0x95,
	0x27, 0x3b, 0xaa, 0x14, 0x1c, 0x7d, 0x02, 0xf7, 0x77, 0x03, 0x1b, 0x47, 0x2c, 0xf1, 0x30, 0xa7,
	0x61, 0xb0, 0xbf, 0x67, 0x75, 0xf3, 0x70, 0x97, 0x8a, 0x70, 0xf7, 0xe1, 0x23, 0x2b, 0x4c, 0x38,
	0xd9, 0xa1, 0x8c, 0xd3, 0xc0, 0x4d, 0x28, 0x3b, 0x26, 0xf1, 0xe1, 0x59, 0xf8, 0xda, 0xe6, 0x84,
	0x77, 0x0e, 0x5a, 0x8b, 0x30, 0x85, 0x1d, 0x3f, 0xad, 0x08, 0x25, 0xb4, 0x56, 0xa0, 0x86, 0x19,
	0xa3, 0x6e, 0x40, 0x1c, 0x1d, 0x59, 0x2a, 0xa3, 0xd7, 0xb0, 0x3a, 0x6e, 0x31, 0xbd, 0x74, 0xd1,
	0x60, 0xfd, 0x36, 0x06, 0xbf, 0x81, 0x87, 0xe3, 0x06, 0xbf, 0x08, 0x93, 0xf8, 0xdd, 0x63, 0xdc,
	0x85, 0xe5, 0x5d, 0x7e, 0x4c, 0xe2, 0x80, 0x70, 0x5d, 0x6e, 0x5d, 0x87, 0x04, 0x9c, 0x8e, 0x28,
	0x89, 0xaf, 0x2c, 0xf0, 0x45, 0x98, 0x3a, 0xc5, 0x5e, 0x42, 0xa4, 0xa5, 0x19, 0x4b, 0x09, 0xe8,
	0x5f, 0x25, 0x58, 0xdb, 0x3d, 0xea, 0xef, 0x1b, 0x5b, 0x9d, 0x84, 0x87, 0xa2, 0xe2, 0xc2, 0x53,
	0x12, 0x5f, 0xc8, 0x98, 0x5b, 0x3f, 0x86, 0x72, 0xac, 0x72, 0xaf, 0xb1, 0xb5, 0xb8, 0xa9, 0xd8,
	0x68, 0xd3, 0xb0, 0xd1, 0x66, 0x27, 0xb8, 0xb0, 0xca, 0xb1, 0xd3, 0xfa, 0x0c, 0x2a, 0x84, 0x51,
	0x69, 0xbc, 0xb1, 0xf5, 0x38, 0x63, 0x83, 0x89, 0x41, 0x5a, 0x42, 0xbf, 0xf5, 0x23, 0x98, 0x21,
	0x5a, 0x63, 0xc0, 0xb1, 0x2b, 0x33, 0xa1, 0x69, 0x35, 0xcc, 0xde, 0x21, 0x76, 0x45, 0xe0, 0x32,
	0x9f, 0xda, 0x55, 0x85, 0x8d, 0x14, 0xd0, 0xff, 0x4a, 0xb0, 0x2a, 0x02, 0xef, 0x75, 0xb6, 0xc5,
	0xcb, 0x9c, 0x92, 0x98, 0x53, 0x46, 0x24, 0xed, 0x7c, 0x10, 0x51, 0xaf, 0x43, 0xc3, 0xc7, 0xf6,
	0xc0, 0xe4, 0x6c, 0x55, 0xa6, 0x0a, 0xf8, 0xd8, 0x36, 0x59, 0xf4, 0x10, 0x80, 0x46, 0xe9, 0xef,
	0x53, 0xf2, 0xf7, 0x3a, 0x8d, 0xcc, 0xcf, 0x59, 0x4d, 0x4d, 0xe7, 0x6b, 0x0a, 0x7d, 0x57, 0x82,
	0x9f, 0x88, 0x7b, 0x77, 0x03, 0xdb, 0x4b, 0x18, 0x3d, 0x25, 0x92, 0x28, 0x6d, 0xcc, 0xf8, 0x6e,
	0xe6, 0xfd, 0x2e, 0x10, 0x5c, 0xbe, 0x4b, 0x79, 0xfc, 0x2e, 0xc5, 0x50, 0x2b, 0x97, 0x42, 0x45,
	0xff, 0x28, 0x41, 0x3b, 0x9f, 0x43, 0x86, 0xfe, 0xdf, 0xff, 0x3b, 0xdc, 0x10, 0xd8, 0x5f, 0xcb,
	0x70, 0x5f, 0x62, 0xd5, 0x57, 0x44, 0xf5, 0x61, 0x64, 0xc6, 0x2a, 0xd4, 0x69, 0x34, 0xd0, 0xcc,
	0xa7, 0xf2, 0xa2, 0x46, 0x23, 0x4d, 0xa5, 0x08, 0x9a, 0xe9, 0x8f, 0x92, 0x35, 0xa7, 0x94, 0x01,
	0xa3, 0x20, 0x78, 0xf3, 0x21, 0x80, 0x7b, 0x96, 0xde, 0x7a, 0x5a, 0xdd, 0xda, 0x3d, 0xcb, 0xd1,
	0x93, 0xaa, 0x97, 0x7b, 0xf9, 0x7a, 0xf9, 0xae, 0x04, 0xcb, 0x9a, 0xbe, 0x25, 0x22, 0xb7, 0x63,
	0x70, 0x85, 0x55, 0xf9, 0x06, 0xac, 0x8a, 0x3c, 0x5f, 0x99, 0xcc, 0xf3, 0xd5, 0x02, 0xcf, 0x7f,
	0x03, 0xcb, 0xf2, 0x45, 0x0e, 0x71, 0xec, 0x12, 0xde, 0x23, 0x72, 0xdc, 0x38, 0xa6, 0x91, 0xe4,
	0x7b, 0xd5, 0x6e, 0x4b, 0x69, 0xbb, 0x15, 0x91, 0xf0, 0x1b, 0x22, 0xe1, 0x28, 0x81, 0xf9, 0x2f,
	0xbc, 0xf0, 0xec, 0x20, 0x22, 0xb6, 0x79, 0xf4, 0x2b, 0xc9, 0xf0, 0xdd, 0x3a, 0x93, 0x9c, 0xae,
	0x46, 0x23, 0x46, 0xb8, 0xe6, 0x22, 0x2d, 0xa1, 0xcf, 0xa1, 0x61, 0xdc, 0xf6, 0x3a, 0xdb, 0x93,
	0xe6, 0x2b, 0xf3, 0x62, 0xe5, 0x62, 0xff, 0xfa, 0x2d, 0x3c, 0x30, 0x87, 0xb7, 0x43, 0x3f, 0x0a,
	0x03, 0x91, 0x56, 0x9c, 0xf8, 0x02, 0x02, 0x3d, 0x1a, 0x35, 0xad, 0x72, 0x18, 0x15, 0x19, 0xbc,
	0x6a, 0x18, 0xfc, 0xcf, 0x70, 0x7f, 0xec, 0xf8, 0x95, 0x11, 0x7c, 0x06, 0x53, 0x94, 0x13, 0x5f,
	0xcd, 0x77, 0x8d, 0xad, 0xf5, 0x2c, 0xa7, 0xaf, 0x74, 0x6f, 0x29, 0x6d, 0xf4, 0x12, 0x66, 0xcc,
	0xef, 0xf2, 0x61, 0x9e, 0xc0, 0x54, 0x9c, 0x78, 0xc4, 0x0c, 0x7e, 0x57, 0xbf, 0x85, 0x52, 0x41,
	0x36, 0xcc, 0x1d, 0xf5, 0xf7, 0x0b, 0xc7, 0x6f, 0x57, 0x7d, 0xa9, 0x93, 0xf2, 0xcd, 0x4e, 0x9e,
	0x01, 0xbc, 0x8e, 0xf0, 0xb7, 0x09, 0x91, 0xf6, 0xe7, 0xa1, 0x72, 0x42, 0x2e, 0xa4, 0x83, 0x19,
	0x4b, 0x2c, 0x27, 0x34, 0xbe, 0x33, 0x58, 0xec, 0x45, 0x16, 0xc1, 0xf6, 0xb1, 0x38, 0x56, 0x18,
	0xa0, 0x47, 0xd8, 0xa7, 0xde, 0x85, 0x19, 0xa0, 0x95, 0x24, 0xaa, 0xd6, 0x4c, 0xab, 0x2a, 0xaa,
	0xba, 0x55, 0xd3, 0xe3, 0x2a, 0x13, 0xe1, 0x06, 0x5e, 0x4c, 0x05, 0x05, 0x5d, 0x13, 0xae, 0x54,
	0x41, 0x7f, 0x82, 0xa5, 0x5e, 0xf4, 0x26, 0x88, 0x6f, 0xef, 0xfa, 0x2e, 0xd6, 0xff, 0x56, 0x82,
	0x95, 0x74, 0xf6, 0x61, 0x02, 0x75, 0x3a, 0xa2, 0xf6, 0xee, 0x39, 0x27, 0x81, 0x43, 0x9c, 0xd6,
	0x63, 0x68, 0x52, 0x36, 0xe0, 0x31, 0x0e, 0x18, 0xe5, 0xf4, 0x54, 0x25, 0x48, 0xcd, 0x9a, 0xa1,
	0xec, 0x30, 0xdd, 0x13, 0x83, 0x39, 0x4b, 0x86, 0x03, 0x99, 0x40, 0xaa, 0x34, 0xee, 0xb1, 0x64,
	0x78, 0x28, 0x72, 0x48, 0x55, 0x65, 0x25, 0xad, 0xca, 0x75, 0x68, 0xa8, 0x31, 0x5b, 0x4d, 0x2f,
	0xaa, 0x2a, 0xd4, 0xe4, 0xdd, 0x11, 0x3b, 0xe8, 0x9f, 0x25, 0x58, 0xed, 0xf6, 0x4f, 0x9f, 0x69,
	0xba, 0xf9, 0xc1, 0x03, 0x9a, 0x38, 0x85, 0xdf, 0x1c, 0xda, 0xdf, 0x4b, 0xb0, 0x9a, 0xcd, 0x60,
	0x1f, 0x00, 0x56, 0x4f, 0xa0, 0x75, 0x84, 0x3d, 0xea, 0xc8, 0xa1, 0x37, 0x0d, 0x63, 0x11, 0xa6,
	0x18, 0xc7, 0xdc, 0xd4, 0xb2, 0x12, 0xd0, 0xc7, 0xd0, 0xdc, 0x0e, 0xbd, 0x30, 0xce, 0xab, 0xd9,
	0x62, 0xc3, 0xa8, 0x49, 0x01, 0xfd, 0x12, 0x9a, 0x72, 0x94, 0x4e, 0xd5, 0xd6, 0xa1, 0xc1, 0x93,
	0x20, 0x20, 0xde, 0x20, 0xc7, 0x0f, 0xa0, 0xb6, 0x44, 0xd4, 0xa8, 0x0d, 0x4b, 0x3b, 0x64, 0x84,
	0x13, 0x8f, 0x7f, 0x89, 0x39, 0x39, 0xc3, 0x17, 0xe6, 0x28, 0xfa, 0x1a, 0x66, 0x55, 0x9d, 0xdd,
	0x0d, 0xa1, 0xb4, 0xfc, 0x2a, 0xf9, 0xf2, 0xb3, 0x60, 0x7e, 0xf7, 0xa0, 0x2b, 0x1b, 0x52, 0x6a,
	0x6e, 0x03, 0xe6, 0x29, 0x1b, 0x30, 0x1a, 0xb8, 0x1e, 0x19, 0x60, 0x3b, 0x67, 0x71, 0x96, 0xb2,
	0x03, 0xb9, 0xdd, 0xb1, 0x8d, 0x4d, 0xd5, 0xe2, 0xca, 0xf9, 0x16, 0xb7, 0x05, 0x0b, 0xbb, 0x07,
	0x5d, 0x3f, 0x0a, 0x63, 0x9e, 0xeb, 0x2b, 0xa2, 0x72, 0x09, 0x1b, 0x50, 0xb9, 0xaf, 0x47, 0xf6,
	0x1a, 0x61, 0x4a, 0x0f, 0xbd, 0x81, 0x85, 0x1e, 0xb6, 0x7b, 0xe1, 0x90, 0x7a, 0x94, 0xa7, 0x77,
	0x95, 0x3d, 0x9a, 0x0d, 0x18, 0xa7, 0xf6, 0xc9, 0x85, 0x8e, 0xa1, 0x46, 0xd9, 0x81, 0x94, 0x45,
	0x8f, 0x67, 0xe4, 0xdb, 0x84, 0x04, 0x36, 0x19, 0x04, 0x89, 0x6f, 0x26, 0x26, 0xb3, 0xb7, 0x9f,
	0xf8, 0xe8, 0x63, 0xb8, 0x2f, 0x43, 0x88, 0x7b, 0x38, 0x4b, 0x28, 0xf1, 0xdf, 0x15, 0xdb, 0x3a,
	0x04, 0xb1, 0x44, 0x2f, 0x60, 0xe1, 0x30, 0xc6, 0xa3, 0x11, 0xb5, 0x2d, 0xcc, 0x33, 0x5c, 0x2f,
	0xf7, 0xbe, 0x16, 0x54, 0x63, 0x91, 0x01, 0xc2, 0x51, 0xd9, 0x92, 0x6b, 0xf4, 0x35, 0x3c, 0xd0,
	0x47, 0x05, 0x26, 0xb9, 0x7c, 0x59, 0x81, 0x1a, 0x27, 0xb1, 0x4f, 0x03, 0xec, 0x99, 0xc8, 0x8d,
	0x2c, 0x18, 0x86, 0x61, 0x3f, 0xf2, 0x94, 0xa9, 0x9a, 0xa5, 0x25, 0xf4, 0x06, 0x90, 0x45, 0x1c,
	0x1a, 0x13, 0x9b, 0x5f, 0x43, 0x1e, 0x97, 0xc3, 0xba, 0x94, 0xd0, 0xe5, 0xb1, 0x84, 0xfe, 0x0b,
	0x3c, 0x36, 0x66, 0xaf, 0xe3, 0x80, 0x89, 0x7f, 0xed, 0x6e, 0xf6, 0x70, 0x94, 0x79, 0xb8, 0xae,
	0x94, 0xef, 0x1c, 0xf9, 0xcf, 0x53, 0x74, 0x2d, 0xe2, 0xe3, 0xf8, 0x24, 0xb5, 0xd4, 0x82, 0xaa,
	0xc3, 0x6c, 0xd3, 0x95, 0xe5, 0x1a, 0x7d, 0x0e, 0x73, 0x6f, 0x82, 0x93, 0x20, 0x3c, 0x0b, 0xf2,
	0x6a, 0xb7, 0xfc, 0x03, 0x76, 0x04, 0x1f, 0x99, 0x53, 0x57, 0x7e, 0x34, 0x78, 0x3e, 0xfe, 0xd1,
	0x60, 0x52, 0x0b, 0x28, 0x7c, 0x4a, 0xd8, 0x86, 0xf9, 0x0e, 0x7b, 0xf6, 0x3d, 0x3f, 0xdb, 0xbc,
	0x82, 0xa5, 0x0e, 0x7b, 0xf6, 0xfd, 0xbe, 0x86, 0x10, 0x58, 0xe8, 0xfb, 0x8c, 0x1e, 0x4a, 0x8a,
	0xc9, 0x0c, 0x2c, 0xc2, 0xd4, 0xc8, 0xc3, 0xae, 0x79, 0x15, 0x25, 0xa4, 0xb8, 0x95, 0x8b, 0xb8,
	0xa9, 0x62, 0xaf, 0xe4, 0x8a, 0x5d, 0x7f, 0x11, 0xa9, 0x4a, 0x28, 0xcb, 0xd4, 0x41, 0xbf, 0x87,
	0x35, 0xe5, 0x42, 0xf2, 0xdd, 0x41, 0x32, 0x3c, 0xdc, 0x3b, 0x2a, 0x7c, 0x45, 0xc8, 0x4f, 0x06,
	0x4d, 0x35, 0x19, 0x2c, 0xc1, 0xb4, 0x1d, 0x86, 0x27, 0xd4, 0x3c, 0x89, 0x96, 0xd0, 0xaf, 0x61,
	0x79, 0xcc, 0x56, 0x5f, 0x20, 0x6d, 0x87, 0x9e, 0xa8, 0xaf, 0x48, 0xaf, 0xb5, 0xad, 0x54, 0x46,
	0x9b, 0xb0, 0x34, 0x76, 0x50, 0xd2, 0xf4, 0x04, 0x7a, 0xde, 0x81, 0xf6, 0x98, 0xbe, 0x4e, 0xa5,
	0x3b, 0xa4, 0xd0, 0x3e, 0xcc, 0xe6, 0xac, 0x1c, 0xee, 0x1d, 0x5d, 0x79, 0x76, 0x03, 0xaa, 0xdc,
	0x3b, 0xbd, 0x7e, 0xa2, 0x92, 0x1a, 0x68, 0x07, 0x16, 0x73, 0xf6, 0xb2, 0x27, 0xfb, 0x85, 0xb6,
	0xa0, 0x52, 0xa7, 0x9d, 0xa5, 0x4e, 0xd1, 0xbb, 0xb6, 0xa2, 0x3b, 0xff, 0xf3, 0x0f, 0xb0, 0xf3,
	0x17, 0x79, 0xe9, 0xf9, 0x7b, 0xe0, 0xa5, 0x3f, 0xc2, 0x7a, 0xb7, 0xff, 0xfc, 0xbd, 0x14, 0xf6,
	0x13, 0x98, 0xef, 0x50, 0x57, 0x00, 0xdd, 0xfd, 0xb2, 0xdf, 0x23, 0x3c, 0xa6, 0xb6, 0x48, 0x64,
	0x5f, 0xae, 0x64, 0xa0, 0x55, 0x4b, 0x4b, 0xe8, 0x25, 0xcc, 0x6a, 0xdd, 0xbb, 0x67, 0xd5, 0x0b,
	0x68, 0x8a, 0xb3, 0x59, 0xc0, 0x1b, 0x85, 0xe7, 0xbf, 0x2e, 0x81, 0x12, 0x98, 0xdd, 0x13, 0xbd,
	0xd7, 0xdc, 0x5b, 0xb6, 0x4c, 0xd7, 0x0b, 0x87, 0x29, 0x62, 0xca, 0x7d, 0x43, 0xed, 0x49, 0xc8,
	0x32, 0x4c, 0x1d, 0xcc, 0xf1, 0xaf, 0x0a, 0x98, 0xee, 0x88, 0x9d, 0xa2, 0xc2, 0x96, 0x66, 0x83,
	0x4c, 0x61, 0x0b, 0xfd, 0x41, 0xfc, 0xc3, 0xcd, 0xb9, 0x2d, 0xc0, 0xfd, 0xf2, 0x2a, 0xb8, 0x73,
	0x39, 0x5c, 0x0c, 0xb8, 0x08, 0xb9, 0x05, 0xf3, 0x1a, 0xbf, 0x77, 0xe4, 0xaf, 0xf1, 0x01, 0xe8,
	0xd5, 0xcc, 0xbf, 0xdf, 0xae, 0x95, 0xfe, 0xf3, 0x76, 0xad, 0xf4, 0xdf, 0xb7, 0x6b, 0xa5, 0xe1,
	0xb4, 0x44, 0xf1, 0xd3, 0xff, 0x07, 0x00, 0x00, 0xff, 0xff, 0xbe, 0x8b, 0xc4, 0x8b, 0x08, 0x18,
	0x00, 0x00,
}
