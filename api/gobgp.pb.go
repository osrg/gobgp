// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: gobgp.proto

/*
	Package gobgpapi is a generated protocol buffer package.

	It is generated from these files:
		gobgp.proto
		attribute.proto

	It has these top-level messages:
		GetNeighborRequest
		GetNeighborResponse
		Arguments
		AddPathRequest
		AddPathResponse
		DeletePathRequest
		DeletePathResponse
		AddNeighborRequest
		AddNeighborResponse
		DeleteNeighborRequest
		DeleteNeighborResponse
		UpdateNeighborRequest
		UpdateNeighborResponse
		AddPeerGroupRequest
		AddPeerGroupResponse
		DeletePeerGroupRequest
		DeletePeerGroupResponse
		UpdatePeerGroupRequest
		UpdatePeerGroupResponse
		AddDynamicNeighborRequest
		AddDynamicNeighborResponse
		ResetNeighborRequest
		ResetNeighborResponse
		SoftResetNeighborRequest
		SoftResetNeighborResponse
		ShutdownNeighborRequest
		ShutdownNeighborResponse
		EnableNeighborRequest
		EnableNeighborResponse
		DisableNeighborRequest
		DisableNeighborResponse
		UpdatePolicyRequest
		UpdatePolicyResponse
		EnableMrtRequest
		EnableMrtResponse
		DisableMrtRequest
		DisableMrtResponse
		InjectMrtRequest
		InjectMrtResponse
		AddBmpRequest
		AddBmpResponse
		DeleteBmpRequest
		DeleteBmpResponse
		MonitorRibRequest
		RPKIConf
		RPKIState
		Rpki
		GetRpkiRequest
		GetRpkiResponse
		AddRpkiRequest
		AddRpkiResponse
		DeleteRpkiRequest
		DeleteRpkiResponse
		EnableRpkiRequest
		EnableRpkiResponse
		DisableRpkiRequest
		DisableRpkiResponse
		ResetRpkiRequest
		ResetRpkiResponse
		SoftResetRpkiRequest
		SoftResetRpkiResponse
		EnableZebraRequest
		EnableZebraResponse
		GetVrfRequest
		GetVrfResponse
		AddVrfRequest
		AddVrfResponse
		DeleteVrfRequest
		DeleteVrfResponse
		GetDefinedSetRequest
		GetDefinedSetResponse
		AddDefinedSetRequest
		AddDefinedSetResponse
		DeleteDefinedSetRequest
		DeleteDefinedSetResponse
		ReplaceDefinedSetRequest
		ReplaceDefinedSetResponse
		GetStatementRequest
		GetStatementResponse
		AddStatementRequest
		AddStatementResponse
		DeleteStatementRequest
		DeleteStatementResponse
		ReplaceStatementRequest
		ReplaceStatementResponse
		GetPolicyRequest
		GetPolicyResponse
		AddPolicyRequest
		AddPolicyResponse
		DeletePolicyRequest
		DeletePolicyResponse
		ReplacePolicyRequest
		ReplacePolicyResponse
		GetPolicyAssignmentRequest
		GetPolicyAssignmentResponse
		AddPolicyAssignmentRequest
		AddPolicyAssignmentResponse
		DeletePolicyAssignmentRequest
		DeletePolicyAssignmentResponse
		ReplacePolicyAssignmentRequest
		ReplacePolicyAssignmentResponse
		GetServerRequest
		GetServerResponse
		StartServerRequest
		StartServerResponse
		StopServerRequest
		StopServerResponse
		RPKIValidation
		Path
		Destination
		Table
		GetRibRequest
		GetRibResponse
		TableLookupPrefix
		GetPathRequest
		ValidateRibRequest
		ValidateRibResponse
		Peer
		PeerGroup
		DynamicNeighbor
		ApplyPolicy
		PrefixLimit
		PeerConf
		PeerGroupConf
		PeerGroupState
		EbgpMultihop
		RouteReflector
		PeerState
		Messages
		Message
		Queues
		Timers
		TimersConfig
		TimersState
		Transport
		RouteServer
		GracefulRestart
		MpGracefulRestartConfig
		MpGracefulRestartState
		MpGracefulRestart
		AfiSafiConfig
		AfiSafiState
		RouteSelectionOptionsConfig
		RouteSelectionOptionsState
		RouteSelectionOptions
		UseMultiplePathsConfig
		UseMultiplePathsState
		EbgpConfig
		EbgpState
		Ebgp
		IbgpConfig
		IbgpState
		Ibgp
		UseMultiplePaths
		RouteTargetMembershipConfig
		RouteTargetMembershipState
		RouteTargetMembership
		LongLivedGracefulRestartConfig
		LongLivedGracefulRestartState
		LongLivedGracefulRestart
		AfiSafi
		AddPathsConfig
		AddPathsState
		AddPaths
		Prefix
		DefinedSet
		MatchSet
		AsPathLength
		Conditions
		CommunityAction
		MedAction
		AsPrependAction
		NexthopAction
		LocalPrefAction
		Actions
		Statement
		Policy
		PolicyAssignment
		RoutingPolicy
		Roa
		GetRoaRequest
		GetRoaResponse
		Vrf
		DefaultRouteDistance
		Global
		Confederation
		TableInfo
		GetRibInfoRequest
		GetRibInfoResponse
		AddCollectorRequest
		AddCollectorResponse
		ShutdownRequest
		ShutdownResponse
		OriginAttribute
		AsSegment
		AsPathAttribute
		NextHopAttribute
		MultiExitDiscAttribute
		LocalPrefAttribute
		AtomicAggregateAttribute
		AggregatorAttribute
		CommunitiesAttribute
		OriginatorIdAttribute
		ClusterListAttribute
		IPAddressPrefix
		LabeledIPAddressPrefix
		EncapsulationNLRI
		RouteDistinguisherTwoOctetAS
		RouteDistinguisherIPAddress
		RouteDistinguisherFourOctetAS
		EthernetSegmentIdentifier
		EVPNEthernetAutoDiscoveryRoute
		EVPNMACIPAdvertisementRoute
		EVPNInclusiveMulticastEthernetTagRoute
		EVPNEthernetSegmentRoute
		EVPNIPPrefixRoute
		LabeledVPNIPAddressPrefix
		RouteTargetMembershipNLRI
		FlowSpecIPPrefix
		FlowSpecMAC
		FlowSpecComponentItem
		FlowSpecComponent
		FlowSpecNLRI
		VPNFlowSpecNLRI
		OpaqueNLRI
		MpReachNLRIAttribute
		MpUnreachNLRIAttribute
		TwoOctetAsSpecificExtended
		IPv4AddressSpecificExtended
		FourOctetAsSpecificExtended
		ValidationExtended
		ColorExtended
		EncapExtended
		DefaultGatewayExtended
		OpaqueExtended
		ESILabelExtended
		ESImportRouteTarget
		MacMobilityExtended
		RouterMacExtended
		TrafficRateExtended
		TrafficActionExtended
		RedirectTwoOctetAsSpecificExtended
		RedirectIPv4AddressSpecificExtended
		RedirectFourOctetAsSpecificExtended
		TrafficRemarkExtended
		UnknownExtended
		ExtendedCommunitiesAttribute
		As4PathAttribute
		As4AggregatorAttribute
		PmsiTunnelAttribute
		TunnelEncapSubTLVEncapsulation
		TunnelEncapSubTLVProtocol
		TunnelEncapSubTLVColor
		TunnelEncapSubTLVUnknown
		TunnelEncapTLV
		TunnelEncapAttribute
		IPv6AddressSpecificExtended
		RedirectIPv6AddressSpecificExtended
		IP6ExtendedCommunitiesAttribute
		AigpTLVIGPMetric
		AigpTLVUnknown
		AigpAttribute
		LargeCommunity
		LargeCommunitiesAttribute
		UnknownAttribute
*/
package gobgpapi

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/gogo/protobuf/types"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// Constants for address families
type Family int32

const (
	Family_RESERVED           Family = 0
	Family_IPv4               Family = 65537
	Family_IPv6               Family = 131073
	Family_IPv4_MC            Family = 65538
	Family_IPv6_MC            Family = 131074
	Family_IPv4_MPLS          Family = 65540
	Family_IPv6_MPLS          Family = 131076
	Family_IPv4_VPN           Family = 65664
	Family_IPv6_VPN           Family = 131200
	Family_IPv4_VPN_MC        Family = 65665
	Family_IPv6_VPN_MC        Family = 131201
	Family_VPLS               Family = 1638465
	Family_EVPN               Family = 1638470
	Family_RTC                Family = 65668
	Family_IPv4_ENCAP         Family = 65543
	Family_IPv6_ENCAP         Family = 131079
	Family_FLOW_SPEC_IPv4     Family = 65669
	Family_FLOW_SPEC_IPv6     Family = 131205
	Family_FLOW_SPEC_IPv4_VPN Family = 65670
	Family_FLOW_SPEC_IPv6_VPN Family = 131206
	Family_FLOW_SPEC_L2_VPN   Family = 1638534
	Family_OPAQUE             Family = 1074594033
)

var Family_name = map[int32]string{
	0:          "RESERVED",
	65537:      "IPv4",
	131073:     "IPv6",
	65538:      "IPv4_MC",
	131074:     "IPv6_MC",
	65540:      "IPv4_MPLS",
	131076:     "IPv6_MPLS",
	65664:      "IPv4_VPN",
	131200:     "IPv6_VPN",
	65665:      "IPv4_VPN_MC",
	131201:     "IPv6_VPN_MC",
	1638465:    "VPLS",
	1638470:    "EVPN",
	65668:      "RTC",
	65543:      "IPv4_ENCAP",
	131079:     "IPv6_ENCAP",
	65669:      "FLOW_SPEC_IPv4",
	131205:     "FLOW_SPEC_IPv6",
	65670:      "FLOW_SPEC_IPv4_VPN",
	131206:     "FLOW_SPEC_IPv6_VPN",
	1638534:    "FLOW_SPEC_L2_VPN",
	1074594033: "OPAQUE",
}
var Family_value = map[string]int32{
	"RESERVED":           0,
	"IPv4":               65537,
	"IPv6":               131073,
	"IPv4_MC":            65538,
	"IPv6_MC":            131074,
	"IPv4_MPLS":          65540,
	"IPv6_MPLS":          131076,
	"IPv4_VPN":           65664,
	"IPv6_VPN":           131200,
	"IPv4_VPN_MC":        65665,
	"IPv6_VPN_MC":        131201,
	"VPLS":               1638465,
	"EVPN":               1638470,
	"RTC":                65668,
	"IPv4_ENCAP":         65543,
	"IPv6_ENCAP":         131079,
	"FLOW_SPEC_IPv4":     65669,
	"FLOW_SPEC_IPv6":     131205,
	"FLOW_SPEC_IPv4_VPN": 65670,
	"FLOW_SPEC_IPv6_VPN": 131206,
	"FLOW_SPEC_L2_VPN":   1638534,
	"OPAQUE":             1074594033,
}

func (x Family) String() string {
	return proto.EnumName(Family_name, int32(x))
}
func (Family) EnumDescriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{0} }

type Resource int32

const (
	Resource_GLOBAL  Resource = 0
	Resource_LOCAL   Resource = 1
	Resource_ADJ_IN  Resource = 2
	Resource_ADJ_OUT Resource = 3
	Resource_VRF     Resource = 4
)

var Resource_name = map[int32]string{
	0: "GLOBAL",
	1: "LOCAL",
	2: "ADJ_IN",
	3: "ADJ_OUT",
	4: "VRF",
}
var Resource_value = map[string]int32{
	"GLOBAL":  0,
	"LOCAL":   1,
	"ADJ_IN":  2,
	"ADJ_OUT": 3,
	"VRF":     4,
}

func (x Resource) String() string {
	return proto.EnumName(Resource_name, int32(x))
}
func (Resource) EnumDescriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{1} }

// API representation of table.LookupOption
type TableLookupOption int32

const (
	TableLookupOption_LOOKUP_EXACT   TableLookupOption = 0
	TableLookupOption_LOOKUP_LONGER  TableLookupOption = 1
	TableLookupOption_LOOKUP_SHORTER TableLookupOption = 2
)

var TableLookupOption_name = map[int32]string{
	0: "LOOKUP_EXACT",
	1: "LOOKUP_LONGER",
	2: "LOOKUP_SHORTER",
}
var TableLookupOption_value = map[string]int32{
	"LOOKUP_EXACT":   0,
	"LOOKUP_LONGER":  1,
	"LOOKUP_SHORTER": 2,
}

func (x TableLookupOption) String() string {
	return proto.EnumName(TableLookupOption_name, int32(x))
}
func (TableLookupOption) EnumDescriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{2} }

type DefinedType int32

const (
	DefinedType_PREFIX          DefinedType = 0
	DefinedType_NEIGHBOR        DefinedType = 1
	DefinedType_TAG             DefinedType = 2
	DefinedType_AS_PATH         DefinedType = 3
	DefinedType_COMMUNITY       DefinedType = 4
	DefinedType_EXT_COMMUNITY   DefinedType = 5
	DefinedType_LARGE_COMMUNITY DefinedType = 6
	DefinedType_NEXT_HOP        DefinedType = 7
)

var DefinedType_name = map[int32]string{
	0: "PREFIX",
	1: "NEIGHBOR",
	2: "TAG",
	3: "AS_PATH",
	4: "COMMUNITY",
	5: "EXT_COMMUNITY",
	6: "LARGE_COMMUNITY",
	7: "NEXT_HOP",
}
var DefinedType_value = map[string]int32{
	"PREFIX":          0,
	"NEIGHBOR":        1,
	"TAG":             2,
	"AS_PATH":         3,
	"COMMUNITY":       4,
	"EXT_COMMUNITY":   5,
	"LARGE_COMMUNITY": 6,
	"NEXT_HOP":        7,
}

func (x DefinedType) String() string {
	return proto.EnumName(DefinedType_name, int32(x))
}
func (DefinedType) EnumDescriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{3} }

type MatchType int32

const (
	MatchType_ANY    MatchType = 0
	MatchType_ALL    MatchType = 1
	MatchType_INVERT MatchType = 2
)

var MatchType_name = map[int32]string{
	0: "ANY",
	1: "ALL",
	2: "INVERT",
}
var MatchType_value = map[string]int32{
	"ANY":    0,
	"ALL":    1,
	"INVERT": 2,
}

func (x MatchType) String() string {
	return proto.EnumName(MatchType_name, int32(x))
}
func (MatchType) EnumDescriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{4} }

type AsPathLengthType int32

const (
	AsPathLengthType_EQ AsPathLengthType = 0
	AsPathLengthType_GE AsPathLengthType = 1
	AsPathLengthType_LE AsPathLengthType = 2
)

var AsPathLengthType_name = map[int32]string{
	0: "EQ",
	1: "GE",
	2: "LE",
}
var AsPathLengthType_value = map[string]int32{
	"EQ": 0,
	"GE": 1,
	"LE": 2,
}

func (x AsPathLengthType) String() string {
	return proto.EnumName(AsPathLengthType_name, int32(x))
}
func (AsPathLengthType) EnumDescriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{5} }

type RouteAction int32

const (
	RouteAction_NONE   RouteAction = 0
	RouteAction_ACCEPT RouteAction = 1
	RouteAction_REJECT RouteAction = 2
)

var RouteAction_name = map[int32]string{
	0: "NONE",
	1: "ACCEPT",
	2: "REJECT",
}
var RouteAction_value = map[string]int32{
	"NONE":   0,
	"ACCEPT": 1,
	"REJECT": 2,
}

func (x RouteAction) String() string {
	return proto.EnumName(RouteAction_name, int32(x))
}
func (RouteAction) EnumDescriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{6} }

type CommunityActionType int32

const (
	CommunityActionType_COMMUNITY_ADD     CommunityActionType = 0
	CommunityActionType_COMMUNITY_REMOVE  CommunityActionType = 1
	CommunityActionType_COMMUNITY_REPLACE CommunityActionType = 2
)

var CommunityActionType_name = map[int32]string{
	0: "COMMUNITY_ADD",
	1: "COMMUNITY_REMOVE",
	2: "COMMUNITY_REPLACE",
}
var CommunityActionType_value = map[string]int32{
	"COMMUNITY_ADD":     0,
	"COMMUNITY_REMOVE":  1,
	"COMMUNITY_REPLACE": 2,
}

func (x CommunityActionType) String() string {
	return proto.EnumName(CommunityActionType_name, int32(x))
}
func (CommunityActionType) EnumDescriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{7} }

type MedActionType int32

const (
	MedActionType_MED_MOD     MedActionType = 0
	MedActionType_MED_REPLACE MedActionType = 1
)

var MedActionType_name = map[int32]string{
	0: "MED_MOD",
	1: "MED_REPLACE",
}
var MedActionType_value = map[string]int32{
	"MED_MOD":     0,
	"MED_REPLACE": 1,
}

func (x MedActionType) String() string {
	return proto.EnumName(MedActionType_name, int32(x))
}
func (MedActionType) EnumDescriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{8} }

type PolicyType int32

const (
	PolicyType_IN     PolicyType = 0
	PolicyType_IMPORT PolicyType = 1
	PolicyType_EXPORT PolicyType = 2
)

var PolicyType_name = map[int32]string{
	0: "IN",
	1: "IMPORT",
	2: "EXPORT",
}
var PolicyType_value = map[string]int32{
	"IN":     0,
	"IMPORT": 1,
	"EXPORT": 2,
}

func (x PolicyType) String() string {
	return proto.EnumName(PolicyType_name, int32(x))
}
func (PolicyType) EnumDescriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{9} }

type SoftResetNeighborRequest_SoftResetDirection int32

const (
	SoftResetNeighborRequest_IN   SoftResetNeighborRequest_SoftResetDirection = 0
	SoftResetNeighborRequest_OUT  SoftResetNeighborRequest_SoftResetDirection = 1
	SoftResetNeighborRequest_BOTH SoftResetNeighborRequest_SoftResetDirection = 2
)

var SoftResetNeighborRequest_SoftResetDirection_name = map[int32]string{
	0: "IN",
	1: "OUT",
	2: "BOTH",
}
var SoftResetNeighborRequest_SoftResetDirection_value = map[string]int32{
	"IN":   0,
	"OUT":  1,
	"BOTH": 2,
}

func (x SoftResetNeighborRequest_SoftResetDirection) String() string {
	return proto.EnumName(SoftResetNeighborRequest_SoftResetDirection_name, int32(x))
}
func (SoftResetNeighborRequest_SoftResetDirection) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorGobgp, []int{23, 0}
}

type AddBmpRequest_MonitoringPolicy int32

const (
	AddBmpRequest_PRE   AddBmpRequest_MonitoringPolicy = 0
	AddBmpRequest_POST  AddBmpRequest_MonitoringPolicy = 1
	AddBmpRequest_BOTH  AddBmpRequest_MonitoringPolicy = 2
	AddBmpRequest_LOCAL AddBmpRequest_MonitoringPolicy = 3
	AddBmpRequest_ALL   AddBmpRequest_MonitoringPolicy = 4
)

var AddBmpRequest_MonitoringPolicy_name = map[int32]string{
	0: "PRE",
	1: "POST",
	2: "BOTH",
	3: "LOCAL",
	4: "ALL",
}
var AddBmpRequest_MonitoringPolicy_value = map[string]int32{
	"PRE":   0,
	"POST":  1,
	"BOTH":  2,
	"LOCAL": 3,
	"ALL":   4,
}

func (x AddBmpRequest_MonitoringPolicy) String() string {
	return proto.EnumName(AddBmpRequest_MonitoringPolicy_name, int32(x))
}
func (AddBmpRequest_MonitoringPolicy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorGobgp, []int{39, 0}
}

type RPKIValidation_State int32

const (
	RPKIValidation_STATE_NONE      RPKIValidation_State = 0
	RPKIValidation_STATE_NOT_FOUND RPKIValidation_State = 1
	RPKIValidation_STATE_VALID     RPKIValidation_State = 2
	RPKIValidation_STATE_INVALID   RPKIValidation_State = 3
)

var RPKIValidation_State_name = map[int32]string{
	0: "STATE_NONE",
	1: "STATE_NOT_FOUND",
	2: "STATE_VALID",
	3: "STATE_INVALID",
}
var RPKIValidation_State_value = map[string]int32{
	"STATE_NONE":      0,
	"STATE_NOT_FOUND": 1,
	"STATE_VALID":     2,
	"STATE_INVALID":   3,
}

func (x RPKIValidation_State) String() string {
	return proto.EnumName(RPKIValidation_State_name, int32(x))
}
func (RPKIValidation_State) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorGobgp, []int{107, 0}
}

type RPKIValidation_Reason int32

const (
	RPKIValidation_REASOT_NONE   RPKIValidation_Reason = 0
	RPKIValidation_REASON_AS     RPKIValidation_Reason = 1
	RPKIValidation_REASON_LENGTH RPKIValidation_Reason = 2
)

var RPKIValidation_Reason_name = map[int32]string{
	0: "REASOT_NONE",
	1: "REASON_AS",
	2: "REASON_LENGTH",
}
var RPKIValidation_Reason_value = map[string]int32{
	"REASOT_NONE":   0,
	"REASON_AS":     1,
	"REASON_LENGTH": 2,
}

func (x RPKIValidation_Reason) String() string {
	return proto.EnumName(RPKIValidation_Reason_name, int32(x))
}
func (RPKIValidation_Reason) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorGobgp, []int{107, 1}
}

type PeerConf_RemovePrivateAs int32

const (
	PeerConf_NONE    PeerConf_RemovePrivateAs = 0
	PeerConf_ALL     PeerConf_RemovePrivateAs = 1
	PeerConf_REPLACE PeerConf_RemovePrivateAs = 2
)

var PeerConf_RemovePrivateAs_name = map[int32]string{
	0: "NONE",
	1: "ALL",
	2: "REPLACE",
}
var PeerConf_RemovePrivateAs_value = map[string]int32{
	"NONE":    0,
	"ALL":     1,
	"REPLACE": 2,
}

func (x PeerConf_RemovePrivateAs) String() string {
	return proto.EnumName(PeerConf_RemovePrivateAs_name, int32(x))
}
func (PeerConf_RemovePrivateAs) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorGobgp, []int{122, 0}
}

type PeerGroupConf_RemovePrivateAs int32

const (
	PeerGroupConf_NONE    PeerGroupConf_RemovePrivateAs = 0
	PeerGroupConf_ALL     PeerGroupConf_RemovePrivateAs = 1
	PeerGroupConf_REPLACE PeerGroupConf_RemovePrivateAs = 2
)

var PeerGroupConf_RemovePrivateAs_name = map[int32]string{
	0: "NONE",
	1: "ALL",
	2: "REPLACE",
}
var PeerGroupConf_RemovePrivateAs_value = map[string]int32{
	"NONE":    0,
	"ALL":     1,
	"REPLACE": 2,
}

func (x PeerGroupConf_RemovePrivateAs) String() string {
	return proto.EnumName(PeerGroupConf_RemovePrivateAs_name, int32(x))
}
func (PeerGroupConf_RemovePrivateAs) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorGobgp, []int{123, 0}
}

type PeerGroupState_RemovePrivateAs int32

const (
	PeerGroupState_NONE    PeerGroupState_RemovePrivateAs = 0
	PeerGroupState_ALL     PeerGroupState_RemovePrivateAs = 1
	PeerGroupState_REPLACE PeerGroupState_RemovePrivateAs = 2
)

var PeerGroupState_RemovePrivateAs_name = map[int32]string{
	0: "NONE",
	1: "ALL",
	2: "REPLACE",
}
var PeerGroupState_RemovePrivateAs_value = map[string]int32{
	"NONE":    0,
	"ALL":     1,
	"REPLACE": 2,
}

func (x PeerGroupState_RemovePrivateAs) String() string {
	return proto.EnumName(PeerGroupState_RemovePrivateAs_name, int32(x))
}
func (PeerGroupState_RemovePrivateAs) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorGobgp, []int{124, 0}
}

type PeerState_AdminState int32

const (
	PeerState_UP     PeerState_AdminState = 0
	PeerState_DOWN   PeerState_AdminState = 1
	PeerState_PFX_CT PeerState_AdminState = 2
)

var PeerState_AdminState_name = map[int32]string{
	0: "UP",
	1: "DOWN",
	2: "PFX_CT",
}
var PeerState_AdminState_value = map[string]int32{
	"UP":     0,
	"DOWN":   1,
	"PFX_CT": 2,
}

func (x PeerState_AdminState) String() string {
	return proto.EnumName(PeerState_AdminState_name, int32(x))
}
func (PeerState_AdminState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorGobgp, []int{127, 0}
}

type Conditions_RouteType int32

const (
	Conditions_ROUTE_TYPE_NONE     Conditions_RouteType = 0
	Conditions_ROUTE_TYPE_INTERNAL Conditions_RouteType = 1
	Conditions_ROUTE_TYPE_EXTERNAL Conditions_RouteType = 2
	Conditions_ROUTE_TYPE_LOCAL    Conditions_RouteType = 3
)

var Conditions_RouteType_name = map[int32]string{
	0: "ROUTE_TYPE_NONE",
	1: "ROUTE_TYPE_INTERNAL",
	2: "ROUTE_TYPE_EXTERNAL",
	3: "ROUTE_TYPE_LOCAL",
}
var Conditions_RouteType_value = map[string]int32{
	"ROUTE_TYPE_NONE":     0,
	"ROUTE_TYPE_INTERNAL": 1,
	"ROUTE_TYPE_EXTERNAL": 2,
	"ROUTE_TYPE_LOCAL":    3,
}

func (x Conditions_RouteType) String() string {
	return proto.EnumName(Conditions_RouteType_name, int32(x))
}
func (Conditions_RouteType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorGobgp, []int{168, 0}
}

type GetNeighborRequest struct {
	EnableAdvertised bool   `protobuf:"varint,1,opt,name=enableAdvertised,proto3" json:"enableAdvertised,omitempty"`
	Address          string `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *GetNeighborRequest) Reset()                    { *m = GetNeighborRequest{} }
func (m *GetNeighborRequest) String() string            { return proto.CompactTextString(m) }
func (*GetNeighborRequest) ProtoMessage()               {}
func (*GetNeighborRequest) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{0} }

func (m *GetNeighborRequest) GetEnableAdvertised() bool {
	if m != nil {
		return m.EnableAdvertised
	}
	return false
}

func (m *GetNeighborRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type GetNeighborResponse struct {
	Peers []*Peer `protobuf:"bytes,1,rep,name=peers" json:"peers,omitempty"`
}

func (m *GetNeighborResponse) Reset()                    { *m = GetNeighborResponse{} }
func (m *GetNeighborResponse) String() string            { return proto.CompactTextString(m) }
func (*GetNeighborResponse) ProtoMessage()               {}
func (*GetNeighborResponse) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{1} }

func (m *GetNeighborResponse) GetPeers() []*Peer {
	if m != nil {
		return m.Peers
	}
	return nil
}

type Arguments struct {
	Resource Resource `protobuf:"varint,1,opt,name=resource,proto3,enum=gobgpapi.Resource" json:"resource,omitempty"`
	Family   uint32   `protobuf:"varint,2,opt,name=family,proto3" json:"family,omitempty"`
	Name     string   `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Current  bool     `protobuf:"varint,4,opt,name=current,proto3" json:"current,omitempty"`
}

func (m *Arguments) Reset()                    { *m = Arguments{} }
func (m *Arguments) String() string            { return proto.CompactTextString(m) }
func (*Arguments) ProtoMessage()               {}
func (*Arguments) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{2} }

func (m *Arguments) GetResource() Resource {
	if m != nil {
		return m.Resource
	}
	return Resource_GLOBAL
}

func (m *Arguments) GetFamily() uint32 {
	if m != nil {
		return m.Family
	}
	return 0
}

func (m *Arguments) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Arguments) GetCurrent() bool {
	if m != nil {
		return m.Current
	}
	return false
}

type AddPathRequest struct {
	Resource Resource `protobuf:"varint,1,opt,name=resource,proto3,enum=gobgpapi.Resource" json:"resource,omitempty"`
	VrfId    string   `protobuf:"bytes,2,opt,name=vrf_id,json=vrfId,proto3" json:"vrf_id,omitempty"`
	Path     *Path    `protobuf:"bytes,3,opt,name=path" json:"path,omitempty"`
}

func (m *AddPathRequest) Reset()                    { *m = AddPathRequest{} }
func (m *AddPathRequest) String() string            { return proto.CompactTextString(m) }
func (*AddPathRequest) ProtoMessage()               {}
func (*AddPathRequest) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{3} }

func (m *AddPathRequest) GetResource() Resource {
	if m != nil {
		return m.Resource
	}
	return Resource_GLOBAL
}

func (m *AddPathRequest) GetVrfId() string {
	if m != nil {
		return m.VrfId
	}
	return ""
}

func (m *AddPathRequest) GetPath() *Path {
	if m != nil {
		return m.Path
	}
	return nil
}

type AddPathResponse struct {
	Uuid []byte `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
}

func (m *AddPathResponse) Reset()                    { *m = AddPathResponse{} }
func (m *AddPathResponse) String() string            { return proto.CompactTextString(m) }
func (*AddPathResponse) ProtoMessage()               {}
func (*AddPathResponse) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{4} }

func (m *AddPathResponse) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

type DeletePathRequest struct {
	Resource Resource `protobuf:"varint,1,opt,name=resource,proto3,enum=gobgpapi.Resource" json:"resource,omitempty"`
	VrfId    string   `protobuf:"bytes,2,opt,name=vrf_id,json=vrfId,proto3" json:"vrf_id,omitempty"`
	Family   uint32   `protobuf:"varint,3,opt,name=family,proto3" json:"family,omitempty"`
	Path     *Path    `protobuf:"bytes,4,opt,name=path" json:"path,omitempty"`
	Uuid     []byte   `protobuf:"bytes,5,opt,name=uuid,proto3" json:"uuid,omitempty"`
}

func (m *DeletePathRequest) Reset()                    { *m = DeletePathRequest{} }
func (m *DeletePathRequest) String() string            { return proto.CompactTextString(m) }
func (*DeletePathRequest) ProtoMessage()               {}
func (*DeletePathRequest) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{5} }

func (m *DeletePathRequest) GetResource() Resource {
	if m != nil {
		return m.Resource
	}
	return Resource_GLOBAL
}

func (m *DeletePathRequest) GetVrfId() string {
	if m != nil {
		return m.VrfId
	}
	return ""
}

func (m *DeletePathRequest) GetFamily() uint32 {
	if m != nil {
		return m.Family
	}
	return 0
}

func (m *DeletePathRequest) GetPath() *Path {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *DeletePathRequest) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

type DeletePathResponse struct {
}

func (m *DeletePathResponse) Reset()                    { *m = DeletePathResponse{} }
func (m *DeletePathResponse) String() string            { return proto.CompactTextString(m) }
func (*DeletePathResponse) ProtoMessage()               {}
func (*DeletePathResponse) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{6} }

type AddNeighborRequest struct {
	Peer *Peer `protobuf:"bytes,1,opt,name=peer" json:"peer,omitempty"`
}

func (m *AddNeighborRequest) Reset()                    { *m = AddNeighborRequest{} }
func (m *AddNeighborRequest) String() string            { return proto.CompactTextString(m) }
func (*AddNeighborRequest) ProtoMessage()               {}
func (*AddNeighborRequest) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{7} }

func (m *AddNeighborRequest) GetPeer() *Peer {
	if m != nil {
		return m.Peer
	}
	return nil
}

type AddNeighborResponse struct {
}

func (m *AddNeighborResponse) Reset()                    { *m = AddNeighborResponse{} }
func (m *AddNeighborResponse) String() string            { return proto.CompactTextString(m) }
func (*AddNeighborResponse) ProtoMessage()               {}
func (*AddNeighborResponse) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{8} }

type DeleteNeighborRequest struct {
	Peer *Peer `protobuf:"bytes,1,opt,name=peer" json:"peer,omitempty"`
}

func (m *DeleteNeighborRequest) Reset()                    { *m = DeleteNeighborRequest{} }
func (m *DeleteNeighborRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteNeighborRequest) ProtoMessage()               {}
func (*DeleteNeighborRequest) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{9} }

func (m *DeleteNeighborRequest) GetPeer() *Peer {
	if m != nil {
		return m.Peer
	}
	return nil
}

type DeleteNeighborResponse struct {
}

func (m *DeleteNeighborResponse) Reset()                    { *m = DeleteNeighborResponse{} }
func (m *DeleteNeighborResponse) String() string            { return proto.CompactTextString(m) }
func (*DeleteNeighborResponse) ProtoMessage()               {}
func (*DeleteNeighborResponse) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{10} }

type UpdateNeighborRequest struct {
	Peer *Peer `protobuf:"bytes,1,opt,name=peer" json:"peer,omitempty"`
	// Calls SoftResetIn after updating the neighbor configuration if needed.
	DoSoftResetIn bool `protobuf:"varint,2,opt,name=do_soft_reset_in,json=doSoftResetIn,proto3" json:"do_soft_reset_in,omitempty"`
}

func (m *UpdateNeighborRequest) Reset()                    { *m = UpdateNeighborRequest{} }
func (m *UpdateNeighborRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdateNeighborRequest) ProtoMessage()               {}
func (*UpdateNeighborRequest) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{11} }

func (m *UpdateNeighborRequest) GetPeer() *Peer {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *UpdateNeighborRequest) GetDoSoftResetIn() bool {
	if m != nil {
		return m.DoSoftResetIn
	}
	return false
}

type UpdateNeighborResponse struct {
	// Indicates whether calling SoftResetIn is required due to this update. If
	// "true" is set, the client should call SoftResetIn manually. If
	// "do_soft_reset_in = true" is set in the request, always returned with
	// "false".
	NeedsSoftResetIn bool `protobuf:"varint,1,opt,name=needs_soft_reset_in,json=needsSoftResetIn,proto3" json:"needs_soft_reset_in,omitempty"`
}

func (m *UpdateNeighborResponse) Reset()                    { *m = UpdateNeighborResponse{} }
func (m *UpdateNeighborResponse) String() string            { return proto.CompactTextString(m) }
func (*UpdateNeighborResponse) ProtoMessage()               {}
func (*UpdateNeighborResponse) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{12} }

func (m *UpdateNeighborResponse) GetNeedsSoftResetIn() bool {
	if m != nil {
		return m.NeedsSoftResetIn
	}
	return false
}

type AddPeerGroupRequest struct {
	PeerGroup *PeerGroup `protobuf:"bytes,1,opt,name=peer_group,json=peerGroup" json:"peer_group,omitempty"`
}

func (m *AddPeerGroupRequest) Reset()                    { *m = AddPeerGroupRequest{} }
func (m *AddPeerGroupRequest) String() string            { return proto.CompactTextString(m) }
func (*AddPeerGroupRequest) ProtoMessage()               {}
func (*AddPeerGroupRequest) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{13} }

func (m *AddPeerGroupRequest) GetPeerGroup() *PeerGroup {
	if m != nil {
		return m.PeerGroup
	}
	return nil
}

type AddPeerGroupResponse struct {
}

func (m *AddPeerGroupResponse) Reset()                    { *m = AddPeerGroupResponse{} }
func (m *AddPeerGroupResponse) String() string            { return proto.CompactTextString(m) }
func (*AddPeerGroupResponse) ProtoMessage()               {}
func (*AddPeerGroupResponse) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{14} }

type DeletePeerGroupRequest struct {
	PeerGroup *PeerGroup `protobuf:"bytes,1,opt,name=peer_group,json=peerGroup" json:"peer_group,omitempty"`
}

func (m *DeletePeerGroupRequest) Reset()                    { *m = DeletePeerGroupRequest{} }
func (m *DeletePeerGroupRequest) String() string            { return proto.CompactTextString(m) }
func (*DeletePeerGroupRequest) ProtoMessage()               {}
func (*DeletePeerGroupRequest) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{15} }

func (m *DeletePeerGroupRequest) GetPeerGroup() *PeerGroup {
	if m != nil {
		return m.PeerGroup
	}
	return nil
}

type DeletePeerGroupResponse struct {
}

func (m *DeletePeerGroupResponse) Reset()                    { *m = DeletePeerGroupResponse{} }
func (m *DeletePeerGroupResponse) String() string            { return proto.CompactTextString(m) }
func (*DeletePeerGroupResponse) ProtoMessage()               {}
func (*DeletePeerGroupResponse) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{16} }

type UpdatePeerGroupRequest struct {
	PeerGroup     *PeerGroup `protobuf:"bytes,1,opt,name=peer_group,json=peerGroup" json:"peer_group,omitempty"`
	DoSoftResetIn bool       `protobuf:"varint,2,opt,name=do_soft_reset_in,json=doSoftResetIn,proto3" json:"do_soft_reset_in,omitempty"`
}

func (m *UpdatePeerGroupRequest) Reset()                    { *m = UpdatePeerGroupRequest{} }
func (m *UpdatePeerGroupRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdatePeerGroupRequest) ProtoMessage()               {}
func (*UpdatePeerGroupRequest) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{17} }

func (m *UpdatePeerGroupRequest) GetPeerGroup() *PeerGroup {
	if m != nil {
		return m.PeerGroup
	}
	return nil
}

func (m *UpdatePeerGroupRequest) GetDoSoftResetIn() bool {
	if m != nil {
		return m.DoSoftResetIn
	}
	return false
}

type UpdatePeerGroupResponse struct {
	NeedsSoftResetIn bool `protobuf:"varint,1,opt,name=needs_soft_reset_in,json=needsSoftResetIn,proto3" json:"needs_soft_reset_in,omitempty"`
}

func (m *UpdatePeerGroupResponse) Reset()                    { *m = UpdatePeerGroupResponse{} }
func (m *UpdatePeerGroupResponse) String() string            { return proto.CompactTextString(m) }
func (*UpdatePeerGroupResponse) ProtoMessage()               {}
func (*UpdatePeerGroupResponse) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{18} }

func (m *UpdatePeerGroupResponse) GetNeedsSoftResetIn() bool {
	if m != nil {
		return m.NeedsSoftResetIn
	}
	return false
}

type AddDynamicNeighborRequest struct {
	DynamicNeighbor *DynamicNeighbor `protobuf:"bytes,1,opt,name=dynamic_neighbor,json=dynamicNeighbor" json:"dynamic_neighbor,omitempty"`
}

func (m *AddDynamicNeighborRequest) Reset()                    { *m = AddDynamicNeighborRequest{} }
func (m *AddDynamicNeighborRequest) String() string            { return proto.CompactTextString(m) }
func (*AddDynamicNeighborRequest) ProtoMessage()               {}
func (*AddDynamicNeighborRequest) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{19} }

func (m *AddDynamicNeighborRequest) GetDynamicNeighbor() *DynamicNeighbor {
	if m != nil {
		return m.DynamicNeighbor
	}
	return nil
}

type AddDynamicNeighborResponse struct {
}

func (m *AddDynamicNeighborResponse) Reset()                    { *m = AddDynamicNeighborResponse{} }
func (m *AddDynamicNeighborResponse) String() string            { return proto.CompactTextString(m) }
func (*AddDynamicNeighborResponse) ProtoMessage()               {}
func (*AddDynamicNeighborResponse) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{20} }

type ResetNeighborRequest struct {
	Address       string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Communication string `protobuf:"bytes,2,opt,name=communication,proto3" json:"communication,omitempty"`
}

func (m *ResetNeighborRequest) Reset()                    { *m = ResetNeighborRequest{} }
func (m *ResetNeighborRequest) String() string            { return proto.CompactTextString(m) }
func (*ResetNeighborRequest) ProtoMessage()               {}
func (*ResetNeighborRequest) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{21} }

func (m *ResetNeighborRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *ResetNeighborRequest) GetCommunication() string {
	if m != nil {
		return m.Communication
	}
	return ""
}

type ResetNeighborResponse struct {
}

func (m *ResetNeighborResponse) Reset()                    { *m = ResetNeighborResponse{} }
func (m *ResetNeighborResponse) String() string            { return proto.CompactTextString(m) }
func (*ResetNeighborResponse) ProtoMessage()               {}
func (*ResetNeighborResponse) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{22} }

type SoftResetNeighborRequest struct {
	Address   string                                      `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Direction SoftResetNeighborRequest_SoftResetDirection `protobuf:"varint,2,opt,name=direction,proto3,enum=gobgpapi.SoftResetNeighborRequest_SoftResetDirection" json:"direction,omitempty"`
}

func (m *SoftResetNeighborRequest) Reset()                    { *m = SoftResetNeighborRequest{} }
func (m *SoftResetNeighborRequest) String() string            { return proto.CompactTextString(m) }
func (*SoftResetNeighborRequest) ProtoMessage()               {}
func (*SoftResetNeighborRequest) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{23} }

func (m *SoftResetNeighborRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *SoftResetNeighborRequest) GetDirection() SoftResetNeighborRequest_SoftResetDirection {
	if m != nil {
		return m.Direction
	}
	return SoftResetNeighborRequest_IN
}

type SoftResetNeighborResponse struct {
}

func (m *SoftResetNeighborResponse) Reset()                    { *m = SoftResetNeighborResponse{} }
func (m *SoftResetNeighborResponse) String() string            { return proto.CompactTextString(m) }
func (*SoftResetNeighborResponse) ProtoMessage()               {}
func (*SoftResetNeighborResponse) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{24} }

type ShutdownNeighborRequest struct {
	Address       string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Communication string `protobuf:"bytes,2,opt,name=communication,proto3" json:"communication,omitempty"`
}

func (m *ShutdownNeighborRequest) Reset()                    { *m = ShutdownNeighborRequest{} }
func (m *ShutdownNeighborRequest) String() string            { return proto.CompactTextString(m) }
func (*ShutdownNeighborRequest) ProtoMessage()               {}
func (*ShutdownNeighborRequest) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{25} }

func (m *ShutdownNeighborRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *ShutdownNeighborRequest) GetCommunication() string {
	if m != nil {
		return m.Communication
	}
	return ""
}

type ShutdownNeighborResponse struct {
}

func (m *ShutdownNeighborResponse) Reset()                    { *m = ShutdownNeighborResponse{} }
func (m *ShutdownNeighborResponse) String() string            { return proto.CompactTextString(m) }
func (*ShutdownNeighborResponse) ProtoMessage()               {}
func (*ShutdownNeighborResponse) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{26} }

type EnableNeighborRequest struct {
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *EnableNeighborRequest) Reset()                    { *m = EnableNeighborRequest{} }
func (m *EnableNeighborRequest) String() string            { return proto.CompactTextString(m) }
func (*EnableNeighborRequest) ProtoMessage()               {}
func (*EnableNeighborRequest) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{27} }

func (m *EnableNeighborRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type EnableNeighborResponse struct {
}

func (m *EnableNeighborResponse) Reset()                    { *m = EnableNeighborResponse{} }
func (m *EnableNeighborResponse) String() string            { return proto.CompactTextString(m) }
func (*EnableNeighborResponse) ProtoMessage()               {}
func (*EnableNeighborResponse) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{28} }

type DisableNeighborRequest struct {
	Address       string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Communication string `protobuf:"bytes,2,opt,name=communication,proto3" json:"communication,omitempty"`
}

func (m *DisableNeighborRequest) Reset()                    { *m = DisableNeighborRequest{} }
func (m *DisableNeighborRequest) String() string            { return proto.CompactTextString(m) }
func (*DisableNeighborRequest) ProtoMessage()               {}
func (*DisableNeighborRequest) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{29} }

func (m *DisableNeighborRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *DisableNeighborRequest) GetCommunication() string {
	if m != nil {
		return m.Communication
	}
	return ""
}

type DisableNeighborResponse struct {
}

func (m *DisableNeighborResponse) Reset()                    { *m = DisableNeighborResponse{} }
func (m *DisableNeighborResponse) String() string            { return proto.CompactTextString(m) }
func (*DisableNeighborResponse) ProtoMessage()               {}
func (*DisableNeighborResponse) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{30} }

type UpdatePolicyRequest struct {
	Sets     []*DefinedSet `protobuf:"bytes,1,rep,name=sets" json:"sets,omitempty"`
	Policies []*Policy     `protobuf:"bytes,2,rep,name=policies" json:"policies,omitempty"`
}

func (m *UpdatePolicyRequest) Reset()                    { *m = UpdatePolicyRequest{} }
func (m *UpdatePolicyRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdatePolicyRequest) ProtoMessage()               {}
func (*UpdatePolicyRequest) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{31} }

func (m *UpdatePolicyRequest) GetSets() []*DefinedSet {
	if m != nil {
		return m.Sets
	}
	return nil
}

func (m *UpdatePolicyRequest) GetPolicies() []*Policy {
	if m != nil {
		return m.Policies
	}
	return nil
}

type UpdatePolicyResponse struct {
}

func (m *UpdatePolicyResponse) Reset()                    { *m = UpdatePolicyResponse{} }
func (m *UpdatePolicyResponse) String() string            { return proto.CompactTextString(m) }
func (*UpdatePolicyResponse) ProtoMessage()               {}
func (*UpdatePolicyResponse) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{32} }

type EnableMrtRequest struct {
	DumpType int32  `protobuf:"varint,1,opt,name=dump_type,json=dumpType,proto3" json:"dump_type,omitempty"`
	Filename string `protobuf:"bytes,2,opt,name=filename,proto3" json:"filename,omitempty"`
	Interval uint64 `protobuf:"varint,3,opt,name=interval,proto3" json:"interval,omitempty"`
}

func (m *EnableMrtRequest) Reset()                    { *m = EnableMrtRequest{} }
func (m *EnableMrtRequest) String() string            { return proto.CompactTextString(m) }
func (*EnableMrtRequest) ProtoMessage()               {}
func (*EnableMrtRequest) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{33} }

func (m *EnableMrtRequest) GetDumpType() int32 {
	if m != nil {
		return m.DumpType
	}
	return 0
}

func (m *EnableMrtRequest) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

func (m *EnableMrtRequest) GetInterval() uint64 {
	if m != nil {
		return m.Interval
	}
	return 0
}

type EnableMrtResponse struct {
}

func (m *EnableMrtResponse) Reset()                    { *m = EnableMrtResponse{} }
func (m *EnableMrtResponse) String() string            { return proto.CompactTextString(m) }
func (*EnableMrtResponse) ProtoMessage()               {}
func (*EnableMrtResponse) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{34} }

type DisableMrtRequest struct {
}

func (m *DisableMrtRequest) Reset()                    { *m = DisableMrtRequest{} }
func (m *DisableMrtRequest) String() string            { return proto.CompactTextString(m) }
func (*DisableMrtRequest) ProtoMessage()               {}
func (*DisableMrtRequest) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{35} }

type DisableMrtResponse struct {
}

func (m *DisableMrtResponse) Reset()                    { *m = DisableMrtResponse{} }
func (m *DisableMrtResponse) String() string            { return proto.CompactTextString(m) }
func (*DisableMrtResponse) ProtoMessage()               {}
func (*DisableMrtResponse) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{36} }

type InjectMrtRequest struct {
	Resource Resource `protobuf:"varint,1,opt,name=resource,proto3,enum=gobgpapi.Resource" json:"resource,omitempty"`
	VrfId    string   `protobuf:"bytes,2,opt,name=vrf_id,json=vrfId,proto3" json:"vrf_id,omitempty"`
	Paths    []*Path  `protobuf:"bytes,3,rep,name=paths" json:"paths,omitempty"`
}

func (m *InjectMrtRequest) Reset()                    { *m = InjectMrtRequest{} }
func (m *InjectMrtRequest) String() string            { return proto.CompactTextString(m) }
func (*InjectMrtRequest) ProtoMessage()               {}
func (*InjectMrtRequest) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{37} }

func (m *InjectMrtRequest) GetResource() Resource {
	if m != nil {
		return m.Resource
	}
	return Resource_GLOBAL
}

func (m *InjectMrtRequest) GetVrfId() string {
	if m != nil {
		return m.VrfId
	}
	return ""
}

func (m *InjectMrtRequest) GetPaths() []*Path {
	if m != nil {
		return m.Paths
	}
	return nil
}

type InjectMrtResponse struct {
}

func (m *InjectMrtResponse) Reset()                    { *m = InjectMrtResponse{} }
func (m *InjectMrtResponse) String() string            { return proto.CompactTextString(m) }
func (*InjectMrtResponse) ProtoMessage()               {}
func (*InjectMrtResponse) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{38} }

type AddBmpRequest struct {
	Address string                         `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Port    uint32                         `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
	Type    AddBmpRequest_MonitoringPolicy `protobuf:"varint,3,opt,name=type,proto3,enum=gobgpapi.AddBmpRequest_MonitoringPolicy" json:"type,omitempty"`
}

func (m *AddBmpRequest) Reset()                    { *m = AddBmpRequest{} }
func (m *AddBmpRequest) String() string            { return proto.CompactTextString(m) }
func (*AddBmpRequest) ProtoMessage()               {}
func (*AddBmpRequest) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{39} }

func (m *AddBmpRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *AddBmpRequest) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *AddBmpRequest) GetType() AddBmpRequest_MonitoringPolicy {
	if m != nil {
		return m.Type
	}
	return AddBmpRequest_PRE
}

type AddBmpResponse struct {
}

func (m *AddBmpResponse) Reset()                    { *m = AddBmpResponse{} }
func (m *AddBmpResponse) String() string            { return proto.CompactTextString(m) }
func (*AddBmpResponse) ProtoMessage()               {}
func (*AddBmpResponse) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{40} }

type DeleteBmpRequest struct {
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Port    uint32 `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
}

func (m *DeleteBmpRequest) Reset()                    { *m = DeleteBmpRequest{} }
func (m *DeleteBmpRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteBmpRequest) ProtoMessage()               {}
func (*DeleteBmpRequest) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{41} }

func (m *DeleteBmpRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *DeleteBmpRequest) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

type DeleteBmpResponse struct {
}

func (m *DeleteBmpResponse) Reset()                    { *m = DeleteBmpResponse{} }
func (m *DeleteBmpResponse) String() string            { return proto.CompactTextString(m) }
func (*DeleteBmpResponse) ProtoMessage()               {}
func (*DeleteBmpResponse) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{42} }

type MonitorRibRequest struct {
	Table   *Table `protobuf:"bytes,1,opt,name=table" json:"table,omitempty"`
	Current bool   `protobuf:"varint,2,opt,name=current,proto3" json:"current,omitempty"`
}

func (m *MonitorRibRequest) Reset()                    { *m = MonitorRibRequest{} }
func (m *MonitorRibRequest) String() string            { return proto.CompactTextString(m) }
func (*MonitorRibRequest) ProtoMessage()               {}
func (*MonitorRibRequest) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{43} }

func (m *MonitorRibRequest) GetTable() *Table {
	if m != nil {
		return m.Table
	}
	return nil
}

func (m *MonitorRibRequest) GetCurrent() bool {
	if m != nil {
		return m.Current
	}
	return false
}

type RPKIConf struct {
	Address    string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	RemotePort string `protobuf:"bytes,2,opt,name=remote_port,json=remotePort,proto3" json:"remote_port,omitempty"`
}

func (m *RPKIConf) Reset()                    { *m = RPKIConf{} }
func (m *RPKIConf) String() string            { return proto.CompactTextString(m) }
func (*RPKIConf) ProtoMessage()               {}
func (*RPKIConf) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{44} }

func (m *RPKIConf) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *RPKIConf) GetRemotePort() string {
	if m != nil {
		return m.RemotePort
	}
	return ""
}

type RPKIState struct {
	Uptime        int64  `protobuf:"varint,1,opt,name=uptime,proto3" json:"uptime,omitempty"`
	Downtime      int64  `protobuf:"varint,2,opt,name=downtime,proto3" json:"downtime,omitempty"`
	Up            bool   `protobuf:"varint,3,opt,name=up,proto3" json:"up,omitempty"`
	RecordIpv4    uint32 `protobuf:"varint,4,opt,name=record_ipv4,json=recordIpv4,proto3" json:"record_ipv4,omitempty"`
	RecordIpv6    uint32 `protobuf:"varint,5,opt,name=record_ipv6,json=recordIpv6,proto3" json:"record_ipv6,omitempty"`
	PrefixIpv4    uint32 `protobuf:"varint,6,opt,name=prefix_ipv4,json=prefixIpv4,proto3" json:"prefix_ipv4,omitempty"`
	PrefixIpv6    uint32 `protobuf:"varint,7,opt,name=prefix_ipv6,json=prefixIpv6,proto3" json:"prefix_ipv6,omitempty"`
	Serial        uint32 `protobuf:"varint,8,opt,name=serial,proto3" json:"serial,omitempty"`
	ReceivedIpv4  int64  `protobuf:"varint,9,opt,name=received_ipv4,json=receivedIpv4,proto3" json:"received_ipv4,omitempty"`
	ReceivedIpv6  int64  `protobuf:"varint,10,opt,name=received_ipv6,json=receivedIpv6,proto3" json:"received_ipv6,omitempty"`
	SerialNotify  int64  `protobuf:"varint,11,opt,name=serial_notify,json=serialNotify,proto3" json:"serial_notify,omitempty"`
	CacheReset    int64  `protobuf:"varint,12,opt,name=cache_reset,json=cacheReset,proto3" json:"cache_reset,omitempty"`
	CacheResponse int64  `protobuf:"varint,13,opt,name=cache_response,json=cacheResponse,proto3" json:"cache_response,omitempty"`
	EndOfData     int64  `protobuf:"varint,14,opt,name=end_of_data,json=endOfData,proto3" json:"end_of_data,omitempty"`
	Error         int64  `protobuf:"varint,15,opt,name=error,proto3" json:"error,omitempty"`
	SerialQuery   int64  `protobuf:"varint,16,opt,name=serial_query,json=serialQuery,proto3" json:"serial_query,omitempty"`
	ResetQuery    int64  `protobuf:"varint,17,opt,name=reset_query,json=resetQuery,proto3" json:"reset_query,omitempty"`
}

func (m *RPKIState) Reset()                    { *m = RPKIState{} }
func (m *RPKIState) String() string            { return proto.CompactTextString(m) }
func (*RPKIState) ProtoMessage()               {}
func (*RPKIState) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{45} }

func (m *RPKIState) GetUptime() int64 {
	if m != nil {
		return m.Uptime
	}
	return 0
}

func (m *RPKIState) GetDowntime() int64 {
	if m != nil {
		return m.Downtime
	}
	return 0
}

func (m *RPKIState) GetUp() bool {
	if m != nil {
		return m.Up
	}
	return false
}

func (m *RPKIState) GetRecordIpv4() uint32 {
	if m != nil {
		return m.RecordIpv4
	}
	return 0
}

func (m *RPKIState) GetRecordIpv6() uint32 {
	if m != nil {
		return m.RecordIpv6
	}
	return 0
}

func (m *RPKIState) GetPrefixIpv4() uint32 {
	if m != nil {
		return m.PrefixIpv4
	}
	return 0
}

func (m *RPKIState) GetPrefixIpv6() uint32 {
	if m != nil {
		return m.PrefixIpv6
	}
	return 0
}

func (m *RPKIState) GetSerial() uint32 {
	if m != nil {
		return m.Serial
	}
	return 0
}

func (m *RPKIState) GetReceivedIpv4() int64 {
	if m != nil {
		return m.ReceivedIpv4
	}
	return 0
}

func (m *RPKIState) GetReceivedIpv6() int64 {
	if m != nil {
		return m.ReceivedIpv6
	}
	return 0
}

func (m *RPKIState) GetSerialNotify() int64 {
	if m != nil {
		return m.SerialNotify
	}
	return 0
}

func (m *RPKIState) GetCacheReset() int64 {
	if m != nil {
		return m.CacheReset
	}
	return 0
}

func (m *RPKIState) GetCacheResponse() int64 {
	if m != nil {
		return m.CacheResponse
	}
	return 0
}

func (m *RPKIState) GetEndOfData() int64 {
	if m != nil {
		return m.EndOfData
	}
	return 0
}

func (m *RPKIState) GetError() int64 {
	if m != nil {
		return m.Error
	}
	return 0
}

func (m *RPKIState) GetSerialQuery() int64 {
	if m != nil {
		return m.SerialQuery
	}
	return 0
}

func (m *RPKIState) GetResetQuery() int64 {
	if m != nil {
		return m.ResetQuery
	}
	return 0
}

type Rpki struct {
	Conf  *RPKIConf  `protobuf:"bytes,1,opt,name=conf" json:"conf,omitempty"`
	State *RPKIState `protobuf:"bytes,2,opt,name=state" json:"state,omitempty"`
}

func (m *Rpki) Reset()                    { *m = Rpki{} }
func (m *Rpki) String() string            { return proto.CompactTextString(m) }
func (*Rpki) ProtoMessage()               {}
func (*Rpki) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{46} }

func (m *Rpki) GetConf() *RPKIConf {
	if m != nil {
		return m.Conf
	}
	return nil
}

func (m *Rpki) GetState() *RPKIState {
	if m != nil {
		return m.State
	}
	return nil
}

type GetRpkiRequest struct {
	Family uint32 `protobuf:"varint,1,opt,name=family,proto3" json:"family,omitempty"`
}

func (m *GetRpkiRequest) Reset()                    { *m = GetRpkiRequest{} }
func (m *GetRpkiRequest) String() string            { return proto.CompactTextString(m) }
func (*GetRpkiRequest) ProtoMessage()               {}
func (*GetRpkiRequest) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{47} }

func (m *GetRpkiRequest) GetFamily() uint32 {
	if m != nil {
		return m.Family
	}
	return 0
}

type GetRpkiResponse struct {
	Servers []*Rpki `protobuf:"bytes,1,rep,name=servers" json:"servers,omitempty"`
}

func (m *GetRpkiResponse) Reset()                    { *m = GetRpkiResponse{} }
func (m *GetRpkiResponse) String() string            { return proto.CompactTextString(m) }
func (*GetRpkiResponse) ProtoMessage()               {}
func (*GetRpkiResponse) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{48} }

func (m *GetRpkiResponse) GetServers() []*Rpki {
	if m != nil {
		return m.Servers
	}
	return nil
}

type AddRpkiRequest struct {
	Address  string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Port     uint32 `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
	Lifetime int64  `protobuf:"varint,3,opt,name=lifetime,proto3" json:"lifetime,omitempty"`
}

func (m *AddRpkiRequest) Reset()                    { *m = AddRpkiRequest{} }
func (m *AddRpkiRequest) String() string            { return proto.CompactTextString(m) }
func (*AddRpkiRequest) ProtoMessage()               {}
func (*AddRpkiRequest) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{49} }

func (m *AddRpkiRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *AddRpkiRequest) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *AddRpkiRequest) GetLifetime() int64 {
	if m != nil {
		return m.Lifetime
	}
	return 0
}

type AddRpkiResponse struct {
}

func (m *AddRpkiResponse) Reset()                    { *m = AddRpkiResponse{} }
func (m *AddRpkiResponse) String() string            { return proto.CompactTextString(m) }
func (*AddRpkiResponse) ProtoMessage()               {}
func (*AddRpkiResponse) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{50} }

type DeleteRpkiRequest struct {
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Port    uint32 `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
}

func (m *DeleteRpkiRequest) Reset()                    { *m = DeleteRpkiRequest{} }
func (m *DeleteRpkiRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteRpkiRequest) ProtoMessage()               {}
func (*DeleteRpkiRequest) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{51} }

func (m *DeleteRpkiRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *DeleteRpkiRequest) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

type DeleteRpkiResponse struct {
}

func (m *DeleteRpkiResponse) Reset()                    { *m = DeleteRpkiResponse{} }
func (m *DeleteRpkiResponse) String() string            { return proto.CompactTextString(m) }
func (*DeleteRpkiResponse) ProtoMessage()               {}
func (*DeleteRpkiResponse) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{52} }

type EnableRpkiRequest struct {
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *EnableRpkiRequest) Reset()                    { *m = EnableRpkiRequest{} }
func (m *EnableRpkiRequest) String() string            { return proto.CompactTextString(m) }
func (*EnableRpkiRequest) ProtoMessage()               {}
func (*EnableRpkiRequest) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{53} }

func (m *EnableRpkiRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type EnableRpkiResponse struct {
}

func (m *EnableRpkiResponse) Reset()                    { *m = EnableRpkiResponse{} }
func (m *EnableRpkiResponse) String() string            { return proto.CompactTextString(m) }
func (*EnableRpkiResponse) ProtoMessage()               {}
func (*EnableRpkiResponse) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{54} }

type DisableRpkiRequest struct {
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *DisableRpkiRequest) Reset()                    { *m = DisableRpkiRequest{} }
func (m *DisableRpkiRequest) String() string            { return proto.CompactTextString(m) }
func (*DisableRpkiRequest) ProtoMessage()               {}
func (*DisableRpkiRequest) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{55} }

func (m *DisableRpkiRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type DisableRpkiResponse struct {
}

func (m *DisableRpkiResponse) Reset()                    { *m = DisableRpkiResponse{} }
func (m *DisableRpkiResponse) String() string            { return proto.CompactTextString(m) }
func (*DisableRpkiResponse) ProtoMessage()               {}
func (*DisableRpkiResponse) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{56} }

type ResetRpkiRequest struct {
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *ResetRpkiRequest) Reset()                    { *m = ResetRpkiRequest{} }
func (m *ResetRpkiRequest) String() string            { return proto.CompactTextString(m) }
func (*ResetRpkiRequest) ProtoMessage()               {}
func (*ResetRpkiRequest) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{57} }

func (m *ResetRpkiRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type ResetRpkiResponse struct {
}

func (m *ResetRpkiResponse) Reset()                    { *m = ResetRpkiResponse{} }
func (m *ResetRpkiResponse) String() string            { return proto.CompactTextString(m) }
func (*ResetRpkiResponse) ProtoMessage()               {}
func (*ResetRpkiResponse) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{58} }

type SoftResetRpkiRequest struct {
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *SoftResetRpkiRequest) Reset()                    { *m = SoftResetRpkiRequest{} }
func (m *SoftResetRpkiRequest) String() string            { return proto.CompactTextString(m) }
func (*SoftResetRpkiRequest) ProtoMessage()               {}
func (*SoftResetRpkiRequest) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{59} }

func (m *SoftResetRpkiRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type SoftResetRpkiResponse struct {
}

func (m *SoftResetRpkiResponse) Reset()                    { *m = SoftResetRpkiResponse{} }
func (m *SoftResetRpkiResponse) String() string            { return proto.CompactTextString(m) }
func (*SoftResetRpkiResponse) ProtoMessage()               {}
func (*SoftResetRpkiResponse) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{60} }

type EnableZebraRequest struct {
	Url                  string   `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	RouteTypes           []string `protobuf:"bytes,2,rep,name=route_types,json=routeTypes" json:"route_types,omitempty"`
	Version              uint32   `protobuf:"varint,3,opt,name=version,proto3" json:"version,omitempty"`
	NexthopTriggerEnable bool     `protobuf:"varint,4,opt,name=nexthop_trigger_enable,json=nexthopTriggerEnable,proto3" json:"nexthop_trigger_enable,omitempty"`
	NexthopTriggerDelay  uint32   `protobuf:"varint,5,opt,name=nexthop_trigger_delay,json=nexthopTriggerDelay,proto3" json:"nexthop_trigger_delay,omitempty"`
}

func (m *EnableZebraRequest) Reset()                    { *m = EnableZebraRequest{} }
func (m *EnableZebraRequest) String() string            { return proto.CompactTextString(m) }
func (*EnableZebraRequest) ProtoMessage()               {}
func (*EnableZebraRequest) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{61} }

func (m *EnableZebraRequest) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *EnableZebraRequest) GetRouteTypes() []string {
	if m != nil {
		return m.RouteTypes
	}
	return nil
}

func (m *EnableZebraRequest) GetVersion() uint32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *EnableZebraRequest) GetNexthopTriggerEnable() bool {
	if m != nil {
		return m.NexthopTriggerEnable
	}
	return false
}

func (m *EnableZebraRequest) GetNexthopTriggerDelay() uint32 {
	if m != nil {
		return m.NexthopTriggerDelay
	}
	return 0
}

type EnableZebraResponse struct {
}

func (m *EnableZebraResponse) Reset()                    { *m = EnableZebraResponse{} }
func (m *EnableZebraResponse) String() string            { return proto.CompactTextString(m) }
func (*EnableZebraResponse) ProtoMessage()               {}
func (*EnableZebraResponse) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{62} }

type GetVrfRequest struct {
}

func (m *GetVrfRequest) Reset()                    { *m = GetVrfRequest{} }
func (m *GetVrfRequest) String() string            { return proto.CompactTextString(m) }
func (*GetVrfRequest) ProtoMessage()               {}
func (*GetVrfRequest) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{63} }

type GetVrfResponse struct {
	Vrfs []*Vrf `protobuf:"bytes,1,rep,name=vrfs" json:"vrfs,omitempty"`
}

func (m *GetVrfResponse) Reset()                    { *m = GetVrfResponse{} }
func (m *GetVrfResponse) String() string            { return proto.CompactTextString(m) }
func (*GetVrfResponse) ProtoMessage()               {}
func (*GetVrfResponse) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{64} }

func (m *GetVrfResponse) GetVrfs() []*Vrf {
	if m != nil {
		return m.Vrfs
	}
	return nil
}

type AddVrfRequest struct {
	Vrf *Vrf `protobuf:"bytes,1,opt,name=vrf" json:"vrf,omitempty"`
}

func (m *AddVrfRequest) Reset()                    { *m = AddVrfRequest{} }
func (m *AddVrfRequest) String() string            { return proto.CompactTextString(m) }
func (*AddVrfRequest) ProtoMessage()               {}
func (*AddVrfRequest) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{65} }

func (m *AddVrfRequest) GetVrf() *Vrf {
	if m != nil {
		return m.Vrf
	}
	return nil
}

type AddVrfResponse struct {
}

func (m *AddVrfResponse) Reset()                    { *m = AddVrfResponse{} }
func (m *AddVrfResponse) String() string            { return proto.CompactTextString(m) }
func (*AddVrfResponse) ProtoMessage()               {}
func (*AddVrfResponse) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{66} }

type DeleteVrfRequest struct {
	Vrf *Vrf `protobuf:"bytes,1,opt,name=vrf" json:"vrf,omitempty"`
}

func (m *DeleteVrfRequest) Reset()                    { *m = DeleteVrfRequest{} }
func (m *DeleteVrfRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteVrfRequest) ProtoMessage()               {}
func (*DeleteVrfRequest) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{67} }

func (m *DeleteVrfRequest) GetVrf() *Vrf {
	if m != nil {
		return m.Vrf
	}
	return nil
}

type DeleteVrfResponse struct {
}

func (m *DeleteVrfResponse) Reset()                    { *m = DeleteVrfResponse{} }
func (m *DeleteVrfResponse) String() string            { return proto.CompactTextString(m) }
func (*DeleteVrfResponse) ProtoMessage()               {}
func (*DeleteVrfResponse) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{68} }

type GetDefinedSetRequest struct {
	Type DefinedType `protobuf:"varint,1,opt,name=type,proto3,enum=gobgpapi.DefinedType" json:"type,omitempty"`
	Name string      `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *GetDefinedSetRequest) Reset()                    { *m = GetDefinedSetRequest{} }
func (m *GetDefinedSetRequest) String() string            { return proto.CompactTextString(m) }
func (*GetDefinedSetRequest) ProtoMessage()               {}
func (*GetDefinedSetRequest) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{69} }

func (m *GetDefinedSetRequest) GetType() DefinedType {
	if m != nil {
		return m.Type
	}
	return DefinedType_PREFIX
}

func (m *GetDefinedSetRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type GetDefinedSetResponse struct {
	Sets []*DefinedSet `protobuf:"bytes,1,rep,name=sets" json:"sets,omitempty"`
}

func (m *GetDefinedSetResponse) Reset()                    { *m = GetDefinedSetResponse{} }
func (m *GetDefinedSetResponse) String() string            { return proto.CompactTextString(m) }
func (*GetDefinedSetResponse) ProtoMessage()               {}
func (*GetDefinedSetResponse) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{70} }

func (m *GetDefinedSetResponse) GetSets() []*DefinedSet {
	if m != nil {
		return m.Sets
	}
	return nil
}

type AddDefinedSetRequest struct {
	Set *DefinedSet `protobuf:"bytes,1,opt,name=set" json:"set,omitempty"`
}

func (m *AddDefinedSetRequest) Reset()                    { *m = AddDefinedSetRequest{} }
func (m *AddDefinedSetRequest) String() string            { return proto.CompactTextString(m) }
func (*AddDefinedSetRequest) ProtoMessage()               {}
func (*AddDefinedSetRequest) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{71} }

func (m *AddDefinedSetRequest) GetSet() *DefinedSet {
	if m != nil {
		return m.Set
	}
	return nil
}

type AddDefinedSetResponse struct {
}

func (m *AddDefinedSetResponse) Reset()                    { *m = AddDefinedSetResponse{} }
func (m *AddDefinedSetResponse) String() string            { return proto.CompactTextString(m) }
func (*AddDefinedSetResponse) ProtoMessage()               {}
func (*AddDefinedSetResponse) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{72} }

type DeleteDefinedSetRequest struct {
	Set *DefinedSet `protobuf:"bytes,1,opt,name=set" json:"set,omitempty"`
	All bool        `protobuf:"varint,2,opt,name=all,proto3" json:"all,omitempty"`
}

func (m *DeleteDefinedSetRequest) Reset()                    { *m = DeleteDefinedSetRequest{} }
func (m *DeleteDefinedSetRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteDefinedSetRequest) ProtoMessage()               {}
func (*DeleteDefinedSetRequest) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{73} }

func (m *DeleteDefinedSetRequest) GetSet() *DefinedSet {
	if m != nil {
		return m.Set
	}
	return nil
}

func (m *DeleteDefinedSetRequest) GetAll() bool {
	if m != nil {
		return m.All
	}
	return false
}

type DeleteDefinedSetResponse struct {
}

func (m *DeleteDefinedSetResponse) Reset()                    { *m = DeleteDefinedSetResponse{} }
func (m *DeleteDefinedSetResponse) String() string            { return proto.CompactTextString(m) }
func (*DeleteDefinedSetResponse) ProtoMessage()               {}
func (*DeleteDefinedSetResponse) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{74} }

type ReplaceDefinedSetRequest struct {
	Set *DefinedSet `protobuf:"bytes,1,opt,name=set" json:"set,omitempty"`
}

func (m *ReplaceDefinedSetRequest) Reset()                    { *m = ReplaceDefinedSetRequest{} }
func (m *ReplaceDefinedSetRequest) String() string            { return proto.CompactTextString(m) }
func (*ReplaceDefinedSetRequest) ProtoMessage()               {}
func (*ReplaceDefinedSetRequest) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{75} }

func (m *ReplaceDefinedSetRequest) GetSet() *DefinedSet {
	if m != nil {
		return m.Set
	}
	return nil
}

type ReplaceDefinedSetResponse struct {
}

func (m *ReplaceDefinedSetResponse) Reset()                    { *m = ReplaceDefinedSetResponse{} }
func (m *ReplaceDefinedSetResponse) String() string            { return proto.CompactTextString(m) }
func (*ReplaceDefinedSetResponse) ProtoMessage()               {}
func (*ReplaceDefinedSetResponse) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{76} }

type GetStatementRequest struct {
}

func (m *GetStatementRequest) Reset()                    { *m = GetStatementRequest{} }
func (m *GetStatementRequest) String() string            { return proto.CompactTextString(m) }
func (*GetStatementRequest) ProtoMessage()               {}
func (*GetStatementRequest) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{77} }

type GetStatementResponse struct {
	Statements []*Statement `protobuf:"bytes,1,rep,name=statements" json:"statements,omitempty"`
}

func (m *GetStatementResponse) Reset()                    { *m = GetStatementResponse{} }
func (m *GetStatementResponse) String() string            { return proto.CompactTextString(m) }
func (*GetStatementResponse) ProtoMessage()               {}
func (*GetStatementResponse) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{78} }

func (m *GetStatementResponse) GetStatements() []*Statement {
	if m != nil {
		return m.Statements
	}
	return nil
}

type AddStatementRequest struct {
	Statement *Statement `protobuf:"bytes,1,opt,name=statement" json:"statement,omitempty"`
}

func (m *AddStatementRequest) Reset()                    { *m = AddStatementRequest{} }
func (m *AddStatementRequest) String() string            { return proto.CompactTextString(m) }
func (*AddStatementRequest) ProtoMessage()               {}
func (*AddStatementRequest) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{79} }

func (m *AddStatementRequest) GetStatement() *Statement {
	if m != nil {
		return m.Statement
	}
	return nil
}

type AddStatementResponse struct {
}

func (m *AddStatementResponse) Reset()                    { *m = AddStatementResponse{} }
func (m *AddStatementResponse) String() string            { return proto.CompactTextString(m) }
func (*AddStatementResponse) ProtoMessage()               {}
func (*AddStatementResponse) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{80} }

type DeleteStatementRequest struct {
	Statement *Statement `protobuf:"bytes,1,opt,name=statement" json:"statement,omitempty"`
	All       bool       `protobuf:"varint,2,opt,name=all,proto3" json:"all,omitempty"`
}

func (m *DeleteStatementRequest) Reset()                    { *m = DeleteStatementRequest{} }
func (m *DeleteStatementRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteStatementRequest) ProtoMessage()               {}
func (*DeleteStatementRequest) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{81} }

func (m *DeleteStatementRequest) GetStatement() *Statement {
	if m != nil {
		return m.Statement
	}
	return nil
}

func (m *DeleteStatementRequest) GetAll() bool {
	if m != nil {
		return m.All
	}
	return false
}

type DeleteStatementResponse struct {
}

func (m *DeleteStatementResponse) Reset()                    { *m = DeleteStatementResponse{} }
func (m *DeleteStatementResponse) String() string            { return proto.CompactTextString(m) }
func (*DeleteStatementResponse) ProtoMessage()               {}
func (*DeleteStatementResponse) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{82} }

type ReplaceStatementRequest struct {
	Statement *Statement `protobuf:"bytes,1,opt,name=statement" json:"statement,omitempty"`
}

func (m *ReplaceStatementRequest) Reset()                    { *m = ReplaceStatementRequest{} }
func (m *ReplaceStatementRequest) String() string            { return proto.CompactTextString(m) }
func (*ReplaceStatementRequest) ProtoMessage()               {}
func (*ReplaceStatementRequest) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{83} }

func (m *ReplaceStatementRequest) GetStatement() *Statement {
	if m != nil {
		return m.Statement
	}
	return nil
}

type ReplaceStatementResponse struct {
}

func (m *ReplaceStatementResponse) Reset()                    { *m = ReplaceStatementResponse{} }
func (m *ReplaceStatementResponse) String() string            { return proto.CompactTextString(m) }
func (*ReplaceStatementResponse) ProtoMessage()               {}
func (*ReplaceStatementResponse) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{84} }

type GetPolicyRequest struct {
}

func (m *GetPolicyRequest) Reset()                    { *m = GetPolicyRequest{} }
func (m *GetPolicyRequest) String() string            { return proto.CompactTextString(m) }
func (*GetPolicyRequest) ProtoMessage()               {}
func (*GetPolicyRequest) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{85} }

type GetPolicyResponse struct {
	Policies []*Policy `protobuf:"bytes,1,rep,name=policies" json:"policies,omitempty"`
}

func (m *GetPolicyResponse) Reset()                    { *m = GetPolicyResponse{} }
func (m *GetPolicyResponse) String() string            { return proto.CompactTextString(m) }
func (*GetPolicyResponse) ProtoMessage()               {}
func (*GetPolicyResponse) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{86} }

func (m *GetPolicyResponse) GetPolicies() []*Policy {
	if m != nil {
		return m.Policies
	}
	return nil
}

type AddPolicyRequest struct {
	Policy *Policy `protobuf:"bytes,1,opt,name=policy" json:"policy,omitempty"`
	// if this flag is set, gobgpd won't define new statements
	// but refer existing statements using statement's names in this arguments.
	ReferExistingStatements bool `protobuf:"varint,2,opt,name=refer_existing_statements,json=referExistingStatements,proto3" json:"refer_existing_statements,omitempty"`
}

func (m *AddPolicyRequest) Reset()                    { *m = AddPolicyRequest{} }
func (m *AddPolicyRequest) String() string            { return proto.CompactTextString(m) }
func (*AddPolicyRequest) ProtoMessage()               {}
func (*AddPolicyRequest) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{87} }

func (m *AddPolicyRequest) GetPolicy() *Policy {
	if m != nil {
		return m.Policy
	}
	return nil
}

func (m *AddPolicyRequest) GetReferExistingStatements() bool {
	if m != nil {
		return m.ReferExistingStatements
	}
	return false
}

type AddPolicyResponse struct {
}

func (m *AddPolicyResponse) Reset()                    { *m = AddPolicyResponse{} }
func (m *AddPolicyResponse) String() string            { return proto.CompactTextString(m) }
func (*AddPolicyResponse) ProtoMessage()               {}
func (*AddPolicyResponse) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{88} }

type DeletePolicyRequest struct {
	Policy *Policy `protobuf:"bytes,1,opt,name=policy" json:"policy,omitempty"`
	// if this flag is set, gobgpd won't delete any statements
	// even if some statements get not used by any policy by this operation.
	PreserveStatements bool `protobuf:"varint,2,opt,name=preserve_statements,json=preserveStatements,proto3" json:"preserve_statements,omitempty"`
	All                bool `protobuf:"varint,3,opt,name=all,proto3" json:"all,omitempty"`
}

func (m *DeletePolicyRequest) Reset()                    { *m = DeletePolicyRequest{} }
func (m *DeletePolicyRequest) String() string            { return proto.CompactTextString(m) }
func (*DeletePolicyRequest) ProtoMessage()               {}
func (*DeletePolicyRequest) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{89} }

func (m *DeletePolicyRequest) GetPolicy() *Policy {
	if m != nil {
		return m.Policy
	}
	return nil
}

func (m *DeletePolicyRequest) GetPreserveStatements() bool {
	if m != nil {
		return m.PreserveStatements
	}
	return false
}

func (m *DeletePolicyRequest) GetAll() bool {
	if m != nil {
		return m.All
	}
	return false
}

type DeletePolicyResponse struct {
}

func (m *DeletePolicyResponse) Reset()                    { *m = DeletePolicyResponse{} }
func (m *DeletePolicyResponse) String() string            { return proto.CompactTextString(m) }
func (*DeletePolicyResponse) ProtoMessage()               {}
func (*DeletePolicyResponse) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{90} }

type ReplacePolicyRequest struct {
	Policy *Policy `protobuf:"bytes,1,opt,name=policy" json:"policy,omitempty"`
	// if this flag is set, gobgpd won't define new statements
	// but refer existing statements using statement's names in this arguments.
	ReferExistingStatements bool `protobuf:"varint,2,opt,name=refer_existing_statements,json=referExistingStatements,proto3" json:"refer_existing_statements,omitempty"`
	// if this flag is set, gobgpd won't delete any statements
	// even if some statements get not used by any policy by this operation.
	PreserveStatements bool `protobuf:"varint,3,opt,name=preserve_statements,json=preserveStatements,proto3" json:"preserve_statements,omitempty"`
}

func (m *ReplacePolicyRequest) Reset()                    { *m = ReplacePolicyRequest{} }
func (m *ReplacePolicyRequest) String() string            { return proto.CompactTextString(m) }
func (*ReplacePolicyRequest) ProtoMessage()               {}
func (*ReplacePolicyRequest) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{91} }

func (m *ReplacePolicyRequest) GetPolicy() *Policy {
	if m != nil {
		return m.Policy
	}
	return nil
}

func (m *ReplacePolicyRequest) GetReferExistingStatements() bool {
	if m != nil {
		return m.ReferExistingStatements
	}
	return false
}

func (m *ReplacePolicyRequest) GetPreserveStatements() bool {
	if m != nil {
		return m.PreserveStatements
	}
	return false
}

type ReplacePolicyResponse struct {
}

func (m *ReplacePolicyResponse) Reset()                    { *m = ReplacePolicyResponse{} }
func (m *ReplacePolicyResponse) String() string            { return proto.CompactTextString(m) }
func (*ReplacePolicyResponse) ProtoMessage()               {}
func (*ReplacePolicyResponse) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{92} }

type GetPolicyAssignmentRequest struct {
	Assignment *PolicyAssignment `protobuf:"bytes,1,opt,name=assignment" json:"assignment,omitempty"`
}

func (m *GetPolicyAssignmentRequest) Reset()                    { *m = GetPolicyAssignmentRequest{} }
func (m *GetPolicyAssignmentRequest) String() string            { return proto.CompactTextString(m) }
func (*GetPolicyAssignmentRequest) ProtoMessage()               {}
func (*GetPolicyAssignmentRequest) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{93} }

func (m *GetPolicyAssignmentRequest) GetAssignment() *PolicyAssignment {
	if m != nil {
		return m.Assignment
	}
	return nil
}

type GetPolicyAssignmentResponse struct {
	Assignment *PolicyAssignment `protobuf:"bytes,1,opt,name=assignment" json:"assignment,omitempty"`
}

func (m *GetPolicyAssignmentResponse) Reset()         { *m = GetPolicyAssignmentResponse{} }
func (m *GetPolicyAssignmentResponse) String() string { return proto.CompactTextString(m) }
func (*GetPolicyAssignmentResponse) ProtoMessage()    {}
func (*GetPolicyAssignmentResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorGobgp, []int{94}
}

func (m *GetPolicyAssignmentResponse) GetAssignment() *PolicyAssignment {
	if m != nil {
		return m.Assignment
	}
	return nil
}

type AddPolicyAssignmentRequest struct {
	Assignment *PolicyAssignment `protobuf:"bytes,1,opt,name=assignment" json:"assignment,omitempty"`
}

func (m *AddPolicyAssignmentRequest) Reset()                    { *m = AddPolicyAssignmentRequest{} }
func (m *AddPolicyAssignmentRequest) String() string            { return proto.CompactTextString(m) }
func (*AddPolicyAssignmentRequest) ProtoMessage()               {}
func (*AddPolicyAssignmentRequest) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{95} }

func (m *AddPolicyAssignmentRequest) GetAssignment() *PolicyAssignment {
	if m != nil {
		return m.Assignment
	}
	return nil
}

type AddPolicyAssignmentResponse struct {
}

func (m *AddPolicyAssignmentResponse) Reset()         { *m = AddPolicyAssignmentResponse{} }
func (m *AddPolicyAssignmentResponse) String() string { return proto.CompactTextString(m) }
func (*AddPolicyAssignmentResponse) ProtoMessage()    {}
func (*AddPolicyAssignmentResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorGobgp, []int{96}
}

type DeletePolicyAssignmentRequest struct {
	Assignment *PolicyAssignment `protobuf:"bytes,1,opt,name=assignment" json:"assignment,omitempty"`
	All        bool              `protobuf:"varint,2,opt,name=all,proto3" json:"all,omitempty"`
}

func (m *DeletePolicyAssignmentRequest) Reset()         { *m = DeletePolicyAssignmentRequest{} }
func (m *DeletePolicyAssignmentRequest) String() string { return proto.CompactTextString(m) }
func (*DeletePolicyAssignmentRequest) ProtoMessage()    {}
func (*DeletePolicyAssignmentRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorGobgp, []int{97}
}

func (m *DeletePolicyAssignmentRequest) GetAssignment() *PolicyAssignment {
	if m != nil {
		return m.Assignment
	}
	return nil
}

func (m *DeletePolicyAssignmentRequest) GetAll() bool {
	if m != nil {
		return m.All
	}
	return false
}

type DeletePolicyAssignmentResponse struct {
}

func (m *DeletePolicyAssignmentResponse) Reset()         { *m = DeletePolicyAssignmentResponse{} }
func (m *DeletePolicyAssignmentResponse) String() string { return proto.CompactTextString(m) }
func (*DeletePolicyAssignmentResponse) ProtoMessage()    {}
func (*DeletePolicyAssignmentResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorGobgp, []int{98}
}

type ReplacePolicyAssignmentRequest struct {
	Assignment *PolicyAssignment `protobuf:"bytes,1,opt,name=assignment" json:"assignment,omitempty"`
}

func (m *ReplacePolicyAssignmentRequest) Reset()         { *m = ReplacePolicyAssignmentRequest{} }
func (m *ReplacePolicyAssignmentRequest) String() string { return proto.CompactTextString(m) }
func (*ReplacePolicyAssignmentRequest) ProtoMessage()    {}
func (*ReplacePolicyAssignmentRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorGobgp, []int{99}
}

func (m *ReplacePolicyAssignmentRequest) GetAssignment() *PolicyAssignment {
	if m != nil {
		return m.Assignment
	}
	return nil
}

type ReplacePolicyAssignmentResponse struct {
}

func (m *ReplacePolicyAssignmentResponse) Reset()         { *m = ReplacePolicyAssignmentResponse{} }
func (m *ReplacePolicyAssignmentResponse) String() string { return proto.CompactTextString(m) }
func (*ReplacePolicyAssignmentResponse) ProtoMessage()    {}
func (*ReplacePolicyAssignmentResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorGobgp, []int{100}
}

type GetServerRequest struct {
}

func (m *GetServerRequest) Reset()                    { *m = GetServerRequest{} }
func (m *GetServerRequest) String() string            { return proto.CompactTextString(m) }
func (*GetServerRequest) ProtoMessage()               {}
func (*GetServerRequest) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{101} }

type GetServerResponse struct {
	Global *Global `protobuf:"bytes,1,opt,name=global" json:"global,omitempty"`
}

func (m *GetServerResponse) Reset()                    { *m = GetServerResponse{} }
func (m *GetServerResponse) String() string            { return proto.CompactTextString(m) }
func (*GetServerResponse) ProtoMessage()               {}
func (*GetServerResponse) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{102} }

func (m *GetServerResponse) GetGlobal() *Global {
	if m != nil {
		return m.Global
	}
	return nil
}

type StartServerRequest struct {
	Global *Global `protobuf:"bytes,1,opt,name=global" json:"global,omitempty"`
}

func (m *StartServerRequest) Reset()                    { *m = StartServerRequest{} }
func (m *StartServerRequest) String() string            { return proto.CompactTextString(m) }
func (*StartServerRequest) ProtoMessage()               {}
func (*StartServerRequest) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{103} }

func (m *StartServerRequest) GetGlobal() *Global {
	if m != nil {
		return m.Global
	}
	return nil
}

type StartServerResponse struct {
}

func (m *StartServerResponse) Reset()                    { *m = StartServerResponse{} }
func (m *StartServerResponse) String() string            { return proto.CompactTextString(m) }
func (*StartServerResponse) ProtoMessage()               {}
func (*StartServerResponse) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{104} }

type StopServerRequest struct {
}

func (m *StopServerRequest) Reset()                    { *m = StopServerRequest{} }
func (m *StopServerRequest) String() string            { return proto.CompactTextString(m) }
func (*StopServerRequest) ProtoMessage()               {}
func (*StopServerRequest) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{105} }

type StopServerResponse struct {
}

func (m *StopServerResponse) Reset()                    { *m = StopServerResponse{} }
func (m *StopServerResponse) String() string            { return proto.CompactTextString(m) }
func (*StopServerResponse) ProtoMessage()               {}
func (*StopServerResponse) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{106} }

type RPKIValidation struct {
	State           RPKIValidation_State  `protobuf:"varint,1,opt,name=state,proto3,enum=gobgpapi.RPKIValidation_State" json:"state,omitempty"`
	Reason          RPKIValidation_Reason `protobuf:"varint,2,opt,name=reason,proto3,enum=gobgpapi.RPKIValidation_Reason" json:"reason,omitempty"`
	Matched         []*Roa                `protobuf:"bytes,3,rep,name=matched" json:"matched,omitempty"`
	UnmatchedAs     []*Roa                `protobuf:"bytes,4,rep,name=unmatched_as,json=unmatchedAs" json:"unmatched_as,omitempty"`
	UnmatchedLength []*Roa                `protobuf:"bytes,5,rep,name=unmatched_length,json=unmatchedLength" json:"unmatched_length,omitempty"`
}

func (m *RPKIValidation) Reset()                    { *m = RPKIValidation{} }
func (m *RPKIValidation) String() string            { return proto.CompactTextString(m) }
func (*RPKIValidation) ProtoMessage()               {}
func (*RPKIValidation) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{107} }

func (m *RPKIValidation) GetState() RPKIValidation_State {
	if m != nil {
		return m.State
	}
	return RPKIValidation_STATE_NONE
}

func (m *RPKIValidation) GetReason() RPKIValidation_Reason {
	if m != nil {
		return m.Reason
	}
	return RPKIValidation_REASOT_NONE
}

func (m *RPKIValidation) GetMatched() []*Roa {
	if m != nil {
		return m.Matched
	}
	return nil
}

func (m *RPKIValidation) GetUnmatchedAs() []*Roa {
	if m != nil {
		return m.UnmatchedAs
	}
	return nil
}

func (m *RPKIValidation) GetUnmatchedLength() []*Roa {
	if m != nil {
		return m.UnmatchedLength
	}
	return nil
}

type Path struct {
	Nlri               []byte          `protobuf:"bytes,1,opt,name=nlri,proto3" json:"nlri,omitempty"`
	Pattrs             [][]byte        `protobuf:"bytes,2,rep,name=pattrs" json:"pattrs,omitempty"`
	Age                int64           `protobuf:"varint,3,opt,name=age,proto3" json:"age,omitempty"`
	Best               bool            `protobuf:"varint,4,opt,name=best,proto3" json:"best,omitempty"`
	IsWithdraw         bool            `protobuf:"varint,5,opt,name=is_withdraw,json=isWithdraw,proto3" json:"is_withdraw,omitempty"`
	Validation         int32           `protobuf:"varint,6,opt,name=validation,proto3" json:"validation,omitempty"`
	ValidationDetail   *RPKIValidation `protobuf:"bytes,7,opt,name=validation_detail,json=validationDetail" json:"validation_detail,omitempty"`
	NoImplicitWithdraw bool            `protobuf:"varint,8,opt,name=no_implicit_withdraw,json=noImplicitWithdraw,proto3" json:"no_implicit_withdraw,omitempty"`
	Family             uint32          `protobuf:"varint,9,opt,name=family,proto3" json:"family,omitempty"`
	SourceAsn          uint32          `protobuf:"varint,10,opt,name=source_asn,json=sourceAsn,proto3" json:"source_asn,omitempty"`
	SourceId           string          `protobuf:"bytes,11,opt,name=source_id,json=sourceId,proto3" json:"source_id,omitempty"`
	Filtered           bool            `protobuf:"varint,12,opt,name=filtered,proto3" json:"filtered,omitempty"`
	Stale              bool            `protobuf:"varint,13,opt,name=stale,proto3" json:"stale,omitempty"`
	IsFromExternal     bool            `protobuf:"varint,14,opt,name=is_from_external,json=isFromExternal,proto3" json:"is_from_external,omitempty"`
	NeighborIp         string          `protobuf:"bytes,15,opt,name=neighbor_ip,json=neighborIp,proto3" json:"neighbor_ip,omitempty"`
	Uuid               []byte          `protobuf:"bytes,16,opt,name=uuid,proto3" json:"uuid,omitempty"`
	IsNexthopInvalid   bool            `protobuf:"varint,17,opt,name=is_nexthop_invalid,json=isNexthopInvalid,proto3" json:"is_nexthop_invalid,omitempty"`
	Identifier         uint32          `protobuf:"varint,18,opt,name=identifier,proto3" json:"identifier,omitempty"`
	LocalIdentifier    uint32          `protobuf:"varint,19,opt,name=local_identifier,json=localIdentifier,proto3" json:"local_identifier,omitempty"`
	// One of the following defined in "api/bgp/attribute.proto":
	// - IPAddressPrefix
	// - LabeledIPAddressPrefix
	// - EncapsulationNLRI
	// - EVPNEthernetAutoDiscoveryRoute
	// - EVPNMACIPAdvertisementRoute
	// - EVPNInclusiveMulticastEthernetTagRoute
	// - EVPNEthernetSegmentRoute
	// - EVPNIPPrefixRoute
	// - LabeledVPNIPAddressPrefix
	// - RouteTargetMembershipNLRI
	// - FlowSpecNLRI
	// - VPNFlowSpecNLRI
	// - OpaqueNLRI
	AnyNlri *google_protobuf.Any `protobuf:"bytes,20,opt,name=any_nlri,json=anyNlri" json:"any_nlri,omitempty"`
	// Each attribute must be on of *Attribute defined in
	// "api/bgp/attribute.proto".
	AnyPattrs []*google_protobuf.Any `protobuf:"bytes,21,rep,name=any_pattrs,json=anyPattrs" json:"any_pattrs,omitempty"`
}

func (m *Path) Reset()                    { *m = Path{} }
func (m *Path) String() string            { return proto.CompactTextString(m) }
func (*Path) ProtoMessage()               {}
func (*Path) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{108} }

func (m *Path) GetNlri() []byte {
	if m != nil {
		return m.Nlri
	}
	return nil
}

func (m *Path) GetPattrs() [][]byte {
	if m != nil {
		return m.Pattrs
	}
	return nil
}

func (m *Path) GetAge() int64 {
	if m != nil {
		return m.Age
	}
	return 0
}

func (m *Path) GetBest() bool {
	if m != nil {
		return m.Best
	}
	return false
}

func (m *Path) GetIsWithdraw() bool {
	if m != nil {
		return m.IsWithdraw
	}
	return false
}

func (m *Path) GetValidation() int32 {
	if m != nil {
		return m.Validation
	}
	return 0
}

func (m *Path) GetValidationDetail() *RPKIValidation {
	if m != nil {
		return m.ValidationDetail
	}
	return nil
}

func (m *Path) GetNoImplicitWithdraw() bool {
	if m != nil {
		return m.NoImplicitWithdraw
	}
	return false
}

func (m *Path) GetFamily() uint32 {
	if m != nil {
		return m.Family
	}
	return 0
}

func (m *Path) GetSourceAsn() uint32 {
	if m != nil {
		return m.SourceAsn
	}
	return 0
}

func (m *Path) GetSourceId() string {
	if m != nil {
		return m.SourceId
	}
	return ""
}

func (m *Path) GetFiltered() bool {
	if m != nil {
		return m.Filtered
	}
	return false
}

func (m *Path) GetStale() bool {
	if m != nil {
		return m.Stale
	}
	return false
}

func (m *Path) GetIsFromExternal() bool {
	if m != nil {
		return m.IsFromExternal
	}
	return false
}

func (m *Path) GetNeighborIp() string {
	if m != nil {
		return m.NeighborIp
	}
	return ""
}

func (m *Path) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *Path) GetIsNexthopInvalid() bool {
	if m != nil {
		return m.IsNexthopInvalid
	}
	return false
}

func (m *Path) GetIdentifier() uint32 {
	if m != nil {
		return m.Identifier
	}
	return 0
}

func (m *Path) GetLocalIdentifier() uint32 {
	if m != nil {
		return m.LocalIdentifier
	}
	return 0
}

func (m *Path) GetAnyNlri() *google_protobuf.Any {
	if m != nil {
		return m.AnyNlri
	}
	return nil
}

func (m *Path) GetAnyPattrs() []*google_protobuf.Any {
	if m != nil {
		return m.AnyPattrs
	}
	return nil
}

type Destination struct {
	Prefix          string  `protobuf:"bytes,1,opt,name=prefix,proto3" json:"prefix,omitempty"`
	Paths           []*Path `protobuf:"bytes,2,rep,name=paths" json:"paths,omitempty"`
	LongerPrefixes  bool    `protobuf:"varint,3,opt,name=longer_prefixes,json=longerPrefixes,proto3" json:"longer_prefixes,omitempty"`
	ShorterPrefixes bool    `protobuf:"varint,4,opt,name=shorter_prefixes,json=shorterPrefixes,proto3" json:"shorter_prefixes,omitempty"`
}

func (m *Destination) Reset()                    { *m = Destination{} }
func (m *Destination) String() string            { return proto.CompactTextString(m) }
func (*Destination) ProtoMessage()               {}
func (*Destination) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{109} }

func (m *Destination) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

func (m *Destination) GetPaths() []*Path {
	if m != nil {
		return m.Paths
	}
	return nil
}

func (m *Destination) GetLongerPrefixes() bool {
	if m != nil {
		return m.LongerPrefixes
	}
	return false
}

func (m *Destination) GetShorterPrefixes() bool {
	if m != nil {
		return m.ShorterPrefixes
	}
	return false
}

type Table struct {
	Type         Resource       `protobuf:"varint,1,opt,name=type,proto3,enum=gobgpapi.Resource" json:"type,omitempty"`
	Name         string         `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Family       uint32         `protobuf:"varint,3,opt,name=family,proto3" json:"family,omitempty"`
	Destinations []*Destination `protobuf:"bytes,4,rep,name=destinations" json:"destinations,omitempty"`
	PostPolicy   bool           `protobuf:"varint,5,opt,name=post_policy,json=postPolicy,proto3" json:"post_policy,omitempty"`
}

func (m *Table) Reset()                    { *m = Table{} }
func (m *Table) String() string            { return proto.CompactTextString(m) }
func (*Table) ProtoMessage()               {}
func (*Table) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{110} }

func (m *Table) GetType() Resource {
	if m != nil {
		return m.Type
	}
	return Resource_GLOBAL
}

func (m *Table) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Table) GetFamily() uint32 {
	if m != nil {
		return m.Family
	}
	return 0
}

func (m *Table) GetDestinations() []*Destination {
	if m != nil {
		return m.Destinations
	}
	return nil
}

func (m *Table) GetPostPolicy() bool {
	if m != nil {
		return m.PostPolicy
	}
	return false
}

type GetRibRequest struct {
	Table *Table `protobuf:"bytes,1,opt,name=table" json:"table,omitempty"`
}

func (m *GetRibRequest) Reset()                    { *m = GetRibRequest{} }
func (m *GetRibRequest) String() string            { return proto.CompactTextString(m) }
func (*GetRibRequest) ProtoMessage()               {}
func (*GetRibRequest) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{111} }

func (m *GetRibRequest) GetTable() *Table {
	if m != nil {
		return m.Table
	}
	return nil
}

type GetRibResponse struct {
	Table *Table `protobuf:"bytes,1,opt,name=table" json:"table,omitempty"`
}

func (m *GetRibResponse) Reset()                    { *m = GetRibResponse{} }
func (m *GetRibResponse) String() string            { return proto.CompactTextString(m) }
func (*GetRibResponse) ProtoMessage()               {}
func (*GetRibResponse) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{112} }

func (m *GetRibResponse) GetTable() *Table {
	if m != nil {
		return m.Table
	}
	return nil
}

// API representation of table.LookupPrefix
type TableLookupPrefix struct {
	Prefix       string            `protobuf:"bytes,1,opt,name=prefix,proto3" json:"prefix,omitempty"`
	LookupOption TableLookupOption `protobuf:"varint,2,opt,name=lookup_option,json=lookupOption,proto3,enum=gobgpapi.TableLookupOption" json:"lookup_option,omitempty"`
}

func (m *TableLookupPrefix) Reset()                    { *m = TableLookupPrefix{} }
func (m *TableLookupPrefix) String() string            { return proto.CompactTextString(m) }
func (*TableLookupPrefix) ProtoMessage()               {}
func (*TableLookupPrefix) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{113} }

func (m *TableLookupPrefix) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

func (m *TableLookupPrefix) GetLookupOption() TableLookupOption {
	if m != nil {
		return m.LookupOption
	}
	return TableLookupOption_LOOKUP_EXACT
}

type GetPathRequest struct {
	Type     Resource             `protobuf:"varint,1,opt,name=type,proto3,enum=gobgpapi.Resource" json:"type,omitempty"`
	Name     string               `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Family   uint32               `protobuf:"varint,3,opt,name=family,proto3" json:"family,omitempty"`
	Prefixes []*TableLookupPrefix `protobuf:"bytes,4,rep,name=prefixes" json:"prefixes,omitempty"`
}

func (m *GetPathRequest) Reset()                    { *m = GetPathRequest{} }
func (m *GetPathRequest) String() string            { return proto.CompactTextString(m) }
func (*GetPathRequest) ProtoMessage()               {}
func (*GetPathRequest) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{114} }

func (m *GetPathRequest) GetType() Resource {
	if m != nil {
		return m.Type
	}
	return Resource_GLOBAL
}

func (m *GetPathRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GetPathRequest) GetFamily() uint32 {
	if m != nil {
		return m.Family
	}
	return 0
}

func (m *GetPathRequest) GetPrefixes() []*TableLookupPrefix {
	if m != nil {
		return m.Prefixes
	}
	return nil
}

type ValidateRibRequest struct {
	Type   Resource `protobuf:"varint,1,opt,name=type,proto3,enum=gobgpapi.Resource" json:"type,omitempty"`
	Family uint32   `protobuf:"varint,2,opt,name=family,proto3" json:"family,omitempty"`
	Prefix string   `protobuf:"bytes,3,opt,name=prefix,proto3" json:"prefix,omitempty"`
}

func (m *ValidateRibRequest) Reset()                    { *m = ValidateRibRequest{} }
func (m *ValidateRibRequest) String() string            { return proto.CompactTextString(m) }
func (*ValidateRibRequest) ProtoMessage()               {}
func (*ValidateRibRequest) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{115} }

func (m *ValidateRibRequest) GetType() Resource {
	if m != nil {
		return m.Type
	}
	return Resource_GLOBAL
}

func (m *ValidateRibRequest) GetFamily() uint32 {
	if m != nil {
		return m.Family
	}
	return 0
}

func (m *ValidateRibRequest) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

type ValidateRibResponse struct {
}

func (m *ValidateRibResponse) Reset()                    { *m = ValidateRibResponse{} }
func (m *ValidateRibResponse) String() string            { return proto.CompactTextString(m) }
func (*ValidateRibResponse) ProtoMessage()               {}
func (*ValidateRibResponse) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{116} }

type Peer struct {
	// Note: Regarding to the consistency with OpenConfig model, a list of
	// address family should be removed from here, and should be configured with
	// the list of AfiSafi instead.
	Families        []uint32         `protobuf:"varint,1,rep,packed,name=families" json:"families,omitempty"`
	ApplyPolicy     *ApplyPolicy     `protobuf:"bytes,2,opt,name=apply_policy,json=applyPolicy" json:"apply_policy,omitempty"`
	Conf            *PeerConf        `protobuf:"bytes,3,opt,name=conf" json:"conf,omitempty"`
	EbgpMultihop    *EbgpMultihop    `protobuf:"bytes,4,opt,name=ebgp_multihop,json=ebgpMultihop" json:"ebgp_multihop,omitempty"`
	RouteReflector  *RouteReflector  `protobuf:"bytes,5,opt,name=route_reflector,json=routeReflector" json:"route_reflector,omitempty"`
	Info            *PeerState       `protobuf:"bytes,6,opt,name=info" json:"info,omitempty"`
	Timers          *Timers          `protobuf:"bytes,7,opt,name=timers" json:"timers,omitempty"`
	Transport       *Transport       `protobuf:"bytes,8,opt,name=transport" json:"transport,omitempty"`
	RouteServer     *RouteServer     `protobuf:"bytes,9,opt,name=route_server,json=routeServer" json:"route_server,omitempty"`
	GracefulRestart *GracefulRestart `protobuf:"bytes,10,opt,name=graceful_restart,json=gracefulRestart" json:"graceful_restart,omitempty"`
	AfiSafis        []*AfiSafi       `protobuf:"bytes,11,rep,name=afi_safis,json=afiSafis" json:"afi_safis,omitempty"`
	AddPaths        *AddPaths        `protobuf:"bytes,12,opt,name=add_paths,json=addPaths" json:"add_paths,omitempty"`
}

func (m *Peer) Reset()                    { *m = Peer{} }
func (m *Peer) String() string            { return proto.CompactTextString(m) }
func (*Peer) ProtoMessage()               {}
func (*Peer) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{117} }

func (m *Peer) GetFamilies() []uint32 {
	if m != nil {
		return m.Families
	}
	return nil
}

func (m *Peer) GetApplyPolicy() *ApplyPolicy {
	if m != nil {
		return m.ApplyPolicy
	}
	return nil
}

func (m *Peer) GetConf() *PeerConf {
	if m != nil {
		return m.Conf
	}
	return nil
}

func (m *Peer) GetEbgpMultihop() *EbgpMultihop {
	if m != nil {
		return m.EbgpMultihop
	}
	return nil
}

func (m *Peer) GetRouteReflector() *RouteReflector {
	if m != nil {
		return m.RouteReflector
	}
	return nil
}

func (m *Peer) GetInfo() *PeerState {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *Peer) GetTimers() *Timers {
	if m != nil {
		return m.Timers
	}
	return nil
}

func (m *Peer) GetTransport() *Transport {
	if m != nil {
		return m.Transport
	}
	return nil
}

func (m *Peer) GetRouteServer() *RouteServer {
	if m != nil {
		return m.RouteServer
	}
	return nil
}

func (m *Peer) GetGracefulRestart() *GracefulRestart {
	if m != nil {
		return m.GracefulRestart
	}
	return nil
}

func (m *Peer) GetAfiSafis() []*AfiSafi {
	if m != nil {
		return m.AfiSafis
	}
	return nil
}

func (m *Peer) GetAddPaths() *AddPaths {
	if m != nil {
		return m.AddPaths
	}
	return nil
}

type PeerGroup struct {
	// Note: Regarding to the consistency with OpenConfig model, a list of
	// address family should be removed from here, and should be configured with
	// the list of AfiSafi instead.
	Families        []uint32         `protobuf:"varint,1,rep,packed,name=families" json:"families,omitempty"`
	ApplyPolicy     *ApplyPolicy     `protobuf:"bytes,2,opt,name=apply_policy,json=applyPolicy" json:"apply_policy,omitempty"`
	Conf            *PeerGroupConf   `protobuf:"bytes,3,opt,name=conf" json:"conf,omitempty"`
	EbgpMultihop    *EbgpMultihop    `protobuf:"bytes,4,opt,name=ebgp_multihop,json=ebgpMultihop" json:"ebgp_multihop,omitempty"`
	RouteReflector  *RouteReflector  `protobuf:"bytes,5,opt,name=route_reflector,json=routeReflector" json:"route_reflector,omitempty"`
	Info            *PeerGroupState  `protobuf:"bytes,6,opt,name=info" json:"info,omitempty"`
	Timers          *Timers          `protobuf:"bytes,7,opt,name=timers" json:"timers,omitempty"`
	Transport       *Transport       `protobuf:"bytes,8,opt,name=transport" json:"transport,omitempty"`
	RouteServer     *RouteServer     `protobuf:"bytes,9,opt,name=route_server,json=routeServer" json:"route_server,omitempty"`
	GracefulRestart *GracefulRestart `protobuf:"bytes,10,opt,name=graceful_restart,json=gracefulRestart" json:"graceful_restart,omitempty"`
	AfiSafis        []*AfiSafi       `protobuf:"bytes,11,rep,name=afi_safis,json=afiSafis" json:"afi_safis,omitempty"`
	AddPaths        *AddPaths        `protobuf:"bytes,12,opt,name=add_paths,json=addPaths" json:"add_paths,omitempty"`
}

func (m *PeerGroup) Reset()                    { *m = PeerGroup{} }
func (m *PeerGroup) String() string            { return proto.CompactTextString(m) }
func (*PeerGroup) ProtoMessage()               {}
func (*PeerGroup) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{118} }

func (m *PeerGroup) GetFamilies() []uint32 {
	if m != nil {
		return m.Families
	}
	return nil
}

func (m *PeerGroup) GetApplyPolicy() *ApplyPolicy {
	if m != nil {
		return m.ApplyPolicy
	}
	return nil
}

func (m *PeerGroup) GetConf() *PeerGroupConf {
	if m != nil {
		return m.Conf
	}
	return nil
}

func (m *PeerGroup) GetEbgpMultihop() *EbgpMultihop {
	if m != nil {
		return m.EbgpMultihop
	}
	return nil
}

func (m *PeerGroup) GetRouteReflector() *RouteReflector {
	if m != nil {
		return m.RouteReflector
	}
	return nil
}

func (m *PeerGroup) GetInfo() *PeerGroupState {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *PeerGroup) GetTimers() *Timers {
	if m != nil {
		return m.Timers
	}
	return nil
}

func (m *PeerGroup) GetTransport() *Transport {
	if m != nil {
		return m.Transport
	}
	return nil
}

func (m *PeerGroup) GetRouteServer() *RouteServer {
	if m != nil {
		return m.RouteServer
	}
	return nil
}

func (m *PeerGroup) GetGracefulRestart() *GracefulRestart {
	if m != nil {
		return m.GracefulRestart
	}
	return nil
}

func (m *PeerGroup) GetAfiSafis() []*AfiSafi {
	if m != nil {
		return m.AfiSafis
	}
	return nil
}

func (m *PeerGroup) GetAddPaths() *AddPaths {
	if m != nil {
		return m.AddPaths
	}
	return nil
}

type DynamicNeighbor struct {
	Prefix    string `protobuf:"bytes,1,opt,name=prefix,proto3" json:"prefix,omitempty"`
	PeerGroup string `protobuf:"bytes,2,opt,name=peer_group,json=peerGroup,proto3" json:"peer_group,omitempty"`
}

func (m *DynamicNeighbor) Reset()                    { *m = DynamicNeighbor{} }
func (m *DynamicNeighbor) String() string            { return proto.CompactTextString(m) }
func (*DynamicNeighbor) ProtoMessage()               {}
func (*DynamicNeighbor) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{119} }

func (m *DynamicNeighbor) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

func (m *DynamicNeighbor) GetPeerGroup() string {
	if m != nil {
		return m.PeerGroup
	}
	return ""
}

type ApplyPolicy struct {
	InPolicy     *PolicyAssignment `protobuf:"bytes,1,opt,name=in_policy,json=inPolicy" json:"in_policy,omitempty"`
	ExportPolicy *PolicyAssignment `protobuf:"bytes,2,opt,name=export_policy,json=exportPolicy" json:"export_policy,omitempty"`
	ImportPolicy *PolicyAssignment `protobuf:"bytes,3,opt,name=import_policy,json=importPolicy" json:"import_policy,omitempty"`
}

func (m *ApplyPolicy) Reset()                    { *m = ApplyPolicy{} }
func (m *ApplyPolicy) String() string            { return proto.CompactTextString(m) }
func (*ApplyPolicy) ProtoMessage()               {}
func (*ApplyPolicy) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{120} }

func (m *ApplyPolicy) GetInPolicy() *PolicyAssignment {
	if m != nil {
		return m.InPolicy
	}
	return nil
}

func (m *ApplyPolicy) GetExportPolicy() *PolicyAssignment {
	if m != nil {
		return m.ExportPolicy
	}
	return nil
}

func (m *ApplyPolicy) GetImportPolicy() *PolicyAssignment {
	if m != nil {
		return m.ImportPolicy
	}
	return nil
}

type PrefixLimit struct {
	Family               uint32 `protobuf:"varint,1,opt,name=family,proto3" json:"family,omitempty"`
	MaxPrefixes          uint32 `protobuf:"varint,2,opt,name=max_prefixes,json=maxPrefixes,proto3" json:"max_prefixes,omitempty"`
	ShutdownThresholdPct uint32 `protobuf:"varint,3,opt,name=shutdown_threshold_pct,json=shutdownThresholdPct,proto3" json:"shutdown_threshold_pct,omitempty"`
}

func (m *PrefixLimit) Reset()                    { *m = PrefixLimit{} }
func (m *PrefixLimit) String() string            { return proto.CompactTextString(m) }
func (*PrefixLimit) ProtoMessage()               {}
func (*PrefixLimit) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{121} }

func (m *PrefixLimit) GetFamily() uint32 {
	if m != nil {
		return m.Family
	}
	return 0
}

func (m *PrefixLimit) GetMaxPrefixes() uint32 {
	if m != nil {
		return m.MaxPrefixes
	}
	return 0
}

func (m *PrefixLimit) GetShutdownThresholdPct() uint32 {
	if m != nil {
		return m.ShutdownThresholdPct
	}
	return 0
}

type PeerConf struct {
	AuthPassword     string                   `protobuf:"bytes,1,opt,name=auth_password,json=authPassword,proto3" json:"auth_password,omitempty"`
	Description      string                   `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	LocalAs          uint32                   `protobuf:"varint,3,opt,name=local_as,json=localAs,proto3" json:"local_as,omitempty"`
	NeighborAddress  string                   `protobuf:"bytes,4,opt,name=neighbor_address,json=neighborAddress,proto3" json:"neighbor_address,omitempty"`
	PeerAs           uint32                   `protobuf:"varint,5,opt,name=peer_as,json=peerAs,proto3" json:"peer_as,omitempty"`
	PeerGroup        string                   `protobuf:"bytes,6,opt,name=peer_group,json=peerGroup,proto3" json:"peer_group,omitempty"`
	PeerType         uint32                   `protobuf:"varint,7,opt,name=peer_type,json=peerType,proto3" json:"peer_type,omitempty"`
	RemovePrivateAs  PeerConf_RemovePrivateAs `protobuf:"varint,8,opt,name=remove_private_as,json=removePrivateAs,proto3,enum=gobgpapi.PeerConf_RemovePrivateAs" json:"remove_private_as,omitempty"`
	RouteFlapDamping bool                     `protobuf:"varint,9,opt,name=route_flap_damping,json=routeFlapDamping,proto3" json:"route_flap_damping,omitempty"`
	SendCommunity    uint32                   `protobuf:"varint,10,opt,name=send_community,json=sendCommunity,proto3" json:"send_community,omitempty"`
	RemoteCap        [][]byte                 `protobuf:"bytes,11,rep,name=remote_cap,json=remoteCap" json:"remote_cap,omitempty"`
	LocalCap         [][]byte                 `protobuf:"bytes,12,rep,name=local_cap,json=localCap" json:"local_cap,omitempty"`
	Id               string                   `protobuf:"bytes,13,opt,name=id,proto3" json:"id,omitempty"`
	// Note: Regarding to the consistency with OpenConfig model, list of
	// PrefixLimit should be removed from here, and list of PrefixLimit in
	// AfiSafi should be used instead.
	PrefixLimits      []*PrefixLimit `protobuf:"bytes,14,rep,name=prefix_limits,json=prefixLimits" json:"prefix_limits,omitempty"`
	LocalAddress      string         `protobuf:"bytes,15,opt,name=local_address,json=localAddress,proto3" json:"local_address,omitempty"`
	NeighborInterface string         `protobuf:"bytes,16,opt,name=neighbor_interface,json=neighborInterface,proto3" json:"neighbor_interface,omitempty"`
	Vrf               string         `protobuf:"bytes,17,opt,name=vrf,proto3" json:"vrf,omitempty"`
	AllowOwnAs        uint32         `protobuf:"varint,18,opt,name=allow_own_as,json=allowOwnAs,proto3" json:"allow_own_as,omitempty"`
	ReplacePeerAs     bool           `protobuf:"varint,19,opt,name=replace_peer_as,json=replacePeerAs,proto3" json:"replace_peer_as,omitempty"`
}

func (m *PeerConf) Reset()                    { *m = PeerConf{} }
func (m *PeerConf) String() string            { return proto.CompactTextString(m) }
func (*PeerConf) ProtoMessage()               {}
func (*PeerConf) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{122} }

func (m *PeerConf) GetAuthPassword() string {
	if m != nil {
		return m.AuthPassword
	}
	return ""
}

func (m *PeerConf) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *PeerConf) GetLocalAs() uint32 {
	if m != nil {
		return m.LocalAs
	}
	return 0
}

func (m *PeerConf) GetNeighborAddress() string {
	if m != nil {
		return m.NeighborAddress
	}
	return ""
}

func (m *PeerConf) GetPeerAs() uint32 {
	if m != nil {
		return m.PeerAs
	}
	return 0
}

func (m *PeerConf) GetPeerGroup() string {
	if m != nil {
		return m.PeerGroup
	}
	return ""
}

func (m *PeerConf) GetPeerType() uint32 {
	if m != nil {
		return m.PeerType
	}
	return 0
}

func (m *PeerConf) GetRemovePrivateAs() PeerConf_RemovePrivateAs {
	if m != nil {
		return m.RemovePrivateAs
	}
	return PeerConf_NONE
}

func (m *PeerConf) GetRouteFlapDamping() bool {
	if m != nil {
		return m.RouteFlapDamping
	}
	return false
}

func (m *PeerConf) GetSendCommunity() uint32 {
	if m != nil {
		return m.SendCommunity
	}
	return 0
}

func (m *PeerConf) GetRemoteCap() [][]byte {
	if m != nil {
		return m.RemoteCap
	}
	return nil
}

func (m *PeerConf) GetLocalCap() [][]byte {
	if m != nil {
		return m.LocalCap
	}
	return nil
}

func (m *PeerConf) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *PeerConf) GetPrefixLimits() []*PrefixLimit {
	if m != nil {
		return m.PrefixLimits
	}
	return nil
}

func (m *PeerConf) GetLocalAddress() string {
	if m != nil {
		return m.LocalAddress
	}
	return ""
}

func (m *PeerConf) GetNeighborInterface() string {
	if m != nil {
		return m.NeighborInterface
	}
	return ""
}

func (m *PeerConf) GetVrf() string {
	if m != nil {
		return m.Vrf
	}
	return ""
}

func (m *PeerConf) GetAllowOwnAs() uint32 {
	if m != nil {
		return m.AllowOwnAs
	}
	return 0
}

func (m *PeerConf) GetReplacePeerAs() bool {
	if m != nil {
		return m.ReplacePeerAs
	}
	return false
}

type PeerGroupConf struct {
	AuthPassword     string                        `protobuf:"bytes,1,opt,name=auth_password,json=authPassword,proto3" json:"auth_password,omitempty"`
	Description      string                        `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	LocalAs          uint32                        `protobuf:"varint,3,opt,name=local_as,json=localAs,proto3" json:"local_as,omitempty"`
	PeerAs           uint32                        `protobuf:"varint,5,opt,name=peer_as,json=peerAs,proto3" json:"peer_as,omitempty"`
	PeerGroupName    string                        `protobuf:"bytes,6,opt,name=peer_group_name,json=peerGroupName,proto3" json:"peer_group_name,omitempty"`
	PeerType         uint32                        `protobuf:"varint,7,opt,name=peer_type,json=peerType,proto3" json:"peer_type,omitempty"`
	RemovePrivateAs  PeerGroupConf_RemovePrivateAs `protobuf:"varint,8,opt,name=remove_private_as,json=removePrivateAs,proto3,enum=gobgpapi.PeerGroupConf_RemovePrivateAs" json:"remove_private_as,omitempty"`
	RouteFlapDamping bool                          `protobuf:"varint,9,opt,name=route_flap_damping,json=routeFlapDamping,proto3" json:"route_flap_damping,omitempty"`
	SendCommunity    uint32                        `protobuf:"varint,10,opt,name=send_community,json=sendCommunity,proto3" json:"send_community,omitempty"`
}

func (m *PeerGroupConf) Reset()                    { *m = PeerGroupConf{} }
func (m *PeerGroupConf) String() string            { return proto.CompactTextString(m) }
func (*PeerGroupConf) ProtoMessage()               {}
func (*PeerGroupConf) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{123} }

func (m *PeerGroupConf) GetAuthPassword() string {
	if m != nil {
		return m.AuthPassword
	}
	return ""
}

func (m *PeerGroupConf) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *PeerGroupConf) GetLocalAs() uint32 {
	if m != nil {
		return m.LocalAs
	}
	return 0
}

func (m *PeerGroupConf) GetPeerAs() uint32 {
	if m != nil {
		return m.PeerAs
	}
	return 0
}

func (m *PeerGroupConf) GetPeerGroupName() string {
	if m != nil {
		return m.PeerGroupName
	}
	return ""
}

func (m *PeerGroupConf) GetPeerType() uint32 {
	if m != nil {
		return m.PeerType
	}
	return 0
}

func (m *PeerGroupConf) GetRemovePrivateAs() PeerGroupConf_RemovePrivateAs {
	if m != nil {
		return m.RemovePrivateAs
	}
	return PeerGroupConf_NONE
}

func (m *PeerGroupConf) GetRouteFlapDamping() bool {
	if m != nil {
		return m.RouteFlapDamping
	}
	return false
}

func (m *PeerGroupConf) GetSendCommunity() uint32 {
	if m != nil {
		return m.SendCommunity
	}
	return 0
}

type PeerGroupState struct {
	AuthPassword     string                         `protobuf:"bytes,1,opt,name=auth_password,json=authPassword,proto3" json:"auth_password,omitempty"`
	Description      string                         `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	LocalAs          uint32                         `protobuf:"varint,3,opt,name=local_as,json=localAs,proto3" json:"local_as,omitempty"`
	PeerAs           uint32                         `protobuf:"varint,5,opt,name=peer_as,json=peerAs,proto3" json:"peer_as,omitempty"`
	PeerGroupName    string                         `protobuf:"bytes,6,opt,name=peer_group_name,json=peerGroupName,proto3" json:"peer_group_name,omitempty"`
	PeerType         uint32                         `protobuf:"varint,7,opt,name=peer_type,json=peerType,proto3" json:"peer_type,omitempty"`
	RemovePrivateAs  PeerGroupState_RemovePrivateAs `protobuf:"varint,8,opt,name=remove_private_as,json=removePrivateAs,proto3,enum=gobgpapi.PeerGroupState_RemovePrivateAs" json:"remove_private_as,omitempty"`
	RouteFlapDamping bool                           `protobuf:"varint,9,opt,name=route_flap_damping,json=routeFlapDamping,proto3" json:"route_flap_damping,omitempty"`
	SendCommunity    uint32                         `protobuf:"varint,10,opt,name=send_community,json=sendCommunity,proto3" json:"send_community,omitempty"`
	TotalPaths       uint32                         `protobuf:"varint,11,opt,name=total_paths,json=totalPaths,proto3" json:"total_paths,omitempty"`
	TotalPrefixes    uint32                         `protobuf:"varint,12,opt,name=total_prefixes,json=totalPrefixes,proto3" json:"total_prefixes,omitempty"`
}

func (m *PeerGroupState) Reset()                    { *m = PeerGroupState{} }
func (m *PeerGroupState) String() string            { return proto.CompactTextString(m) }
func (*PeerGroupState) ProtoMessage()               {}
func (*PeerGroupState) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{124} }

func (m *PeerGroupState) GetAuthPassword() string {
	if m != nil {
		return m.AuthPassword
	}
	return ""
}

func (m *PeerGroupState) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *PeerGroupState) GetLocalAs() uint32 {
	if m != nil {
		return m.LocalAs
	}
	return 0
}

func (m *PeerGroupState) GetPeerAs() uint32 {
	if m != nil {
		return m.PeerAs
	}
	return 0
}

func (m *PeerGroupState) GetPeerGroupName() string {
	if m != nil {
		return m.PeerGroupName
	}
	return ""
}

func (m *PeerGroupState) GetPeerType() uint32 {
	if m != nil {
		return m.PeerType
	}
	return 0
}

func (m *PeerGroupState) GetRemovePrivateAs() PeerGroupState_RemovePrivateAs {
	if m != nil {
		return m.RemovePrivateAs
	}
	return PeerGroupState_NONE
}

func (m *PeerGroupState) GetRouteFlapDamping() bool {
	if m != nil {
		return m.RouteFlapDamping
	}
	return false
}

func (m *PeerGroupState) GetSendCommunity() uint32 {
	if m != nil {
		return m.SendCommunity
	}
	return 0
}

func (m *PeerGroupState) GetTotalPaths() uint32 {
	if m != nil {
		return m.TotalPaths
	}
	return 0
}

func (m *PeerGroupState) GetTotalPrefixes() uint32 {
	if m != nil {
		return m.TotalPrefixes
	}
	return 0
}

type EbgpMultihop struct {
	Enabled     bool   `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	MultihopTtl uint32 `protobuf:"varint,2,opt,name=multihop_ttl,json=multihopTtl,proto3" json:"multihop_ttl,omitempty"`
}

func (m *EbgpMultihop) Reset()                    { *m = EbgpMultihop{} }
func (m *EbgpMultihop) String() string            { return proto.CompactTextString(m) }
func (*EbgpMultihop) ProtoMessage()               {}
func (*EbgpMultihop) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{125} }

func (m *EbgpMultihop) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *EbgpMultihop) GetMultihopTtl() uint32 {
	if m != nil {
		return m.MultihopTtl
	}
	return 0
}

type RouteReflector struct {
	RouteReflectorClient    bool   `protobuf:"varint,1,opt,name=route_reflector_client,json=routeReflectorClient,proto3" json:"route_reflector_client,omitempty"`
	RouteReflectorClusterId string `protobuf:"bytes,2,opt,name=route_reflector_cluster_id,json=routeReflectorClusterId,proto3" json:"route_reflector_cluster_id,omitempty"`
}

func (m *RouteReflector) Reset()                    { *m = RouteReflector{} }
func (m *RouteReflector) String() string            { return proto.CompactTextString(m) }
func (*RouteReflector) ProtoMessage()               {}
func (*RouteReflector) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{126} }

func (m *RouteReflector) GetRouteReflectorClient() bool {
	if m != nil {
		return m.RouteReflectorClient
	}
	return false
}

func (m *RouteReflector) GetRouteReflectorClusterId() string {
	if m != nil {
		return m.RouteReflectorClusterId
	}
	return ""
}

type PeerState struct {
	AuthPassword          string               `protobuf:"bytes,1,opt,name=auth_password,json=authPassword,proto3" json:"auth_password,omitempty"`
	Description           string               `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	LocalAs               uint32               `protobuf:"varint,3,opt,name=local_as,json=localAs,proto3" json:"local_as,omitempty"`
	Messages              *Messages            `protobuf:"bytes,4,opt,name=messages" json:"messages,omitempty"`
	NeighborAddress       string               `protobuf:"bytes,5,opt,name=neighbor_address,json=neighborAddress,proto3" json:"neighbor_address,omitempty"`
	PeerAs                uint32               `protobuf:"varint,6,opt,name=peer_as,json=peerAs,proto3" json:"peer_as,omitempty"`
	PeerGroup             string               `protobuf:"bytes,7,opt,name=peer_group,json=peerGroup,proto3" json:"peer_group,omitempty"`
	PeerType              uint32               `protobuf:"varint,8,opt,name=peer_type,json=peerType,proto3" json:"peer_type,omitempty"`
	Queues                *Queues              `protobuf:"bytes,9,opt,name=queues" json:"queues,omitempty"`
	RemovePrivateAs       uint32               `protobuf:"varint,10,opt,name=remove_private_as,json=removePrivateAs,proto3" json:"remove_private_as,omitempty"`
	RouteFlapDamping      bool                 `protobuf:"varint,11,opt,name=route_flap_damping,json=routeFlapDamping,proto3" json:"route_flap_damping,omitempty"`
	SendCommunity         uint32               `protobuf:"varint,12,opt,name=send_community,json=sendCommunity,proto3" json:"send_community,omitempty"`
	SessionState          uint32               `protobuf:"varint,13,opt,name=session_state,json=sessionState,proto3" json:"session_state,omitempty"`
	SupportedCapabilities []string             `protobuf:"bytes,14,rep,name=supported_capabilities,json=supportedCapabilities" json:"supported_capabilities,omitempty"`
	BgpState              string               `protobuf:"bytes,15,opt,name=bgp_state,json=bgpState,proto3" json:"bgp_state,omitempty"`
	AdminState            PeerState_AdminState `protobuf:"varint,16,opt,name=admin_state,json=adminState,proto3,enum=gobgpapi.PeerState_AdminState" json:"admin_state,omitempty"`
	Received              uint32               `protobuf:"varint,17,opt,name=received,proto3" json:"received,omitempty"`
	Accepted              uint32               `protobuf:"varint,18,opt,name=accepted,proto3" json:"accepted,omitempty"`
	Advertised            uint32               `protobuf:"varint,19,opt,name=advertised,proto3" json:"advertised,omitempty"`
	OutQ                  uint32               `protobuf:"varint,20,opt,name=out_q,json=outQ,proto3" json:"out_q,omitempty"`
	Flops                 uint32               `protobuf:"varint,21,opt,name=flops,proto3" json:"flops,omitempty"`
}

func (m *PeerState) Reset()                    { *m = PeerState{} }
func (m *PeerState) String() string            { return proto.CompactTextString(m) }
func (*PeerState) ProtoMessage()               {}
func (*PeerState) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{127} }

func (m *PeerState) GetAuthPassword() string {
	if m != nil {
		return m.AuthPassword
	}
	return ""
}

func (m *PeerState) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *PeerState) GetLocalAs() uint32 {
	if m != nil {
		return m.LocalAs
	}
	return 0
}

func (m *PeerState) GetMessages() *Messages {
	if m != nil {
		return m.Messages
	}
	return nil
}

func (m *PeerState) GetNeighborAddress() string {
	if m != nil {
		return m.NeighborAddress
	}
	return ""
}

func (m *PeerState) GetPeerAs() uint32 {
	if m != nil {
		return m.PeerAs
	}
	return 0
}

func (m *PeerState) GetPeerGroup() string {
	if m != nil {
		return m.PeerGroup
	}
	return ""
}

func (m *PeerState) GetPeerType() uint32 {
	if m != nil {
		return m.PeerType
	}
	return 0
}

func (m *PeerState) GetQueues() *Queues {
	if m != nil {
		return m.Queues
	}
	return nil
}

func (m *PeerState) GetRemovePrivateAs() uint32 {
	if m != nil {
		return m.RemovePrivateAs
	}
	return 0
}

func (m *PeerState) GetRouteFlapDamping() bool {
	if m != nil {
		return m.RouteFlapDamping
	}
	return false
}

func (m *PeerState) GetSendCommunity() uint32 {
	if m != nil {
		return m.SendCommunity
	}
	return 0
}

func (m *PeerState) GetSessionState() uint32 {
	if m != nil {
		return m.SessionState
	}
	return 0
}

func (m *PeerState) GetSupportedCapabilities() []string {
	if m != nil {
		return m.SupportedCapabilities
	}
	return nil
}

func (m *PeerState) GetBgpState() string {
	if m != nil {
		return m.BgpState
	}
	return ""
}

func (m *PeerState) GetAdminState() PeerState_AdminState {
	if m != nil {
		return m.AdminState
	}
	return PeerState_UP
}

func (m *PeerState) GetReceived() uint32 {
	if m != nil {
		return m.Received
	}
	return 0
}

func (m *PeerState) GetAccepted() uint32 {
	if m != nil {
		return m.Accepted
	}
	return 0
}

func (m *PeerState) GetAdvertised() uint32 {
	if m != nil {
		return m.Advertised
	}
	return 0
}

func (m *PeerState) GetOutQ() uint32 {
	if m != nil {
		return m.OutQ
	}
	return 0
}

func (m *PeerState) GetFlops() uint32 {
	if m != nil {
		return m.Flops
	}
	return 0
}

type Messages struct {
	Received *Message `protobuf:"bytes,1,opt,name=received" json:"received,omitempty"`
	Sent     *Message `protobuf:"bytes,2,opt,name=sent" json:"sent,omitempty"`
}

func (m *Messages) Reset()                    { *m = Messages{} }
func (m *Messages) String() string            { return proto.CompactTextString(m) }
func (*Messages) ProtoMessage()               {}
func (*Messages) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{128} }

func (m *Messages) GetReceived() *Message {
	if m != nil {
		return m.Received
	}
	return nil
}

func (m *Messages) GetSent() *Message {
	if m != nil {
		return m.Sent
	}
	return nil
}

type Message struct {
	NOTIFICATION uint64 `protobuf:"varint,1,opt,name=NOTIFICATION,proto3" json:"NOTIFICATION,omitempty"`
	UPDATE       uint64 `protobuf:"varint,2,opt,name=UPDATE,proto3" json:"UPDATE,omitempty"`
	OPEN         uint64 `protobuf:"varint,3,opt,name=OPEN,proto3" json:"OPEN,omitempty"`
	KEEPALIVE    uint64 `protobuf:"varint,4,opt,name=KEEPALIVE,proto3" json:"KEEPALIVE,omitempty"`
	REFRESH      uint64 `protobuf:"varint,5,opt,name=REFRESH,proto3" json:"REFRESH,omitempty"`
	DISCARDED    uint64 `protobuf:"varint,6,opt,name=DISCARDED,proto3" json:"DISCARDED,omitempty"`
	TOTAL        uint64 `protobuf:"varint,7,opt,name=TOTAL,proto3" json:"TOTAL,omitempty"`
}

func (m *Message) Reset()                    { *m = Message{} }
func (m *Message) String() string            { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()               {}
func (*Message) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{129} }

func (m *Message) GetNOTIFICATION() uint64 {
	if m != nil {
		return m.NOTIFICATION
	}
	return 0
}

func (m *Message) GetUPDATE() uint64 {
	if m != nil {
		return m.UPDATE
	}
	return 0
}

func (m *Message) GetOPEN() uint64 {
	if m != nil {
		return m.OPEN
	}
	return 0
}

func (m *Message) GetKEEPALIVE() uint64 {
	if m != nil {
		return m.KEEPALIVE
	}
	return 0
}

func (m *Message) GetREFRESH() uint64 {
	if m != nil {
		return m.REFRESH
	}
	return 0
}

func (m *Message) GetDISCARDED() uint64 {
	if m != nil {
		return m.DISCARDED
	}
	return 0
}

func (m *Message) GetTOTAL() uint64 {
	if m != nil {
		return m.TOTAL
	}
	return 0
}

type Queues struct {
	Input  uint32 `protobuf:"varint,1,opt,name=input,proto3" json:"input,omitempty"`
	Output uint32 `protobuf:"varint,2,opt,name=output,proto3" json:"output,omitempty"`
}

func (m *Queues) Reset()                    { *m = Queues{} }
func (m *Queues) String() string            { return proto.CompactTextString(m) }
func (*Queues) ProtoMessage()               {}
func (*Queues) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{130} }

func (m *Queues) GetInput() uint32 {
	if m != nil {
		return m.Input
	}
	return 0
}

func (m *Queues) GetOutput() uint32 {
	if m != nil {
		return m.Output
	}
	return 0
}

type Timers struct {
	Config *TimersConfig `protobuf:"bytes,1,opt,name=config" json:"config,omitempty"`
	State  *TimersState  `protobuf:"bytes,2,opt,name=state" json:"state,omitempty"`
}

func (m *Timers) Reset()                    { *m = Timers{} }
func (m *Timers) String() string            { return proto.CompactTextString(m) }
func (*Timers) ProtoMessage()               {}
func (*Timers) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{131} }

func (m *Timers) GetConfig() *TimersConfig {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *Timers) GetState() *TimersState {
	if m != nil {
		return m.State
	}
	return nil
}

type TimersConfig struct {
	ConnectRetry                 uint64 `protobuf:"varint,1,opt,name=connect_retry,json=connectRetry,proto3" json:"connect_retry,omitempty"`
	HoldTime                     uint64 `protobuf:"varint,2,opt,name=hold_time,json=holdTime,proto3" json:"hold_time,omitempty"`
	KeepaliveInterval            uint64 `protobuf:"varint,3,opt,name=keepalive_interval,json=keepaliveInterval,proto3" json:"keepalive_interval,omitempty"`
	MinimumAdvertisementInterval uint64 `protobuf:"varint,4,opt,name=minimum_advertisement_interval,json=minimumAdvertisementInterval,proto3" json:"minimum_advertisement_interval,omitempty"`
}

func (m *TimersConfig) Reset()                    { *m = TimersConfig{} }
func (m *TimersConfig) String() string            { return proto.CompactTextString(m) }
func (*TimersConfig) ProtoMessage()               {}
func (*TimersConfig) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{132} }

func (m *TimersConfig) GetConnectRetry() uint64 {
	if m != nil {
		return m.ConnectRetry
	}
	return 0
}

func (m *TimersConfig) GetHoldTime() uint64 {
	if m != nil {
		return m.HoldTime
	}
	return 0
}

func (m *TimersConfig) GetKeepaliveInterval() uint64 {
	if m != nil {
		return m.KeepaliveInterval
	}
	return 0
}

func (m *TimersConfig) GetMinimumAdvertisementInterval() uint64 {
	if m != nil {
		return m.MinimumAdvertisementInterval
	}
	return 0
}

type TimersState struct {
	ConnectRetry                 uint64 `protobuf:"varint,1,opt,name=connect_retry,json=connectRetry,proto3" json:"connect_retry,omitempty"`
	HoldTime                     uint64 `protobuf:"varint,2,opt,name=hold_time,json=holdTime,proto3" json:"hold_time,omitempty"`
	KeepaliveInterval            uint64 `protobuf:"varint,3,opt,name=keepalive_interval,json=keepaliveInterval,proto3" json:"keepalive_interval,omitempty"`
	MinimumAdvertisementInterval uint64 `protobuf:"varint,4,opt,name=minimum_advertisement_interval,json=minimumAdvertisementInterval,proto3" json:"minimum_advertisement_interval,omitempty"`
	NegotiatedHoldTime           uint64 `protobuf:"varint,5,opt,name=negotiated_hold_time,json=negotiatedHoldTime,proto3" json:"negotiated_hold_time,omitempty"`
	Uptime                       uint64 `protobuf:"varint,6,opt,name=uptime,proto3" json:"uptime,omitempty"`
	Downtime                     uint64 `protobuf:"varint,7,opt,name=downtime,proto3" json:"downtime,omitempty"`
}

func (m *TimersState) Reset()                    { *m = TimersState{} }
func (m *TimersState) String() string            { return proto.CompactTextString(m) }
func (*TimersState) ProtoMessage()               {}
func (*TimersState) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{133} }

func (m *TimersState) GetConnectRetry() uint64 {
	if m != nil {
		return m.ConnectRetry
	}
	return 0
}

func (m *TimersState) GetHoldTime() uint64 {
	if m != nil {
		return m.HoldTime
	}
	return 0
}

func (m *TimersState) GetKeepaliveInterval() uint64 {
	if m != nil {
		return m.KeepaliveInterval
	}
	return 0
}

func (m *TimersState) GetMinimumAdvertisementInterval() uint64 {
	if m != nil {
		return m.MinimumAdvertisementInterval
	}
	return 0
}

func (m *TimersState) GetNegotiatedHoldTime() uint64 {
	if m != nil {
		return m.NegotiatedHoldTime
	}
	return 0
}

func (m *TimersState) GetUptime() uint64 {
	if m != nil {
		return m.Uptime
	}
	return 0
}

func (m *TimersState) GetDowntime() uint64 {
	if m != nil {
		return m.Downtime
	}
	return 0
}

type Transport struct {
	LocalAddress  string `protobuf:"bytes,1,opt,name=local_address,json=localAddress,proto3" json:"local_address,omitempty"`
	LocalPort     uint32 `protobuf:"varint,2,opt,name=local_port,json=localPort,proto3" json:"local_port,omitempty"`
	MtuDiscovery  bool   `protobuf:"varint,3,opt,name=mtu_discovery,json=mtuDiscovery,proto3" json:"mtu_discovery,omitempty"`
	PassiveMode   bool   `protobuf:"varint,4,opt,name=passive_mode,json=passiveMode,proto3" json:"passive_mode,omitempty"`
	RemoteAddress string `protobuf:"bytes,5,opt,name=remote_address,json=remoteAddress,proto3" json:"remote_address,omitempty"`
	RemotePort    uint32 `protobuf:"varint,6,opt,name=remote_port,json=remotePort,proto3" json:"remote_port,omitempty"`
	TcpMss        uint32 `protobuf:"varint,7,opt,name=tcp_mss,json=tcpMss,proto3" json:"tcp_mss,omitempty"`
}

func (m *Transport) Reset()                    { *m = Transport{} }
func (m *Transport) String() string            { return proto.CompactTextString(m) }
func (*Transport) ProtoMessage()               {}
func (*Transport) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{134} }

func (m *Transport) GetLocalAddress() string {
	if m != nil {
		return m.LocalAddress
	}
	return ""
}

func (m *Transport) GetLocalPort() uint32 {
	if m != nil {
		return m.LocalPort
	}
	return 0
}

func (m *Transport) GetMtuDiscovery() bool {
	if m != nil {
		return m.MtuDiscovery
	}
	return false
}

func (m *Transport) GetPassiveMode() bool {
	if m != nil {
		return m.PassiveMode
	}
	return false
}

func (m *Transport) GetRemoteAddress() string {
	if m != nil {
		return m.RemoteAddress
	}
	return ""
}

func (m *Transport) GetRemotePort() uint32 {
	if m != nil {
		return m.RemotePort
	}
	return 0
}

func (m *Transport) GetTcpMss() uint32 {
	if m != nil {
		return m.TcpMss
	}
	return 0
}

type RouteServer struct {
	RouteServerClient bool `protobuf:"varint,1,opt,name=route_server_client,json=routeServerClient,proto3" json:"route_server_client,omitempty"`
}

func (m *RouteServer) Reset()                    { *m = RouteServer{} }
func (m *RouteServer) String() string            { return proto.CompactTextString(m) }
func (*RouteServer) ProtoMessage()               {}
func (*RouteServer) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{135} }

func (m *RouteServer) GetRouteServerClient() bool {
	if m != nil {
		return m.RouteServerClient
	}
	return false
}

type GracefulRestart struct {
	Enabled             bool   `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	RestartTime         uint32 `protobuf:"varint,2,opt,name=restart_time,json=restartTime,proto3" json:"restart_time,omitempty"`
	HelperOnly          bool   `protobuf:"varint,3,opt,name=helper_only,json=helperOnly,proto3" json:"helper_only,omitempty"`
	DeferralTime        uint32 `protobuf:"varint,4,opt,name=deferral_time,json=deferralTime,proto3" json:"deferral_time,omitempty"`
	NotificationEnabled bool   `protobuf:"varint,5,opt,name=notification_enabled,json=notificationEnabled,proto3" json:"notification_enabled,omitempty"`
	LonglivedEnabled    bool   `protobuf:"varint,6,opt,name=longlived_enabled,json=longlivedEnabled,proto3" json:"longlived_enabled,omitempty"`
	StaleRoutesTime     uint32 `protobuf:"varint,7,opt,name=stale_routes_time,json=staleRoutesTime,proto3" json:"stale_routes_time,omitempty"`
	PeerRestartTime     uint32 `protobuf:"varint,8,opt,name=peer_restart_time,json=peerRestartTime,proto3" json:"peer_restart_time,omitempty"`
	PeerRestarting      bool   `protobuf:"varint,9,opt,name=peer_restarting,json=peerRestarting,proto3" json:"peer_restarting,omitempty"`
	LocalRestarting     bool   `protobuf:"varint,10,opt,name=local_restarting,json=localRestarting,proto3" json:"local_restarting,omitempty"`
	Mode                string `protobuf:"bytes,11,opt,name=mode,proto3" json:"mode,omitempty"`
}

func (m *GracefulRestart) Reset()                    { *m = GracefulRestart{} }
func (m *GracefulRestart) String() string            { return proto.CompactTextString(m) }
func (*GracefulRestart) ProtoMessage()               {}
func (*GracefulRestart) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{136} }

func (m *GracefulRestart) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *GracefulRestart) GetRestartTime() uint32 {
	if m != nil {
		return m.RestartTime
	}
	return 0
}

func (m *GracefulRestart) GetHelperOnly() bool {
	if m != nil {
		return m.HelperOnly
	}
	return false
}

func (m *GracefulRestart) GetDeferralTime() uint32 {
	if m != nil {
		return m.DeferralTime
	}
	return 0
}

func (m *GracefulRestart) GetNotificationEnabled() bool {
	if m != nil {
		return m.NotificationEnabled
	}
	return false
}

func (m *GracefulRestart) GetLonglivedEnabled() bool {
	if m != nil {
		return m.LonglivedEnabled
	}
	return false
}

func (m *GracefulRestart) GetStaleRoutesTime() uint32 {
	if m != nil {
		return m.StaleRoutesTime
	}
	return 0
}

func (m *GracefulRestart) GetPeerRestartTime() uint32 {
	if m != nil {
		return m.PeerRestartTime
	}
	return 0
}

func (m *GracefulRestart) GetPeerRestarting() bool {
	if m != nil {
		return m.PeerRestarting
	}
	return false
}

func (m *GracefulRestart) GetLocalRestarting() bool {
	if m != nil {
		return m.LocalRestarting
	}
	return false
}

func (m *GracefulRestart) GetMode() string {
	if m != nil {
		return m.Mode
	}
	return ""
}

type MpGracefulRestartConfig struct {
	Enabled bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
}

func (m *MpGracefulRestartConfig) Reset()                    { *m = MpGracefulRestartConfig{} }
func (m *MpGracefulRestartConfig) String() string            { return proto.CompactTextString(m) }
func (*MpGracefulRestartConfig) ProtoMessage()               {}
func (*MpGracefulRestartConfig) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{137} }

func (m *MpGracefulRestartConfig) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

type MpGracefulRestartState struct {
	Enabled          bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	Received         bool `protobuf:"varint,2,opt,name=received,proto3" json:"received,omitempty"`
	Advertised       bool `protobuf:"varint,3,opt,name=advertised,proto3" json:"advertised,omitempty"`
	EndOfRibReceived bool `protobuf:"varint,4,opt,name=end_of_rib_received,json=endOfRibReceived,proto3" json:"end_of_rib_received,omitempty"`
	EndOfRibSent     bool `protobuf:"varint,5,opt,name=end_of_rib_sent,json=endOfRibSent,proto3" json:"end_of_rib_sent,omitempty"`
}

func (m *MpGracefulRestartState) Reset()                    { *m = MpGracefulRestartState{} }
func (m *MpGracefulRestartState) String() string            { return proto.CompactTextString(m) }
func (*MpGracefulRestartState) ProtoMessage()               {}
func (*MpGracefulRestartState) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{138} }

func (m *MpGracefulRestartState) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *MpGracefulRestartState) GetReceived() bool {
	if m != nil {
		return m.Received
	}
	return false
}

func (m *MpGracefulRestartState) GetAdvertised() bool {
	if m != nil {
		return m.Advertised
	}
	return false
}

func (m *MpGracefulRestartState) GetEndOfRibReceived() bool {
	if m != nil {
		return m.EndOfRibReceived
	}
	return false
}

func (m *MpGracefulRestartState) GetEndOfRibSent() bool {
	if m != nil {
		return m.EndOfRibSent
	}
	return false
}

type MpGracefulRestart struct {
	Config *MpGracefulRestartConfig `protobuf:"bytes,1,opt,name=config" json:"config,omitempty"`
	State  *MpGracefulRestartState  `protobuf:"bytes,2,opt,name=state" json:"state,omitempty"`
}

func (m *MpGracefulRestart) Reset()                    { *m = MpGracefulRestart{} }
func (m *MpGracefulRestart) String() string            { return proto.CompactTextString(m) }
func (*MpGracefulRestart) ProtoMessage()               {}
func (*MpGracefulRestart) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{139} }

func (m *MpGracefulRestart) GetConfig() *MpGracefulRestartConfig {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *MpGracefulRestart) GetState() *MpGracefulRestartState {
	if m != nil {
		return m.State
	}
	return nil
}

type AfiSafiConfig struct {
	Family  uint32 `protobuf:"varint,1,opt,name=family,proto3" json:"family,omitempty"`
	Enabled bool   `protobuf:"varint,2,opt,name=enabled,proto3" json:"enabled,omitempty"`
}

func (m *AfiSafiConfig) Reset()                    { *m = AfiSafiConfig{} }
func (m *AfiSafiConfig) String() string            { return proto.CompactTextString(m) }
func (*AfiSafiConfig) ProtoMessage()               {}
func (*AfiSafiConfig) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{140} }

func (m *AfiSafiConfig) GetFamily() uint32 {
	if m != nil {
		return m.Family
	}
	return 0
}

func (m *AfiSafiConfig) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

type AfiSafiState struct {
	Family        uint32 `protobuf:"varint,1,opt,name=family,proto3" json:"family,omitempty"`
	Enabled       bool   `protobuf:"varint,2,opt,name=enabled,proto3" json:"enabled,omitempty"`
	TotalPaths    uint32 `protobuf:"varint,3,opt,name=total_paths,json=totalPaths,proto3" json:"total_paths,omitempty"`
	TotalPrefixes uint32 `protobuf:"varint,4,opt,name=total_prefixes,json=totalPrefixes,proto3" json:"total_prefixes,omitempty"`
}

func (m *AfiSafiState) Reset()                    { *m = AfiSafiState{} }
func (m *AfiSafiState) String() string            { return proto.CompactTextString(m) }
func (*AfiSafiState) ProtoMessage()               {}
func (*AfiSafiState) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{141} }

func (m *AfiSafiState) GetFamily() uint32 {
	if m != nil {
		return m.Family
	}
	return 0
}

func (m *AfiSafiState) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *AfiSafiState) GetTotalPaths() uint32 {
	if m != nil {
		return m.TotalPaths
	}
	return 0
}

func (m *AfiSafiState) GetTotalPrefixes() uint32 {
	if m != nil {
		return m.TotalPrefixes
	}
	return 0
}

type RouteSelectionOptionsConfig struct {
	AlwaysCompareMed         bool `protobuf:"varint,1,opt,name=always_compare_med,json=alwaysCompareMed,proto3" json:"always_compare_med,omitempty"`
	IgnoreAsPathLength       bool `protobuf:"varint,2,opt,name=ignore_as_path_length,json=ignoreAsPathLength,proto3" json:"ignore_as_path_length,omitempty"`
	ExternalCompareRouterId  bool `protobuf:"varint,3,opt,name=external_compare_router_id,json=externalCompareRouterId,proto3" json:"external_compare_router_id,omitempty"`
	AdvertiseInactiveRoutes  bool `protobuf:"varint,4,opt,name=advertise_inactive_routes,json=advertiseInactiveRoutes,proto3" json:"advertise_inactive_routes,omitempty"`
	EnableAigp               bool `protobuf:"varint,5,opt,name=enable_aigp,json=enableAigp,proto3" json:"enable_aigp,omitempty"`
	IgnoreNextHopIgpMetric   bool `protobuf:"varint,6,opt,name=ignore_next_hop_igp_metric,json=ignoreNextHopIgpMetric,proto3" json:"ignore_next_hop_igp_metric,omitempty"`
	DisableBestPathSelection bool `protobuf:"varint,7,opt,name=disable_best_path_selection,json=disableBestPathSelection,proto3" json:"disable_best_path_selection,omitempty"`
}

func (m *RouteSelectionOptionsConfig) Reset()         { *m = RouteSelectionOptionsConfig{} }
func (m *RouteSelectionOptionsConfig) String() string { return proto.CompactTextString(m) }
func (*RouteSelectionOptionsConfig) ProtoMessage()    {}
func (*RouteSelectionOptionsConfig) Descriptor() ([]byte, []int) {
	return fileDescriptorGobgp, []int{142}
}

func (m *RouteSelectionOptionsConfig) GetAlwaysCompareMed() bool {
	if m != nil {
		return m.AlwaysCompareMed
	}
	return false
}

func (m *RouteSelectionOptionsConfig) GetIgnoreAsPathLength() bool {
	if m != nil {
		return m.IgnoreAsPathLength
	}
	return false
}

func (m *RouteSelectionOptionsConfig) GetExternalCompareRouterId() bool {
	if m != nil {
		return m.ExternalCompareRouterId
	}
	return false
}

func (m *RouteSelectionOptionsConfig) GetAdvertiseInactiveRoutes() bool {
	if m != nil {
		return m.AdvertiseInactiveRoutes
	}
	return false
}

func (m *RouteSelectionOptionsConfig) GetEnableAigp() bool {
	if m != nil {
		return m.EnableAigp
	}
	return false
}

func (m *RouteSelectionOptionsConfig) GetIgnoreNextHopIgpMetric() bool {
	if m != nil {
		return m.IgnoreNextHopIgpMetric
	}
	return false
}

func (m *RouteSelectionOptionsConfig) GetDisableBestPathSelection() bool {
	if m != nil {
		return m.DisableBestPathSelection
	}
	return false
}

type RouteSelectionOptionsState struct {
	AlwaysCompareMed         bool `protobuf:"varint,1,opt,name=always_compare_med,json=alwaysCompareMed,proto3" json:"always_compare_med,omitempty"`
	IgnoreAsPathLength       bool `protobuf:"varint,2,opt,name=ignore_as_path_length,json=ignoreAsPathLength,proto3" json:"ignore_as_path_length,omitempty"`
	ExternalCompareRouterId  bool `protobuf:"varint,3,opt,name=external_compare_router_id,json=externalCompareRouterId,proto3" json:"external_compare_router_id,omitempty"`
	AdvertiseInactiveRoutes  bool `protobuf:"varint,4,opt,name=advertise_inactive_routes,json=advertiseInactiveRoutes,proto3" json:"advertise_inactive_routes,omitempty"`
	EnableAigp               bool `protobuf:"varint,5,opt,name=enable_aigp,json=enableAigp,proto3" json:"enable_aigp,omitempty"`
	IgnoreNextHopIgpMetric   bool `protobuf:"varint,6,opt,name=ignore_next_hop_igp_metric,json=ignoreNextHopIgpMetric,proto3" json:"ignore_next_hop_igp_metric,omitempty"`
	DisableBestPathSelection bool `protobuf:"varint,7,opt,name=disable_best_path_selection,json=disableBestPathSelection,proto3" json:"disable_best_path_selection,omitempty"`
}

func (m *RouteSelectionOptionsState) Reset()         { *m = RouteSelectionOptionsState{} }
func (m *RouteSelectionOptionsState) String() string { return proto.CompactTextString(m) }
func (*RouteSelectionOptionsState) ProtoMessage()    {}
func (*RouteSelectionOptionsState) Descriptor() ([]byte, []int) {
	return fileDescriptorGobgp, []int{143}
}

func (m *RouteSelectionOptionsState) GetAlwaysCompareMed() bool {
	if m != nil {
		return m.AlwaysCompareMed
	}
	return false
}

func (m *RouteSelectionOptionsState) GetIgnoreAsPathLength() bool {
	if m != nil {
		return m.IgnoreAsPathLength
	}
	return false
}

func (m *RouteSelectionOptionsState) GetExternalCompareRouterId() bool {
	if m != nil {
		return m.ExternalCompareRouterId
	}
	return false
}

func (m *RouteSelectionOptionsState) GetAdvertiseInactiveRoutes() bool {
	if m != nil {
		return m.AdvertiseInactiveRoutes
	}
	return false
}

func (m *RouteSelectionOptionsState) GetEnableAigp() bool {
	if m != nil {
		return m.EnableAigp
	}
	return false
}

func (m *RouteSelectionOptionsState) GetIgnoreNextHopIgpMetric() bool {
	if m != nil {
		return m.IgnoreNextHopIgpMetric
	}
	return false
}

func (m *RouteSelectionOptionsState) GetDisableBestPathSelection() bool {
	if m != nil {
		return m.DisableBestPathSelection
	}
	return false
}

type RouteSelectionOptions struct {
	Config *RouteSelectionOptionsConfig `protobuf:"bytes,1,opt,name=config" json:"config,omitempty"`
	State  *RouteSelectionOptionsState  `protobuf:"bytes,2,opt,name=state" json:"state,omitempty"`
}

func (m *RouteSelectionOptions) Reset()                    { *m = RouteSelectionOptions{} }
func (m *RouteSelectionOptions) String() string            { return proto.CompactTextString(m) }
func (*RouteSelectionOptions) ProtoMessage()               {}
func (*RouteSelectionOptions) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{144} }

func (m *RouteSelectionOptions) GetConfig() *RouteSelectionOptionsConfig {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *RouteSelectionOptions) GetState() *RouteSelectionOptionsState {
	if m != nil {
		return m.State
	}
	return nil
}

type UseMultiplePathsConfig struct {
	Enabled bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
}

func (m *UseMultiplePathsConfig) Reset()                    { *m = UseMultiplePathsConfig{} }
func (m *UseMultiplePathsConfig) String() string            { return proto.CompactTextString(m) }
func (*UseMultiplePathsConfig) ProtoMessage()               {}
func (*UseMultiplePathsConfig) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{145} }

func (m *UseMultiplePathsConfig) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

type UseMultiplePathsState struct {
	Enabled bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
}

func (m *UseMultiplePathsState) Reset()                    { *m = UseMultiplePathsState{} }
func (m *UseMultiplePathsState) String() string            { return proto.CompactTextString(m) }
func (*UseMultiplePathsState) ProtoMessage()               {}
func (*UseMultiplePathsState) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{146} }

func (m *UseMultiplePathsState) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

type EbgpConfig struct {
	AllowMultipleAs bool   `protobuf:"varint,1,opt,name=allow_multiple_as,json=allowMultipleAs,proto3" json:"allow_multiple_as,omitempty"`
	MaximumPaths    uint32 `protobuf:"varint,2,opt,name=maximum_paths,json=maximumPaths,proto3" json:"maximum_paths,omitempty"`
}

func (m *EbgpConfig) Reset()                    { *m = EbgpConfig{} }
func (m *EbgpConfig) String() string            { return proto.CompactTextString(m) }
func (*EbgpConfig) ProtoMessage()               {}
func (*EbgpConfig) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{147} }

func (m *EbgpConfig) GetAllowMultipleAs() bool {
	if m != nil {
		return m.AllowMultipleAs
	}
	return false
}

func (m *EbgpConfig) GetMaximumPaths() uint32 {
	if m != nil {
		return m.MaximumPaths
	}
	return 0
}

type EbgpState struct {
	AllowMultipleAs bool   `protobuf:"varint,1,opt,name=allow_multiple_as,json=allowMultipleAs,proto3" json:"allow_multiple_as,omitempty"`
	MaximumPaths    uint32 `protobuf:"varint,2,opt,name=maximum_paths,json=maximumPaths,proto3" json:"maximum_paths,omitempty"`
}

func (m *EbgpState) Reset()                    { *m = EbgpState{} }
func (m *EbgpState) String() string            { return proto.CompactTextString(m) }
func (*EbgpState) ProtoMessage()               {}
func (*EbgpState) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{148} }

func (m *EbgpState) GetAllowMultipleAs() bool {
	if m != nil {
		return m.AllowMultipleAs
	}
	return false
}

func (m *EbgpState) GetMaximumPaths() uint32 {
	if m != nil {
		return m.MaximumPaths
	}
	return 0
}

type Ebgp struct {
	Config *EbgpConfig `protobuf:"bytes,1,opt,name=config" json:"config,omitempty"`
	State  *EbgpState  `protobuf:"bytes,2,opt,name=state" json:"state,omitempty"`
}

func (m *Ebgp) Reset()                    { *m = Ebgp{} }
func (m *Ebgp) String() string            { return proto.CompactTextString(m) }
func (*Ebgp) ProtoMessage()               {}
func (*Ebgp) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{149} }

func (m *Ebgp) GetConfig() *EbgpConfig {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *Ebgp) GetState() *EbgpState {
	if m != nil {
		return m.State
	}
	return nil
}

type IbgpConfig struct {
	MaximumPaths uint32 `protobuf:"varint,1,opt,name=maximum_paths,json=maximumPaths,proto3" json:"maximum_paths,omitempty"`
}

func (m *IbgpConfig) Reset()                    { *m = IbgpConfig{} }
func (m *IbgpConfig) String() string            { return proto.CompactTextString(m) }
func (*IbgpConfig) ProtoMessage()               {}
func (*IbgpConfig) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{150} }

func (m *IbgpConfig) GetMaximumPaths() uint32 {
	if m != nil {
		return m.MaximumPaths
	}
	return 0
}

type IbgpState struct {
	MaximumPaths uint32 `protobuf:"varint,1,opt,name=maximum_paths,json=maximumPaths,proto3" json:"maximum_paths,omitempty"`
}

func (m *IbgpState) Reset()                    { *m = IbgpState{} }
func (m *IbgpState) String() string            { return proto.CompactTextString(m) }
func (*IbgpState) ProtoMessage()               {}
func (*IbgpState) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{151} }

func (m *IbgpState) GetMaximumPaths() uint32 {
	if m != nil {
		return m.MaximumPaths
	}
	return 0
}

type Ibgp struct {
	Config *IbgpConfig `protobuf:"bytes,1,opt,name=config" json:"config,omitempty"`
	State  *IbgpState  `protobuf:"bytes,2,opt,name=state" json:"state,omitempty"`
}

func (m *Ibgp) Reset()                    { *m = Ibgp{} }
func (m *Ibgp) String() string            { return proto.CompactTextString(m) }
func (*Ibgp) ProtoMessage()               {}
func (*Ibgp) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{152} }

func (m *Ibgp) GetConfig() *IbgpConfig {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *Ibgp) GetState() *IbgpState {
	if m != nil {
		return m.State
	}
	return nil
}

type UseMultiplePaths struct {
	Config *UseMultiplePathsConfig `protobuf:"bytes,1,opt,name=config" json:"config,omitempty"`
	State  *UseMultiplePathsState  `protobuf:"bytes,2,opt,name=state" json:"state,omitempty"`
	Ebgp   *Ebgp                   `protobuf:"bytes,3,opt,name=ebgp" json:"ebgp,omitempty"`
	Ibgp   *Ibgp                   `protobuf:"bytes,4,opt,name=ibgp" json:"ibgp,omitempty"`
}

func (m *UseMultiplePaths) Reset()                    { *m = UseMultiplePaths{} }
func (m *UseMultiplePaths) String() string            { return proto.CompactTextString(m) }
func (*UseMultiplePaths) ProtoMessage()               {}
func (*UseMultiplePaths) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{153} }

func (m *UseMultiplePaths) GetConfig() *UseMultiplePathsConfig {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *UseMultiplePaths) GetState() *UseMultiplePathsState {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *UseMultiplePaths) GetEbgp() *Ebgp {
	if m != nil {
		return m.Ebgp
	}
	return nil
}

func (m *UseMultiplePaths) GetIbgp() *Ibgp {
	if m != nil {
		return m.Ibgp
	}
	return nil
}

type RouteTargetMembershipConfig struct {
	DeferralTime uint32 `protobuf:"varint,1,opt,name=deferral_time,json=deferralTime,proto3" json:"deferral_time,omitempty"`
}

func (m *RouteTargetMembershipConfig) Reset()         { *m = RouteTargetMembershipConfig{} }
func (m *RouteTargetMembershipConfig) String() string { return proto.CompactTextString(m) }
func (*RouteTargetMembershipConfig) ProtoMessage()    {}
func (*RouteTargetMembershipConfig) Descriptor() ([]byte, []int) {
	return fileDescriptorGobgp, []int{154}
}

func (m *RouteTargetMembershipConfig) GetDeferralTime() uint32 {
	if m != nil {
		return m.DeferralTime
	}
	return 0
}

type RouteTargetMembershipState struct {
	DeferralTime uint32 `protobuf:"varint,1,opt,name=deferral_time,json=deferralTime,proto3" json:"deferral_time,omitempty"`
}

func (m *RouteTargetMembershipState) Reset()         { *m = RouteTargetMembershipState{} }
func (m *RouteTargetMembershipState) String() string { return proto.CompactTextString(m) }
func (*RouteTargetMembershipState) ProtoMessage()    {}
func (*RouteTargetMembershipState) Descriptor() ([]byte, []int) {
	return fileDescriptorGobgp, []int{155}
}

func (m *RouteTargetMembershipState) GetDeferralTime() uint32 {
	if m != nil {
		return m.DeferralTime
	}
	return 0
}

type RouteTargetMembership struct {
	Config *RouteTargetMembershipConfig `protobuf:"bytes,1,opt,name=config" json:"config,omitempty"`
	State  *RouteTargetMembershipState  `protobuf:"bytes,2,opt,name=state" json:"state,omitempty"`
}

func (m *RouteTargetMembership) Reset()                    { *m = RouteTargetMembership{} }
func (m *RouteTargetMembership) String() string            { return proto.CompactTextString(m) }
func (*RouteTargetMembership) ProtoMessage()               {}
func (*RouteTargetMembership) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{156} }

func (m *RouteTargetMembership) GetConfig() *RouteTargetMembershipConfig {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *RouteTargetMembership) GetState() *RouteTargetMembershipState {
	if m != nil {
		return m.State
	}
	return nil
}

type LongLivedGracefulRestartConfig struct {
	Enabled     bool   `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	RestartTime uint32 `protobuf:"varint,2,opt,name=restart_time,json=restartTime,proto3" json:"restart_time,omitempty"`
}

func (m *LongLivedGracefulRestartConfig) Reset()         { *m = LongLivedGracefulRestartConfig{} }
func (m *LongLivedGracefulRestartConfig) String() string { return proto.CompactTextString(m) }
func (*LongLivedGracefulRestartConfig) ProtoMessage()    {}
func (*LongLivedGracefulRestartConfig) Descriptor() ([]byte, []int) {
	return fileDescriptorGobgp, []int{157}
}

func (m *LongLivedGracefulRestartConfig) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *LongLivedGracefulRestartConfig) GetRestartTime() uint32 {
	if m != nil {
		return m.RestartTime
	}
	return 0
}

type LongLivedGracefulRestartState struct {
	Enabled                 bool   `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	Received                bool   `protobuf:"varint,2,opt,name=received,proto3" json:"received,omitempty"`
	Advertised              bool   `protobuf:"varint,3,opt,name=advertised,proto3" json:"advertised,omitempty"`
	PeerRestartTime         uint32 `protobuf:"varint,4,opt,name=peer_restart_time,json=peerRestartTime,proto3" json:"peer_restart_time,omitempty"`
	PeerRestartTimerExpired bool   `protobuf:"varint,5,opt,name=peer_restart_timer_expired,json=peerRestartTimerExpired,proto3" json:"peer_restart_timer_expired,omitempty"`
}

func (m *LongLivedGracefulRestartState) Reset()         { *m = LongLivedGracefulRestartState{} }
func (m *LongLivedGracefulRestartState) String() string { return proto.CompactTextString(m) }
func (*LongLivedGracefulRestartState) ProtoMessage()    {}
func (*LongLivedGracefulRestartState) Descriptor() ([]byte, []int) {
	return fileDescriptorGobgp, []int{158}
}

func (m *LongLivedGracefulRestartState) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *LongLivedGracefulRestartState) GetReceived() bool {
	if m != nil {
		return m.Received
	}
	return false
}

func (m *LongLivedGracefulRestartState) GetAdvertised() bool {
	if m != nil {
		return m.Advertised
	}
	return false
}

func (m *LongLivedGracefulRestartState) GetPeerRestartTime() uint32 {
	if m != nil {
		return m.PeerRestartTime
	}
	return 0
}

func (m *LongLivedGracefulRestartState) GetPeerRestartTimerExpired() bool {
	if m != nil {
		return m.PeerRestartTimerExpired
	}
	return false
}

type LongLivedGracefulRestart struct {
	Config *LongLivedGracefulRestartConfig `protobuf:"bytes,1,opt,name=config" json:"config,omitempty"`
	State  *LongLivedGracefulRestartState  `protobuf:"bytes,2,opt,name=state" json:"state,omitempty"`
}

func (m *LongLivedGracefulRestart) Reset()                    { *m = LongLivedGracefulRestart{} }
func (m *LongLivedGracefulRestart) String() string            { return proto.CompactTextString(m) }
func (*LongLivedGracefulRestart) ProtoMessage()               {}
func (*LongLivedGracefulRestart) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{159} }

func (m *LongLivedGracefulRestart) GetConfig() *LongLivedGracefulRestartConfig {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *LongLivedGracefulRestart) GetState() *LongLivedGracefulRestartState {
	if m != nil {
		return m.State
	}
	return nil
}

type AfiSafi struct {
	MpGracefulRestart *MpGracefulRestart `protobuf:"bytes,1,opt,name=mp_graceful_restart,json=mpGracefulRestart" json:"mp_graceful_restart,omitempty"`
	Config            *AfiSafiConfig     `protobuf:"bytes,2,opt,name=config" json:"config,omitempty"`
	ApplyPolicy       *ApplyPolicy       `protobuf:"bytes,3,opt,name=apply_policy,json=applyPolicy" json:"apply_policy,omitempty"`
	// TODO:
	// Support the following structures:
	// - Ipv4Unicast
	// - Ipv6Unicast
	// - Ipv4LabelledUnicast
	// - Ipv6LabelledUnicast
	// - L3vpnIpv4Unicast
	// - L3vpnIpv6Unicast
	// - L3vpnIpv4Multicast
	// - L3vpnIpv6Multicast
	// - L2vpnVpls
	// - L2vpnEvpn
	RouteSelectionOptions    *RouteSelectionOptions    `protobuf:"bytes,4,opt,name=route_selection_options,json=routeSelectionOptions" json:"route_selection_options,omitempty"`
	UseMultiplePaths         *UseMultiplePaths         `protobuf:"bytes,5,opt,name=use_multiple_paths,json=useMultiplePaths" json:"use_multiple_paths,omitempty"`
	PrefixLimits             *PrefixLimit              `protobuf:"bytes,6,opt,name=prefix_limits,json=prefixLimits" json:"prefix_limits,omitempty"`
	RouteTargetMembership    *RouteTargetMembership    `protobuf:"bytes,7,opt,name=route_target_membership,json=routeTargetMembership" json:"route_target_membership,omitempty"`
	LongLivedGracefulRestart *LongLivedGracefulRestart `protobuf:"bytes,8,opt,name=long_lived_graceful_restart,json=longLivedGracefulRestart" json:"long_lived_graceful_restart,omitempty"`
	AddPaths                 *AddPaths                 `protobuf:"bytes,9,opt,name=add_paths,json=addPaths" json:"add_paths,omitempty"`
}

func (m *AfiSafi) Reset()                    { *m = AfiSafi{} }
func (m *AfiSafi) String() string            { return proto.CompactTextString(m) }
func (*AfiSafi) ProtoMessage()               {}
func (*AfiSafi) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{160} }

func (m *AfiSafi) GetMpGracefulRestart() *MpGracefulRestart {
	if m != nil {
		return m.MpGracefulRestart
	}
	return nil
}

func (m *AfiSafi) GetConfig() *AfiSafiConfig {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *AfiSafi) GetApplyPolicy() *ApplyPolicy {
	if m != nil {
		return m.ApplyPolicy
	}
	return nil
}

func (m *AfiSafi) GetRouteSelectionOptions() *RouteSelectionOptions {
	if m != nil {
		return m.RouteSelectionOptions
	}
	return nil
}

func (m *AfiSafi) GetUseMultiplePaths() *UseMultiplePaths {
	if m != nil {
		return m.UseMultiplePaths
	}
	return nil
}

func (m *AfiSafi) GetPrefixLimits() *PrefixLimit {
	if m != nil {
		return m.PrefixLimits
	}
	return nil
}

func (m *AfiSafi) GetRouteTargetMembership() *RouteTargetMembership {
	if m != nil {
		return m.RouteTargetMembership
	}
	return nil
}

func (m *AfiSafi) GetLongLivedGracefulRestart() *LongLivedGracefulRestart {
	if m != nil {
		return m.LongLivedGracefulRestart
	}
	return nil
}

func (m *AfiSafi) GetAddPaths() *AddPaths {
	if m != nil {
		return m.AddPaths
	}
	return nil
}

type AddPathsConfig struct {
	Receive bool   `protobuf:"varint,1,opt,name=receive,proto3" json:"receive,omitempty"`
	SendMax uint32 `protobuf:"varint,2,opt,name=send_max,json=sendMax,proto3" json:"send_max,omitempty"`
}

func (m *AddPathsConfig) Reset()                    { *m = AddPathsConfig{} }
func (m *AddPathsConfig) String() string            { return proto.CompactTextString(m) }
func (*AddPathsConfig) ProtoMessage()               {}
func (*AddPathsConfig) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{161} }

func (m *AddPathsConfig) GetReceive() bool {
	if m != nil {
		return m.Receive
	}
	return false
}

func (m *AddPathsConfig) GetSendMax() uint32 {
	if m != nil {
		return m.SendMax
	}
	return 0
}

type AddPathsState struct {
	Receive bool   `protobuf:"varint,1,opt,name=receive,proto3" json:"receive,omitempty"`
	SendMax uint32 `protobuf:"varint,2,opt,name=send_max,json=sendMax,proto3" json:"send_max,omitempty"`
}

func (m *AddPathsState) Reset()                    { *m = AddPathsState{} }
func (m *AddPathsState) String() string            { return proto.CompactTextString(m) }
func (*AddPathsState) ProtoMessage()               {}
func (*AddPathsState) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{162} }

func (m *AddPathsState) GetReceive() bool {
	if m != nil {
		return m.Receive
	}
	return false
}

func (m *AddPathsState) GetSendMax() uint32 {
	if m != nil {
		return m.SendMax
	}
	return 0
}

type AddPaths struct {
	Config *AddPathsConfig `protobuf:"bytes,1,opt,name=config" json:"config,omitempty"`
	State  *AddPathsState  `protobuf:"bytes,2,opt,name=state" json:"state,omitempty"`
}

func (m *AddPaths) Reset()                    { *m = AddPaths{} }
func (m *AddPaths) String() string            { return proto.CompactTextString(m) }
func (*AddPaths) ProtoMessage()               {}
func (*AddPaths) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{163} }

func (m *AddPaths) GetConfig() *AddPathsConfig {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *AddPaths) GetState() *AddPathsState {
	if m != nil {
		return m.State
	}
	return nil
}

type Prefix struct {
	IpPrefix      string `protobuf:"bytes,1,opt,name=ip_prefix,json=ipPrefix,proto3" json:"ip_prefix,omitempty"`
	MaskLengthMin uint32 `protobuf:"varint,2,opt,name=mask_length_min,json=maskLengthMin,proto3" json:"mask_length_min,omitempty"`
	MaskLengthMax uint32 `protobuf:"varint,3,opt,name=mask_length_max,json=maskLengthMax,proto3" json:"mask_length_max,omitempty"`
}

func (m *Prefix) Reset()                    { *m = Prefix{} }
func (m *Prefix) String() string            { return proto.CompactTextString(m) }
func (*Prefix) ProtoMessage()               {}
func (*Prefix) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{164} }

func (m *Prefix) GetIpPrefix() string {
	if m != nil {
		return m.IpPrefix
	}
	return ""
}

func (m *Prefix) GetMaskLengthMin() uint32 {
	if m != nil {
		return m.MaskLengthMin
	}
	return 0
}

func (m *Prefix) GetMaskLengthMax() uint32 {
	if m != nil {
		return m.MaskLengthMax
	}
	return 0
}

type DefinedSet struct {
	Type     DefinedType `protobuf:"varint,1,opt,name=type,proto3,enum=gobgpapi.DefinedType" json:"type,omitempty"`
	Name     string      `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	List     []string    `protobuf:"bytes,3,rep,name=list" json:"list,omitempty"`
	Prefixes []*Prefix   `protobuf:"bytes,4,rep,name=prefixes" json:"prefixes,omitempty"`
}

func (m *DefinedSet) Reset()                    { *m = DefinedSet{} }
func (m *DefinedSet) String() string            { return proto.CompactTextString(m) }
func (*DefinedSet) ProtoMessage()               {}
func (*DefinedSet) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{165} }

func (m *DefinedSet) GetType() DefinedType {
	if m != nil {
		return m.Type
	}
	return DefinedType_PREFIX
}

func (m *DefinedSet) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DefinedSet) GetList() []string {
	if m != nil {
		return m.List
	}
	return nil
}

func (m *DefinedSet) GetPrefixes() []*Prefix {
	if m != nil {
		return m.Prefixes
	}
	return nil
}

type MatchSet struct {
	Type MatchType `protobuf:"varint,1,opt,name=type,proto3,enum=gobgpapi.MatchType" json:"type,omitempty"`
	Name string    `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *MatchSet) Reset()                    { *m = MatchSet{} }
func (m *MatchSet) String() string            { return proto.CompactTextString(m) }
func (*MatchSet) ProtoMessage()               {}
func (*MatchSet) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{166} }

func (m *MatchSet) GetType() MatchType {
	if m != nil {
		return m.Type
	}
	return MatchType_ANY
}

func (m *MatchSet) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type AsPathLength struct {
	Type   AsPathLengthType `protobuf:"varint,1,opt,name=type,proto3,enum=gobgpapi.AsPathLengthType" json:"type,omitempty"`
	Length uint32           `protobuf:"varint,2,opt,name=length,proto3" json:"length,omitempty"`
}

func (m *AsPathLength) Reset()                    { *m = AsPathLength{} }
func (m *AsPathLength) String() string            { return proto.CompactTextString(m) }
func (*AsPathLength) ProtoMessage()               {}
func (*AsPathLength) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{167} }

func (m *AsPathLength) GetType() AsPathLengthType {
	if m != nil {
		return m.Type
	}
	return AsPathLengthType_EQ
}

func (m *AsPathLength) GetLength() uint32 {
	if m != nil {
		return m.Length
	}
	return 0
}

type Conditions struct {
	PrefixSet         *MatchSet            `protobuf:"bytes,1,opt,name=prefix_set,json=prefixSet" json:"prefix_set,omitempty"`
	NeighborSet       *MatchSet            `protobuf:"bytes,2,opt,name=neighbor_set,json=neighborSet" json:"neighbor_set,omitempty"`
	AsPathLength      *AsPathLength        `protobuf:"bytes,3,opt,name=as_path_length,json=asPathLength" json:"as_path_length,omitempty"`
	AsPathSet         *MatchSet            `protobuf:"bytes,4,opt,name=as_path_set,json=asPathSet" json:"as_path_set,omitempty"`
	CommunitySet      *MatchSet            `protobuf:"bytes,5,opt,name=community_set,json=communitySet" json:"community_set,omitempty"`
	ExtCommunitySet   *MatchSet            `protobuf:"bytes,6,opt,name=ext_community_set,json=extCommunitySet" json:"ext_community_set,omitempty"`
	RpkiResult        int32                `protobuf:"varint,7,opt,name=rpki_result,json=rpkiResult,proto3" json:"rpki_result,omitempty"`
	RouteType         Conditions_RouteType `protobuf:"varint,8,opt,name=route_type,json=routeType,proto3,enum=gobgpapi.Conditions_RouteType" json:"route_type,omitempty"`
	LargeCommunitySet *MatchSet            `protobuf:"bytes,9,opt,name=large_community_set,json=largeCommunitySet" json:"large_community_set,omitempty"`
	NextHopInList     []string             `protobuf:"bytes,10,rep,name=next_hop_in_list,json=nextHopInList" json:"next_hop_in_list,omitempty"`
}

func (m *Conditions) Reset()                    { *m = Conditions{} }
func (m *Conditions) String() string            { return proto.CompactTextString(m) }
func (*Conditions) ProtoMessage()               {}
func (*Conditions) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{168} }

func (m *Conditions) GetPrefixSet() *MatchSet {
	if m != nil {
		return m.PrefixSet
	}
	return nil
}

func (m *Conditions) GetNeighborSet() *MatchSet {
	if m != nil {
		return m.NeighborSet
	}
	return nil
}

func (m *Conditions) GetAsPathLength() *AsPathLength {
	if m != nil {
		return m.AsPathLength
	}
	return nil
}

func (m *Conditions) GetAsPathSet() *MatchSet {
	if m != nil {
		return m.AsPathSet
	}
	return nil
}

func (m *Conditions) GetCommunitySet() *MatchSet {
	if m != nil {
		return m.CommunitySet
	}
	return nil
}

func (m *Conditions) GetExtCommunitySet() *MatchSet {
	if m != nil {
		return m.ExtCommunitySet
	}
	return nil
}

func (m *Conditions) GetRpkiResult() int32 {
	if m != nil {
		return m.RpkiResult
	}
	return 0
}

func (m *Conditions) GetRouteType() Conditions_RouteType {
	if m != nil {
		return m.RouteType
	}
	return Conditions_ROUTE_TYPE_NONE
}

func (m *Conditions) GetLargeCommunitySet() *MatchSet {
	if m != nil {
		return m.LargeCommunitySet
	}
	return nil
}

func (m *Conditions) GetNextHopInList() []string {
	if m != nil {
		return m.NextHopInList
	}
	return nil
}

type CommunityAction struct {
	Type        CommunityActionType `protobuf:"varint,1,opt,name=type,proto3,enum=gobgpapi.CommunityActionType" json:"type,omitempty"`
	Communities []string            `protobuf:"bytes,2,rep,name=communities" json:"communities,omitempty"`
}

func (m *CommunityAction) Reset()                    { *m = CommunityAction{} }
func (m *CommunityAction) String() string            { return proto.CompactTextString(m) }
func (*CommunityAction) ProtoMessage()               {}
func (*CommunityAction) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{169} }

func (m *CommunityAction) GetType() CommunityActionType {
	if m != nil {
		return m.Type
	}
	return CommunityActionType_COMMUNITY_ADD
}

func (m *CommunityAction) GetCommunities() []string {
	if m != nil {
		return m.Communities
	}
	return nil
}

type MedAction struct {
	Type  MedActionType `protobuf:"varint,1,opt,name=type,proto3,enum=gobgpapi.MedActionType" json:"type,omitempty"`
	Value int64         `protobuf:"varint,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *MedAction) Reset()                    { *m = MedAction{} }
func (m *MedAction) String() string            { return proto.CompactTextString(m) }
func (*MedAction) ProtoMessage()               {}
func (*MedAction) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{170} }

func (m *MedAction) GetType() MedActionType {
	if m != nil {
		return m.Type
	}
	return MedActionType_MED_MOD
}

func (m *MedAction) GetValue() int64 {
	if m != nil {
		return m.Value
	}
	return 0
}

type AsPrependAction struct {
	Asn         uint32 `protobuf:"varint,1,opt,name=asn,proto3" json:"asn,omitempty"`
	Repeat      uint32 `protobuf:"varint,2,opt,name=repeat,proto3" json:"repeat,omitempty"`
	UseLeftMost bool   `protobuf:"varint,3,opt,name=use_left_most,json=useLeftMost,proto3" json:"use_left_most,omitempty"`
}

func (m *AsPrependAction) Reset()                    { *m = AsPrependAction{} }
func (m *AsPrependAction) String() string            { return proto.CompactTextString(m) }
func (*AsPrependAction) ProtoMessage()               {}
func (*AsPrependAction) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{171} }

func (m *AsPrependAction) GetAsn() uint32 {
	if m != nil {
		return m.Asn
	}
	return 0
}

func (m *AsPrependAction) GetRepeat() uint32 {
	if m != nil {
		return m.Repeat
	}
	return 0
}

func (m *AsPrependAction) GetUseLeftMost() bool {
	if m != nil {
		return m.UseLeftMost
	}
	return false
}

type NexthopAction struct {
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Self    bool   `protobuf:"varint,2,opt,name=self,proto3" json:"self,omitempty"`
}

func (m *NexthopAction) Reset()                    { *m = NexthopAction{} }
func (m *NexthopAction) String() string            { return proto.CompactTextString(m) }
func (*NexthopAction) ProtoMessage()               {}
func (*NexthopAction) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{172} }

func (m *NexthopAction) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *NexthopAction) GetSelf() bool {
	if m != nil {
		return m.Self
	}
	return false
}

type LocalPrefAction struct {
	Value uint32 `protobuf:"varint,1,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *LocalPrefAction) Reset()                    { *m = LocalPrefAction{} }
func (m *LocalPrefAction) String() string            { return proto.CompactTextString(m) }
func (*LocalPrefAction) ProtoMessage()               {}
func (*LocalPrefAction) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{173} }

func (m *LocalPrefAction) GetValue() uint32 {
	if m != nil {
		return m.Value
	}
	return 0
}

type Actions struct {
	RouteAction    RouteAction      `protobuf:"varint,1,opt,name=route_action,json=routeAction,proto3,enum=gobgpapi.RouteAction" json:"route_action,omitempty"`
	Community      *CommunityAction `protobuf:"bytes,2,opt,name=community" json:"community,omitempty"`
	Med            *MedAction       `protobuf:"bytes,3,opt,name=med" json:"med,omitempty"`
	AsPrepend      *AsPrependAction `protobuf:"bytes,4,opt,name=as_prepend,json=asPrepend" json:"as_prepend,omitempty"`
	ExtCommunity   *CommunityAction `protobuf:"bytes,5,opt,name=ext_community,json=extCommunity" json:"ext_community,omitempty"`
	Nexthop        *NexthopAction   `protobuf:"bytes,6,opt,name=nexthop" json:"nexthop,omitempty"`
	LocalPref      *LocalPrefAction `protobuf:"bytes,7,opt,name=local_pref,json=localPref" json:"local_pref,omitempty"`
	LargeCommunity *CommunityAction `protobuf:"bytes,8,opt,name=large_community,json=largeCommunity" json:"large_community,omitempty"`
}

func (m *Actions) Reset()                    { *m = Actions{} }
func (m *Actions) String() string            { return proto.CompactTextString(m) }
func (*Actions) ProtoMessage()               {}
func (*Actions) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{174} }

func (m *Actions) GetRouteAction() RouteAction {
	if m != nil {
		return m.RouteAction
	}
	return RouteAction_NONE
}

func (m *Actions) GetCommunity() *CommunityAction {
	if m != nil {
		return m.Community
	}
	return nil
}

func (m *Actions) GetMed() *MedAction {
	if m != nil {
		return m.Med
	}
	return nil
}

func (m *Actions) GetAsPrepend() *AsPrependAction {
	if m != nil {
		return m.AsPrepend
	}
	return nil
}

func (m *Actions) GetExtCommunity() *CommunityAction {
	if m != nil {
		return m.ExtCommunity
	}
	return nil
}

func (m *Actions) GetNexthop() *NexthopAction {
	if m != nil {
		return m.Nexthop
	}
	return nil
}

func (m *Actions) GetLocalPref() *LocalPrefAction {
	if m != nil {
		return m.LocalPref
	}
	return nil
}

func (m *Actions) GetLargeCommunity() *CommunityAction {
	if m != nil {
		return m.LargeCommunity
	}
	return nil
}

type Statement struct {
	Name       string      `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Conditions *Conditions `protobuf:"bytes,2,opt,name=conditions" json:"conditions,omitempty"`
	Actions    *Actions    `protobuf:"bytes,3,opt,name=actions" json:"actions,omitempty"`
}

func (m *Statement) Reset()                    { *m = Statement{} }
func (m *Statement) String() string            { return proto.CompactTextString(m) }
func (*Statement) ProtoMessage()               {}
func (*Statement) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{175} }

func (m *Statement) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Statement) GetConditions() *Conditions {
	if m != nil {
		return m.Conditions
	}
	return nil
}

func (m *Statement) GetActions() *Actions {
	if m != nil {
		return m.Actions
	}
	return nil
}

type Policy struct {
	Name       string       `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Statements []*Statement `protobuf:"bytes,2,rep,name=statements" json:"statements,omitempty"`
}

func (m *Policy) Reset()                    { *m = Policy{} }
func (m *Policy) String() string            { return proto.CompactTextString(m) }
func (*Policy) ProtoMessage()               {}
func (*Policy) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{176} }

func (m *Policy) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Policy) GetStatements() []*Statement {
	if m != nil {
		return m.Statements
	}
	return nil
}

type PolicyAssignment struct {
	Type     PolicyType  `protobuf:"varint,1,opt,name=type,proto3,enum=gobgpapi.PolicyType" json:"type,omitempty"`
	Resource Resource    `protobuf:"varint,2,opt,name=resource,proto3,enum=gobgpapi.Resource" json:"resource,omitempty"`
	Name     string      `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Policies []*Policy   `protobuf:"bytes,4,rep,name=policies" json:"policies,omitempty"`
	Default  RouteAction `protobuf:"varint,5,opt,name=default,proto3,enum=gobgpapi.RouteAction" json:"default,omitempty"`
}

func (m *PolicyAssignment) Reset()                    { *m = PolicyAssignment{} }
func (m *PolicyAssignment) String() string            { return proto.CompactTextString(m) }
func (*PolicyAssignment) ProtoMessage()               {}
func (*PolicyAssignment) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{177} }

func (m *PolicyAssignment) GetType() PolicyType {
	if m != nil {
		return m.Type
	}
	return PolicyType_IN
}

func (m *PolicyAssignment) GetResource() Resource {
	if m != nil {
		return m.Resource
	}
	return Resource_GLOBAL
}

func (m *PolicyAssignment) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PolicyAssignment) GetPolicies() []*Policy {
	if m != nil {
		return m.Policies
	}
	return nil
}

func (m *PolicyAssignment) GetDefault() RouteAction {
	if m != nil {
		return m.Default
	}
	return RouteAction_NONE
}

type RoutingPolicy struct {
	DefinedSet       []*DefinedSet `protobuf:"bytes,1,rep,name=defined_set,json=definedSet" json:"defined_set,omitempty"`
	PolicyDefinition []*Policy     `protobuf:"bytes,2,rep,name=policy_definition,json=policyDefinition" json:"policy_definition,omitempty"`
}

func (m *RoutingPolicy) Reset()                    { *m = RoutingPolicy{} }
func (m *RoutingPolicy) String() string            { return proto.CompactTextString(m) }
func (*RoutingPolicy) ProtoMessage()               {}
func (*RoutingPolicy) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{178} }

func (m *RoutingPolicy) GetDefinedSet() []*DefinedSet {
	if m != nil {
		return m.DefinedSet
	}
	return nil
}

func (m *RoutingPolicy) GetPolicyDefinition() []*Policy {
	if m != nil {
		return m.PolicyDefinition
	}
	return nil
}

type Roa struct {
	As        uint32    `protobuf:"varint,1,opt,name=as,proto3" json:"as,omitempty"`
	Prefixlen uint32    `protobuf:"varint,2,opt,name=prefixlen,proto3" json:"prefixlen,omitempty"`
	Maxlen    uint32    `protobuf:"varint,3,opt,name=maxlen,proto3" json:"maxlen,omitempty"`
	Prefix    string    `protobuf:"bytes,4,opt,name=prefix,proto3" json:"prefix,omitempty"`
	Conf      *RPKIConf `protobuf:"bytes,5,opt,name=conf" json:"conf,omitempty"`
}

func (m *Roa) Reset()                    { *m = Roa{} }
func (m *Roa) String() string            { return proto.CompactTextString(m) }
func (*Roa) ProtoMessage()               {}
func (*Roa) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{179} }

func (m *Roa) GetAs() uint32 {
	if m != nil {
		return m.As
	}
	return 0
}

func (m *Roa) GetPrefixlen() uint32 {
	if m != nil {
		return m.Prefixlen
	}
	return 0
}

func (m *Roa) GetMaxlen() uint32 {
	if m != nil {
		return m.Maxlen
	}
	return 0
}

func (m *Roa) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

func (m *Roa) GetConf() *RPKIConf {
	if m != nil {
		return m.Conf
	}
	return nil
}

type GetRoaRequest struct {
	Family uint32 `protobuf:"varint,1,opt,name=family,proto3" json:"family,omitempty"`
}

func (m *GetRoaRequest) Reset()                    { *m = GetRoaRequest{} }
func (m *GetRoaRequest) String() string            { return proto.CompactTextString(m) }
func (*GetRoaRequest) ProtoMessage()               {}
func (*GetRoaRequest) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{180} }

func (m *GetRoaRequest) GetFamily() uint32 {
	if m != nil {
		return m.Family
	}
	return 0
}

type GetRoaResponse struct {
	Roas []*Roa `protobuf:"bytes,1,rep,name=roas" json:"roas,omitempty"`
}

func (m *GetRoaResponse) Reset()                    { *m = GetRoaResponse{} }
func (m *GetRoaResponse) String() string            { return proto.CompactTextString(m) }
func (*GetRoaResponse) ProtoMessage()               {}
func (*GetRoaResponse) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{181} }

func (m *GetRoaResponse) GetRoas() []*Roa {
	if m != nil {
		return m.Roas
	}
	return nil
}

type Vrf struct {
	Name     string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Rd       []byte   `protobuf:"bytes,2,opt,name=rd,proto3" json:"rd,omitempty"`
	ImportRt [][]byte `protobuf:"bytes,3,rep,name=import_rt,json=importRt" json:"import_rt,omitempty"`
	ExportRt [][]byte `protobuf:"bytes,4,rep,name=export_rt,json=exportRt" json:"export_rt,omitempty"`
	Id       uint32   `protobuf:"varint,5,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *Vrf) Reset()                    { *m = Vrf{} }
func (m *Vrf) String() string            { return proto.CompactTextString(m) }
func (*Vrf) ProtoMessage()               {}
func (*Vrf) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{182} }

func (m *Vrf) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Vrf) GetRd() []byte {
	if m != nil {
		return m.Rd
	}
	return nil
}

func (m *Vrf) GetImportRt() [][]byte {
	if m != nil {
		return m.ImportRt
	}
	return nil
}

func (m *Vrf) GetExportRt() [][]byte {
	if m != nil {
		return m.ExportRt
	}
	return nil
}

func (m *Vrf) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

type DefaultRouteDistance struct {
	ExternalRouteDistance uint32 `protobuf:"varint,1,opt,name=external_route_distance,json=externalRouteDistance,proto3" json:"external_route_distance,omitempty"`
	InternalRouteDistance uint32 `protobuf:"varint,2,opt,name=internal_route_distance,json=internalRouteDistance,proto3" json:"internal_route_distance,omitempty"`
}

func (m *DefaultRouteDistance) Reset()                    { *m = DefaultRouteDistance{} }
func (m *DefaultRouteDistance) String() string            { return proto.CompactTextString(m) }
func (*DefaultRouteDistance) ProtoMessage()               {}
func (*DefaultRouteDistance) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{183} }

func (m *DefaultRouteDistance) GetExternalRouteDistance() uint32 {
	if m != nil {
		return m.ExternalRouteDistance
	}
	return 0
}

func (m *DefaultRouteDistance) GetInternalRouteDistance() uint32 {
	if m != nil {
		return m.InternalRouteDistance
	}
	return 0
}

type Global struct {
	As                    uint32                       `protobuf:"varint,1,opt,name=as,proto3" json:"as,omitempty"`
	RouterId              string                       `protobuf:"bytes,2,opt,name=router_id,json=routerId,proto3" json:"router_id,omitempty"`
	ListenPort            int32                        `protobuf:"varint,3,opt,name=listen_port,json=listenPort,proto3" json:"listen_port,omitempty"`
	ListenAddresses       []string                     `protobuf:"bytes,4,rep,name=listen_addresses,json=listenAddresses" json:"listen_addresses,omitempty"`
	Families              []uint32                     `protobuf:"varint,5,rep,packed,name=families" json:"families,omitempty"`
	UseMultiplePaths      bool                         `protobuf:"varint,6,opt,name=use_multiple_paths,json=useMultiplePaths,proto3" json:"use_multiple_paths,omitempty"`
	RouteSelectionOptions *RouteSelectionOptionsConfig `protobuf:"bytes,7,opt,name=route_selection_options,json=routeSelectionOptions" json:"route_selection_options,omitempty"`
	DefaultRouteDistance  *DefaultRouteDistance        `protobuf:"bytes,8,opt,name=default_route_distance,json=defaultRouteDistance" json:"default_route_distance,omitempty"`
	Confederation         *Confederation               `protobuf:"bytes,9,opt,name=confederation" json:"confederation,omitempty"`
	GracefulRestart       *GracefulRestart             `protobuf:"bytes,10,opt,name=graceful_restart,json=gracefulRestart" json:"graceful_restart,omitempty"`
	ApplyPolicy           *ApplyPolicy                 `protobuf:"bytes,11,opt,name=apply_policy,json=applyPolicy" json:"apply_policy,omitempty"`
}

func (m *Global) Reset()                    { *m = Global{} }
func (m *Global) String() string            { return proto.CompactTextString(m) }
func (*Global) ProtoMessage()               {}
func (*Global) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{184} }

func (m *Global) GetAs() uint32 {
	if m != nil {
		return m.As
	}
	return 0
}

func (m *Global) GetRouterId() string {
	if m != nil {
		return m.RouterId
	}
	return ""
}

func (m *Global) GetListenPort() int32 {
	if m != nil {
		return m.ListenPort
	}
	return 0
}

func (m *Global) GetListenAddresses() []string {
	if m != nil {
		return m.ListenAddresses
	}
	return nil
}

func (m *Global) GetFamilies() []uint32 {
	if m != nil {
		return m.Families
	}
	return nil
}

func (m *Global) GetUseMultiplePaths() bool {
	if m != nil {
		return m.UseMultiplePaths
	}
	return false
}

func (m *Global) GetRouteSelectionOptions() *RouteSelectionOptionsConfig {
	if m != nil {
		return m.RouteSelectionOptions
	}
	return nil
}

func (m *Global) GetDefaultRouteDistance() *DefaultRouteDistance {
	if m != nil {
		return m.DefaultRouteDistance
	}
	return nil
}

func (m *Global) GetConfederation() *Confederation {
	if m != nil {
		return m.Confederation
	}
	return nil
}

func (m *Global) GetGracefulRestart() *GracefulRestart {
	if m != nil {
		return m.GracefulRestart
	}
	return nil
}

func (m *Global) GetApplyPolicy() *ApplyPolicy {
	if m != nil {
		return m.ApplyPolicy
	}
	return nil
}

type Confederation struct {
	Enabled      bool     `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	Identifier   uint32   `protobuf:"varint,2,opt,name=identifier,proto3" json:"identifier,omitempty"`
	MemberAsList []uint32 `protobuf:"varint,3,rep,packed,name=member_as_list,json=memberAsList" json:"member_as_list,omitempty"`
}

func (m *Confederation) Reset()                    { *m = Confederation{} }
func (m *Confederation) String() string            { return proto.CompactTextString(m) }
func (*Confederation) ProtoMessage()               {}
func (*Confederation) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{185} }

func (m *Confederation) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *Confederation) GetIdentifier() uint32 {
	if m != nil {
		return m.Identifier
	}
	return 0
}

func (m *Confederation) GetMemberAsList() []uint32 {
	if m != nil {
		return m.MemberAsList
	}
	return nil
}

type TableInfo struct {
	Type           Resource `protobuf:"varint,1,opt,name=type,proto3,enum=gobgpapi.Resource" json:"type,omitempty"`
	Name           string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Family         uint32   `protobuf:"varint,3,opt,name=family,proto3" json:"family,omitempty"`
	NumDestination uint64   `protobuf:"varint,4,opt,name=num_destination,json=numDestination,proto3" json:"num_destination,omitempty"`
	NumPath        uint64   `protobuf:"varint,5,opt,name=num_path,json=numPath,proto3" json:"num_path,omitempty"`
	NumAccepted    uint64   `protobuf:"varint,6,opt,name=num_accepted,json=numAccepted,proto3" json:"num_accepted,omitempty"`
}

func (m *TableInfo) Reset()                    { *m = TableInfo{} }
func (m *TableInfo) String() string            { return proto.CompactTextString(m) }
func (*TableInfo) ProtoMessage()               {}
func (*TableInfo) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{186} }

func (m *TableInfo) GetType() Resource {
	if m != nil {
		return m.Type
	}
	return Resource_GLOBAL
}

func (m *TableInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TableInfo) GetFamily() uint32 {
	if m != nil {
		return m.Family
	}
	return 0
}

func (m *TableInfo) GetNumDestination() uint64 {
	if m != nil {
		return m.NumDestination
	}
	return 0
}

func (m *TableInfo) GetNumPath() uint64 {
	if m != nil {
		return m.NumPath
	}
	return 0
}

func (m *TableInfo) GetNumAccepted() uint64 {
	if m != nil {
		return m.NumAccepted
	}
	return 0
}

type GetRibInfoRequest struct {
	Info *TableInfo `protobuf:"bytes,1,opt,name=info" json:"info,omitempty"`
}

func (m *GetRibInfoRequest) Reset()                    { *m = GetRibInfoRequest{} }
func (m *GetRibInfoRequest) String() string            { return proto.CompactTextString(m) }
func (*GetRibInfoRequest) ProtoMessage()               {}
func (*GetRibInfoRequest) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{187} }

func (m *GetRibInfoRequest) GetInfo() *TableInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

type GetRibInfoResponse struct {
	Info *TableInfo `protobuf:"bytes,1,opt,name=info" json:"info,omitempty"`
}

func (m *GetRibInfoResponse) Reset()                    { *m = GetRibInfoResponse{} }
func (m *GetRibInfoResponse) String() string            { return proto.CompactTextString(m) }
func (*GetRibInfoResponse) ProtoMessage()               {}
func (*GetRibInfoResponse) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{188} }

func (m *GetRibInfoResponse) GetInfo() *TableInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

type AddCollectorRequest struct {
	Url               string `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	DbName            string `protobuf:"bytes,2,opt,name=db_name,json=dbName,proto3" json:"db_name,omitempty"`
	TableDumpInterval uint64 `protobuf:"varint,3,opt,name=table_dump_interval,json=tableDumpInterval,proto3" json:"table_dump_interval,omitempty"`
}

func (m *AddCollectorRequest) Reset()                    { *m = AddCollectorRequest{} }
func (m *AddCollectorRequest) String() string            { return proto.CompactTextString(m) }
func (*AddCollectorRequest) ProtoMessage()               {}
func (*AddCollectorRequest) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{189} }

func (m *AddCollectorRequest) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *AddCollectorRequest) GetDbName() string {
	if m != nil {
		return m.DbName
	}
	return ""
}

func (m *AddCollectorRequest) GetTableDumpInterval() uint64 {
	if m != nil {
		return m.TableDumpInterval
	}
	return 0
}

type AddCollectorResponse struct {
}

func (m *AddCollectorResponse) Reset()                    { *m = AddCollectorResponse{} }
func (m *AddCollectorResponse) String() string            { return proto.CompactTextString(m) }
func (*AddCollectorResponse) ProtoMessage()               {}
func (*AddCollectorResponse) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{190} }

type ShutdownRequest struct {
}

func (m *ShutdownRequest) Reset()                    { *m = ShutdownRequest{} }
func (m *ShutdownRequest) String() string            { return proto.CompactTextString(m) }
func (*ShutdownRequest) ProtoMessage()               {}
func (*ShutdownRequest) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{191} }

type ShutdownResponse struct {
}

func (m *ShutdownResponse) Reset()                    { *m = ShutdownResponse{} }
func (m *ShutdownResponse) String() string            { return proto.CompactTextString(m) }
func (*ShutdownResponse) ProtoMessage()               {}
func (*ShutdownResponse) Descriptor() ([]byte, []int) { return fileDescriptorGobgp, []int{192} }

func init() {
	proto.RegisterType((*GetNeighborRequest)(nil), "gobgpapi.GetNeighborRequest")
	proto.RegisterType((*GetNeighborResponse)(nil), "gobgpapi.GetNeighborResponse")
	proto.RegisterType((*Arguments)(nil), "gobgpapi.Arguments")
	proto.RegisterType((*AddPathRequest)(nil), "gobgpapi.AddPathRequest")
	proto.RegisterType((*AddPathResponse)(nil), "gobgpapi.AddPathResponse")
	proto.RegisterType((*DeletePathRequest)(nil), "gobgpapi.DeletePathRequest")
	proto.RegisterType((*DeletePathResponse)(nil), "gobgpapi.DeletePathResponse")
	proto.RegisterType((*AddNeighborRequest)(nil), "gobgpapi.AddNeighborRequest")
	proto.RegisterType((*AddNeighborResponse)(nil), "gobgpapi.AddNeighborResponse")
	proto.RegisterType((*DeleteNeighborRequest)(nil), "gobgpapi.DeleteNeighborRequest")
	proto.RegisterType((*DeleteNeighborResponse)(nil), "gobgpapi.DeleteNeighborResponse")
	proto.RegisterType((*UpdateNeighborRequest)(nil), "gobgpapi.UpdateNeighborRequest")
	proto.RegisterType((*UpdateNeighborResponse)(nil), "gobgpapi.UpdateNeighborResponse")
	proto.RegisterType((*AddPeerGroupRequest)(nil), "gobgpapi.AddPeerGroupRequest")
	proto.RegisterType((*AddPeerGroupResponse)(nil), "gobgpapi.AddPeerGroupResponse")
	proto.RegisterType((*DeletePeerGroupRequest)(nil), "gobgpapi.DeletePeerGroupRequest")
	proto.RegisterType((*DeletePeerGroupResponse)(nil), "gobgpapi.DeletePeerGroupResponse")
	proto.RegisterType((*UpdatePeerGroupRequest)(nil), "gobgpapi.UpdatePeerGroupRequest")
	proto.RegisterType((*UpdatePeerGroupResponse)(nil), "gobgpapi.UpdatePeerGroupResponse")
	proto.RegisterType((*AddDynamicNeighborRequest)(nil), "gobgpapi.AddDynamicNeighborRequest")
	proto.RegisterType((*AddDynamicNeighborResponse)(nil), "gobgpapi.AddDynamicNeighborResponse")
	proto.RegisterType((*ResetNeighborRequest)(nil), "gobgpapi.ResetNeighborRequest")
	proto.RegisterType((*ResetNeighborResponse)(nil), "gobgpapi.ResetNeighborResponse")
	proto.RegisterType((*SoftResetNeighborRequest)(nil), "gobgpapi.SoftResetNeighborRequest")
	proto.RegisterType((*SoftResetNeighborResponse)(nil), "gobgpapi.SoftResetNeighborResponse")
	proto.RegisterType((*ShutdownNeighborRequest)(nil), "gobgpapi.ShutdownNeighborRequest")
	proto.RegisterType((*ShutdownNeighborResponse)(nil), "gobgpapi.ShutdownNeighborResponse")
	proto.RegisterType((*EnableNeighborRequest)(nil), "gobgpapi.EnableNeighborRequest")
	proto.RegisterType((*EnableNeighborResponse)(nil), "gobgpapi.EnableNeighborResponse")
	proto.RegisterType((*DisableNeighborRequest)(nil), "gobgpapi.DisableNeighborRequest")
	proto.RegisterType((*DisableNeighborResponse)(nil), "gobgpapi.DisableNeighborResponse")
	proto.RegisterType((*UpdatePolicyRequest)(nil), "gobgpapi.UpdatePolicyRequest")
	proto.RegisterType((*UpdatePolicyResponse)(nil), "gobgpapi.UpdatePolicyResponse")
	proto.RegisterType((*EnableMrtRequest)(nil), "gobgpapi.EnableMrtRequest")
	proto.RegisterType((*EnableMrtResponse)(nil), "gobgpapi.EnableMrtResponse")
	proto.RegisterType((*DisableMrtRequest)(nil), "gobgpapi.DisableMrtRequest")
	proto.RegisterType((*DisableMrtResponse)(nil), "gobgpapi.DisableMrtResponse")
	proto.RegisterType((*InjectMrtRequest)(nil), "gobgpapi.InjectMrtRequest")
	proto.RegisterType((*InjectMrtResponse)(nil), "gobgpapi.InjectMrtResponse")
	proto.RegisterType((*AddBmpRequest)(nil), "gobgpapi.AddBmpRequest")
	proto.RegisterType((*AddBmpResponse)(nil), "gobgpapi.AddBmpResponse")
	proto.RegisterType((*DeleteBmpRequest)(nil), "gobgpapi.DeleteBmpRequest")
	proto.RegisterType((*DeleteBmpResponse)(nil), "gobgpapi.DeleteBmpResponse")
	proto.RegisterType((*MonitorRibRequest)(nil), "gobgpapi.MonitorRibRequest")
	proto.RegisterType((*RPKIConf)(nil), "gobgpapi.RPKIConf")
	proto.RegisterType((*RPKIState)(nil), "gobgpapi.RPKIState")
	proto.RegisterType((*Rpki)(nil), "gobgpapi.Rpki")
	proto.RegisterType((*GetRpkiRequest)(nil), "gobgpapi.GetRpkiRequest")
	proto.RegisterType((*GetRpkiResponse)(nil), "gobgpapi.GetRpkiResponse")
	proto.RegisterType((*AddRpkiRequest)(nil), "gobgpapi.AddRpkiRequest")
	proto.RegisterType((*AddRpkiResponse)(nil), "gobgpapi.AddRpkiResponse")
	proto.RegisterType((*DeleteRpkiRequest)(nil), "gobgpapi.DeleteRpkiRequest")
	proto.RegisterType((*DeleteRpkiResponse)(nil), "gobgpapi.DeleteRpkiResponse")
	proto.RegisterType((*EnableRpkiRequest)(nil), "gobgpapi.EnableRpkiRequest")
	proto.RegisterType((*EnableRpkiResponse)(nil), "gobgpapi.EnableRpkiResponse")
	proto.RegisterType((*DisableRpkiRequest)(nil), "gobgpapi.DisableRpkiRequest")
	proto.RegisterType((*DisableRpkiResponse)(nil), "gobgpapi.DisableRpkiResponse")
	proto.RegisterType((*ResetRpkiRequest)(nil), "gobgpapi.ResetRpkiRequest")
	proto.RegisterType((*ResetRpkiResponse)(nil), "gobgpapi.ResetRpkiResponse")
	proto.RegisterType((*SoftResetRpkiRequest)(nil), "gobgpapi.SoftResetRpkiRequest")
	proto.RegisterType((*SoftResetRpkiResponse)(nil), "gobgpapi.SoftResetRpkiResponse")
	proto.RegisterType((*EnableZebraRequest)(nil), "gobgpapi.EnableZebraRequest")
	proto.RegisterType((*EnableZebraResponse)(nil), "gobgpapi.EnableZebraResponse")
	proto.RegisterType((*GetVrfRequest)(nil), "gobgpapi.GetVrfRequest")
	proto.RegisterType((*GetVrfResponse)(nil), "gobgpapi.GetVrfResponse")
	proto.RegisterType((*AddVrfRequest)(nil), "gobgpapi.AddVrfRequest")
	proto.RegisterType((*AddVrfResponse)(nil), "gobgpapi.AddVrfResponse")
	proto.RegisterType((*DeleteVrfRequest)(nil), "gobgpapi.DeleteVrfRequest")
	proto.RegisterType((*DeleteVrfResponse)(nil), "gobgpapi.DeleteVrfResponse")
	proto.RegisterType((*GetDefinedSetRequest)(nil), "gobgpapi.GetDefinedSetRequest")
	proto.RegisterType((*GetDefinedSetResponse)(nil), "gobgpapi.GetDefinedSetResponse")
	proto.RegisterType((*AddDefinedSetRequest)(nil), "gobgpapi.AddDefinedSetRequest")
	proto.RegisterType((*AddDefinedSetResponse)(nil), "gobgpapi.AddDefinedSetResponse")
	proto.RegisterType((*DeleteDefinedSetRequest)(nil), "gobgpapi.DeleteDefinedSetRequest")
	proto.RegisterType((*DeleteDefinedSetResponse)(nil), "gobgpapi.DeleteDefinedSetResponse")
	proto.RegisterType((*ReplaceDefinedSetRequest)(nil), "gobgpapi.ReplaceDefinedSetRequest")
	proto.RegisterType((*ReplaceDefinedSetResponse)(nil), "gobgpapi.ReplaceDefinedSetResponse")
	proto.RegisterType((*GetStatementRequest)(nil), "gobgpapi.GetStatementRequest")
	proto.RegisterType((*GetStatementResponse)(nil), "gobgpapi.GetStatementResponse")
	proto.RegisterType((*AddStatementRequest)(nil), "gobgpapi.AddStatementRequest")
	proto.RegisterType((*AddStatementResponse)(nil), "gobgpapi.AddStatementResponse")
	proto.RegisterType((*DeleteStatementRequest)(nil), "gobgpapi.DeleteStatementRequest")
	proto.RegisterType((*DeleteStatementResponse)(nil), "gobgpapi.DeleteStatementResponse")
	proto.RegisterType((*ReplaceStatementRequest)(nil), "gobgpapi.ReplaceStatementRequest")
	proto.RegisterType((*ReplaceStatementResponse)(nil), "gobgpapi.ReplaceStatementResponse")
	proto.RegisterType((*GetPolicyRequest)(nil), "gobgpapi.GetPolicyRequest")
	proto.RegisterType((*GetPolicyResponse)(nil), "gobgpapi.GetPolicyResponse")
	proto.RegisterType((*AddPolicyRequest)(nil), "gobgpapi.AddPolicyRequest")
	proto.RegisterType((*AddPolicyResponse)(nil), "gobgpapi.AddPolicyResponse")
	proto.RegisterType((*DeletePolicyRequest)(nil), "gobgpapi.DeletePolicyRequest")
	proto.RegisterType((*DeletePolicyResponse)(nil), "gobgpapi.DeletePolicyResponse")
	proto.RegisterType((*ReplacePolicyRequest)(nil), "gobgpapi.ReplacePolicyRequest")
	proto.RegisterType((*ReplacePolicyResponse)(nil), "gobgpapi.ReplacePolicyResponse")
	proto.RegisterType((*GetPolicyAssignmentRequest)(nil), "gobgpapi.GetPolicyAssignmentRequest")
	proto.RegisterType((*GetPolicyAssignmentResponse)(nil), "gobgpapi.GetPolicyAssignmentResponse")
	proto.RegisterType((*AddPolicyAssignmentRequest)(nil), "gobgpapi.AddPolicyAssignmentRequest")
	proto.RegisterType((*AddPolicyAssignmentResponse)(nil), "gobgpapi.AddPolicyAssignmentResponse")
	proto.RegisterType((*DeletePolicyAssignmentRequest)(nil), "gobgpapi.DeletePolicyAssignmentRequest")
	proto.RegisterType((*DeletePolicyAssignmentResponse)(nil), "gobgpapi.DeletePolicyAssignmentResponse")
	proto.RegisterType((*ReplacePolicyAssignmentRequest)(nil), "gobgpapi.ReplacePolicyAssignmentRequest")
	proto.RegisterType((*ReplacePolicyAssignmentResponse)(nil), "gobgpapi.ReplacePolicyAssignmentResponse")
	proto.RegisterType((*GetServerRequest)(nil), "gobgpapi.GetServerRequest")
	proto.RegisterType((*GetServerResponse)(nil), "gobgpapi.GetServerResponse")
	proto.RegisterType((*StartServerRequest)(nil), "gobgpapi.StartServerRequest")
	proto.RegisterType((*StartServerResponse)(nil), "gobgpapi.StartServerResponse")
	proto.RegisterType((*StopServerRequest)(nil), "gobgpapi.StopServerRequest")
	proto.RegisterType((*StopServerResponse)(nil), "gobgpapi.StopServerResponse")
	proto.RegisterType((*RPKIValidation)(nil), "gobgpapi.RPKIValidation")
	proto.RegisterType((*Path)(nil), "gobgpapi.Path")
	proto.RegisterType((*Destination)(nil), "gobgpapi.Destination")
	proto.RegisterType((*Table)(nil), "gobgpapi.Table")
	proto.RegisterType((*GetRibRequest)(nil), "gobgpapi.GetRibRequest")
	proto.RegisterType((*GetRibResponse)(nil), "gobgpapi.GetRibResponse")
	proto.RegisterType((*TableLookupPrefix)(nil), "gobgpapi.TableLookupPrefix")
	proto.RegisterType((*GetPathRequest)(nil), "gobgpapi.GetPathRequest")
	proto.RegisterType((*ValidateRibRequest)(nil), "gobgpapi.ValidateRibRequest")
	proto.RegisterType((*ValidateRibResponse)(nil), "gobgpapi.ValidateRibResponse")
	proto.RegisterType((*Peer)(nil), "gobgpapi.Peer")
	proto.RegisterType((*PeerGroup)(nil), "gobgpapi.PeerGroup")
	proto.RegisterType((*DynamicNeighbor)(nil), "gobgpapi.DynamicNeighbor")
	proto.RegisterType((*ApplyPolicy)(nil), "gobgpapi.ApplyPolicy")
	proto.RegisterType((*PrefixLimit)(nil), "gobgpapi.PrefixLimit")
	proto.RegisterType((*PeerConf)(nil), "gobgpapi.PeerConf")
	proto.RegisterType((*PeerGroupConf)(nil), "gobgpapi.PeerGroupConf")
	proto.RegisterType((*PeerGroupState)(nil), "gobgpapi.PeerGroupState")
	proto.RegisterType((*EbgpMultihop)(nil), "gobgpapi.EbgpMultihop")
	proto.RegisterType((*RouteReflector)(nil), "gobgpapi.RouteReflector")
	proto.RegisterType((*PeerState)(nil), "gobgpapi.PeerState")
	proto.RegisterType((*Messages)(nil), "gobgpapi.Messages")
	proto.RegisterType((*Message)(nil), "gobgpapi.Message")
	proto.RegisterType((*Queues)(nil), "gobgpapi.Queues")
	proto.RegisterType((*Timers)(nil), "gobgpapi.Timers")
	proto.RegisterType((*TimersConfig)(nil), "gobgpapi.TimersConfig")
	proto.RegisterType((*TimersState)(nil), "gobgpapi.TimersState")
	proto.RegisterType((*Transport)(nil), "gobgpapi.Transport")
	proto.RegisterType((*RouteServer)(nil), "gobgpapi.RouteServer")
	proto.RegisterType((*GracefulRestart)(nil), "gobgpapi.GracefulRestart")
	proto.RegisterType((*MpGracefulRestartConfig)(nil), "gobgpapi.MpGracefulRestartConfig")
	proto.RegisterType((*MpGracefulRestartState)(nil), "gobgpapi.MpGracefulRestartState")
	proto.RegisterType((*MpGracefulRestart)(nil), "gobgpapi.MpGracefulRestart")
	proto.RegisterType((*AfiSafiConfig)(nil), "gobgpapi.AfiSafiConfig")
	proto.RegisterType((*AfiSafiState)(nil), "gobgpapi.AfiSafiState")
	proto.RegisterType((*RouteSelectionOptionsConfig)(nil), "gobgpapi.RouteSelectionOptionsConfig")
	proto.RegisterType((*RouteSelectionOptionsState)(nil), "gobgpapi.RouteSelectionOptionsState")
	proto.RegisterType((*RouteSelectionOptions)(nil), "gobgpapi.RouteSelectionOptions")
	proto.RegisterType((*UseMultiplePathsConfig)(nil), "gobgpapi.UseMultiplePathsConfig")
	proto.RegisterType((*UseMultiplePathsState)(nil), "gobgpapi.UseMultiplePathsState")
	proto.RegisterType((*EbgpConfig)(nil), "gobgpapi.EbgpConfig")
	proto.RegisterType((*EbgpState)(nil), "gobgpapi.EbgpState")
	proto.RegisterType((*Ebgp)(nil), "gobgpapi.Ebgp")
	proto.RegisterType((*IbgpConfig)(nil), "gobgpapi.IbgpConfig")
	proto.RegisterType((*IbgpState)(nil), "gobgpapi.IbgpState")
	proto.RegisterType((*Ibgp)(nil), "gobgpapi.Ibgp")
	proto.RegisterType((*UseMultiplePaths)(nil), "gobgpapi.UseMultiplePaths")
	proto.RegisterType((*RouteTargetMembershipConfig)(nil), "gobgpapi.RouteTargetMembershipConfig")
	proto.RegisterType((*RouteTargetMembershipState)(nil), "gobgpapi.RouteTargetMembershipState")
	proto.RegisterType((*RouteTargetMembership)(nil), "gobgpapi.RouteTargetMembership")
	proto.RegisterType((*LongLivedGracefulRestartConfig)(nil), "gobgpapi.LongLivedGracefulRestartConfig")
	proto.RegisterType((*LongLivedGracefulRestartState)(nil), "gobgpapi.LongLivedGracefulRestartState")
	proto.RegisterType((*LongLivedGracefulRestart)(nil), "gobgpapi.LongLivedGracefulRestart")
	proto.RegisterType((*AfiSafi)(nil), "gobgpapi.AfiSafi")
	proto.RegisterType((*AddPathsConfig)(nil), "gobgpapi.AddPathsConfig")
	proto.RegisterType((*AddPathsState)(nil), "gobgpapi.AddPathsState")
	proto.RegisterType((*AddPaths)(nil), "gobgpapi.AddPaths")
	proto.RegisterType((*Prefix)(nil), "gobgpapi.Prefix")
	proto.RegisterType((*DefinedSet)(nil), "gobgpapi.DefinedSet")
	proto.RegisterType((*MatchSet)(nil), "gobgpapi.MatchSet")
	proto.RegisterType((*AsPathLength)(nil), "gobgpapi.AsPathLength")
	proto.RegisterType((*Conditions)(nil), "gobgpapi.Conditions")
	proto.RegisterType((*CommunityAction)(nil), "gobgpapi.CommunityAction")
	proto.RegisterType((*MedAction)(nil), "gobgpapi.MedAction")
	proto.RegisterType((*AsPrependAction)(nil), "gobgpapi.AsPrependAction")
	proto.RegisterType((*NexthopAction)(nil), "gobgpapi.NexthopAction")
	proto.RegisterType((*LocalPrefAction)(nil), "gobgpapi.LocalPrefAction")
	proto.RegisterType((*Actions)(nil), "gobgpapi.Actions")
	proto.RegisterType((*Statement)(nil), "gobgpapi.Statement")
	proto.RegisterType((*Policy)(nil), "gobgpapi.Policy")
	proto.RegisterType((*PolicyAssignment)(nil), "gobgpapi.PolicyAssignment")
	proto.RegisterType((*RoutingPolicy)(nil), "gobgpapi.RoutingPolicy")
	proto.RegisterType((*Roa)(nil), "gobgpapi.Roa")
	proto.RegisterType((*GetRoaRequest)(nil), "gobgpapi.GetRoaRequest")
	proto.RegisterType((*GetRoaResponse)(nil), "gobgpapi.GetRoaResponse")
	proto.RegisterType((*Vrf)(nil), "gobgpapi.Vrf")
	proto.RegisterType((*DefaultRouteDistance)(nil), "gobgpapi.DefaultRouteDistance")
	proto.RegisterType((*Global)(nil), "gobgpapi.Global")
	proto.RegisterType((*Confederation)(nil), "gobgpapi.Confederation")
	proto.RegisterType((*TableInfo)(nil), "gobgpapi.TableInfo")
	proto.RegisterType((*GetRibInfoRequest)(nil), "gobgpapi.GetRibInfoRequest")
	proto.RegisterType((*GetRibInfoResponse)(nil), "gobgpapi.GetRibInfoResponse")
	proto.RegisterType((*AddCollectorRequest)(nil), "gobgpapi.AddCollectorRequest")
	proto.RegisterType((*AddCollectorResponse)(nil), "gobgpapi.AddCollectorResponse")
	proto.RegisterType((*ShutdownRequest)(nil), "gobgpapi.ShutdownRequest")
	proto.RegisterType((*ShutdownResponse)(nil), "gobgpapi.ShutdownResponse")
	proto.RegisterEnum("gobgpapi.Family", Family_name, Family_value)
	proto.RegisterEnum("gobgpapi.Resource", Resource_name, Resource_value)
	proto.RegisterEnum("gobgpapi.TableLookupOption", TableLookupOption_name, TableLookupOption_value)
	proto.RegisterEnum("gobgpapi.DefinedType", DefinedType_name, DefinedType_value)
	proto.RegisterEnum("gobgpapi.MatchType", MatchType_name, MatchType_value)
	proto.RegisterEnum("gobgpapi.AsPathLengthType", AsPathLengthType_name, AsPathLengthType_value)
	proto.RegisterEnum("gobgpapi.RouteAction", RouteAction_name, RouteAction_value)
	proto.RegisterEnum("gobgpapi.CommunityActionType", CommunityActionType_name, CommunityActionType_value)
	proto.RegisterEnum("gobgpapi.MedActionType", MedActionType_name, MedActionType_value)
	proto.RegisterEnum("gobgpapi.PolicyType", PolicyType_name, PolicyType_value)
	proto.RegisterEnum("gobgpapi.SoftResetNeighborRequest_SoftResetDirection", SoftResetNeighborRequest_SoftResetDirection_name, SoftResetNeighborRequest_SoftResetDirection_value)
	proto.RegisterEnum("gobgpapi.AddBmpRequest_MonitoringPolicy", AddBmpRequest_MonitoringPolicy_name, AddBmpRequest_MonitoringPolicy_value)
	proto.RegisterEnum("gobgpapi.RPKIValidation_State", RPKIValidation_State_name, RPKIValidation_State_value)
	proto.RegisterEnum("gobgpapi.RPKIValidation_Reason", RPKIValidation_Reason_name, RPKIValidation_Reason_value)
	proto.RegisterEnum("gobgpapi.PeerConf_RemovePrivateAs", PeerConf_RemovePrivateAs_name, PeerConf_RemovePrivateAs_value)
	proto.RegisterEnum("gobgpapi.PeerGroupConf_RemovePrivateAs", PeerGroupConf_RemovePrivateAs_name, PeerGroupConf_RemovePrivateAs_value)
	proto.RegisterEnum("gobgpapi.PeerGroupState_RemovePrivateAs", PeerGroupState_RemovePrivateAs_name, PeerGroupState_RemovePrivateAs_value)
	proto.RegisterEnum("gobgpapi.PeerState_AdminState", PeerState_AdminState_name, PeerState_AdminState_value)
	proto.RegisterEnum("gobgpapi.Conditions_RouteType", Conditions_RouteType_name, Conditions_RouteType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for GobgpApi service

type GobgpApiClient interface {
	StartServer(ctx context.Context, in *StartServerRequest, opts ...grpc.CallOption) (*StartServerResponse, error)
	StopServer(ctx context.Context, in *StopServerRequest, opts ...grpc.CallOption) (*StopServerResponse, error)
	GetServer(ctx context.Context, in *GetServerRequest, opts ...grpc.CallOption) (*GetServerResponse, error)
	AddNeighbor(ctx context.Context, in *AddNeighborRequest, opts ...grpc.CallOption) (*AddNeighborResponse, error)
	DeleteNeighbor(ctx context.Context, in *DeleteNeighborRequest, opts ...grpc.CallOption) (*DeleteNeighborResponse, error)
	UpdateNeighbor(ctx context.Context, in *UpdateNeighborRequest, opts ...grpc.CallOption) (*UpdateNeighborResponse, error)
	GetNeighbor(ctx context.Context, in *GetNeighborRequest, opts ...grpc.CallOption) (*GetNeighborResponse, error)
	ResetNeighbor(ctx context.Context, in *ResetNeighborRequest, opts ...grpc.CallOption) (*ResetNeighborResponse, error)
	SoftResetNeighbor(ctx context.Context, in *SoftResetNeighborRequest, opts ...grpc.CallOption) (*SoftResetNeighborResponse, error)
	ShutdownNeighbor(ctx context.Context, in *ShutdownNeighborRequest, opts ...grpc.CallOption) (*ShutdownNeighborResponse, error)
	EnableNeighbor(ctx context.Context, in *EnableNeighborRequest, opts ...grpc.CallOption) (*EnableNeighborResponse, error)
	DisableNeighbor(ctx context.Context, in *DisableNeighborRequest, opts ...grpc.CallOption) (*DisableNeighborResponse, error)
	GetRib(ctx context.Context, in *GetRibRequest, opts ...grpc.CallOption) (*GetRibResponse, error)
	GetPath(ctx context.Context, in *GetPathRequest, opts ...grpc.CallOption) (GobgpApi_GetPathClient, error)
	ValidateRib(ctx context.Context, in *ValidateRibRequest, opts ...grpc.CallOption) (*ValidateRibResponse, error)
	AddPath(ctx context.Context, in *AddPathRequest, opts ...grpc.CallOption) (*AddPathResponse, error)
	DeletePath(ctx context.Context, in *DeletePathRequest, opts ...grpc.CallOption) (*DeletePathResponse, error)
	MonitorRib(ctx context.Context, in *MonitorRibRequest, opts ...grpc.CallOption) (GobgpApi_MonitorRibClient, error)
	MonitorPeerState(ctx context.Context, in *Arguments, opts ...grpc.CallOption) (GobgpApi_MonitorPeerStateClient, error)
	EnableMrt(ctx context.Context, in *EnableMrtRequest, opts ...grpc.CallOption) (*EnableMrtResponse, error)
	DisableMrt(ctx context.Context, in *DisableMrtRequest, opts ...grpc.CallOption) (*DisableMrtResponse, error)
	InjectMrt(ctx context.Context, opts ...grpc.CallOption) (GobgpApi_InjectMrtClient, error)
	AddBmp(ctx context.Context, in *AddBmpRequest, opts ...grpc.CallOption) (*AddBmpResponse, error)
	DeleteBmp(ctx context.Context, in *DeleteBmpRequest, opts ...grpc.CallOption) (*DeleteBmpResponse, error)
	GetRpki(ctx context.Context, in *GetRpkiRequest, opts ...grpc.CallOption) (*GetRpkiResponse, error)
	AddRpki(ctx context.Context, in *AddRpkiRequest, opts ...grpc.CallOption) (*AddRpkiResponse, error)
	DeleteRpki(ctx context.Context, in *DeleteRpkiRequest, opts ...grpc.CallOption) (*DeleteRpkiResponse, error)
	EnableRpki(ctx context.Context, in *EnableRpkiRequest, opts ...grpc.CallOption) (*EnableRpkiResponse, error)
	DisableRpki(ctx context.Context, in *DisableRpkiRequest, opts ...grpc.CallOption) (*DisableRpkiResponse, error)
	ResetRpki(ctx context.Context, in *ResetRpkiRequest, opts ...grpc.CallOption) (*ResetRpkiResponse, error)
	SoftResetRpki(ctx context.Context, in *SoftResetRpkiRequest, opts ...grpc.CallOption) (*SoftResetRpkiResponse, error)
	GetRoa(ctx context.Context, in *GetRoaRequest, opts ...grpc.CallOption) (*GetRoaResponse, error)
	EnableZebra(ctx context.Context, in *EnableZebraRequest, opts ...grpc.CallOption) (*EnableZebraResponse, error)
	AddVrf(ctx context.Context, in *AddVrfRequest, opts ...grpc.CallOption) (*AddVrfResponse, error)
	DeleteVrf(ctx context.Context, in *DeleteVrfRequest, opts ...grpc.CallOption) (*DeleteVrfResponse, error)
	GetVrf(ctx context.Context, in *GetVrfRequest, opts ...grpc.CallOption) (*GetVrfResponse, error)
	GetDefinedSet(ctx context.Context, in *GetDefinedSetRequest, opts ...grpc.CallOption) (*GetDefinedSetResponse, error)
	AddDefinedSet(ctx context.Context, in *AddDefinedSetRequest, opts ...grpc.CallOption) (*AddDefinedSetResponse, error)
	DeleteDefinedSet(ctx context.Context, in *DeleteDefinedSetRequest, opts ...grpc.CallOption) (*DeleteDefinedSetResponse, error)
	ReplaceDefinedSet(ctx context.Context, in *ReplaceDefinedSetRequest, opts ...grpc.CallOption) (*ReplaceDefinedSetResponse, error)
	GetStatement(ctx context.Context, in *GetStatementRequest, opts ...grpc.CallOption) (*GetStatementResponse, error)
	AddStatement(ctx context.Context, in *AddStatementRequest, opts ...grpc.CallOption) (*AddStatementResponse, error)
	DeleteStatement(ctx context.Context, in *DeleteStatementRequest, opts ...grpc.CallOption) (*DeleteStatementResponse, error)
	ReplaceStatement(ctx context.Context, in *ReplaceStatementRequest, opts ...grpc.CallOption) (*ReplaceStatementResponse, error)
	GetPolicy(ctx context.Context, in *GetPolicyRequest, opts ...grpc.CallOption) (*GetPolicyResponse, error)
	AddPolicy(ctx context.Context, in *AddPolicyRequest, opts ...grpc.CallOption) (*AddPolicyResponse, error)
	DeletePolicy(ctx context.Context, in *DeletePolicyRequest, opts ...grpc.CallOption) (*DeletePolicyResponse, error)
	ReplacePolicy(ctx context.Context, in *ReplacePolicyRequest, opts ...grpc.CallOption) (*ReplacePolicyResponse, error)
	UpdatePolicy(ctx context.Context, in *UpdatePolicyRequest, opts ...grpc.CallOption) (*UpdatePolicyResponse, error)
	GetPolicyAssignment(ctx context.Context, in *GetPolicyAssignmentRequest, opts ...grpc.CallOption) (*GetPolicyAssignmentResponse, error)
	AddPolicyAssignment(ctx context.Context, in *AddPolicyAssignmentRequest, opts ...grpc.CallOption) (*AddPolicyAssignmentResponse, error)
	DeletePolicyAssignment(ctx context.Context, in *DeletePolicyAssignmentRequest, opts ...grpc.CallOption) (*DeletePolicyAssignmentResponse, error)
	ReplacePolicyAssignment(ctx context.Context, in *ReplacePolicyAssignmentRequest, opts ...grpc.CallOption) (*ReplacePolicyAssignmentResponse, error)
	GetRibInfo(ctx context.Context, in *GetRibInfoRequest, opts ...grpc.CallOption) (*GetRibInfoResponse, error)
	AddPeerGroup(ctx context.Context, in *AddPeerGroupRequest, opts ...grpc.CallOption) (*AddPeerGroupResponse, error)
	DeletePeerGroup(ctx context.Context, in *DeletePeerGroupRequest, opts ...grpc.CallOption) (*DeletePeerGroupResponse, error)
	UpdatePeerGroup(ctx context.Context, in *UpdatePeerGroupRequest, opts ...grpc.CallOption) (*UpdatePeerGroupResponse, error)
	AddDynamicNeighbor(ctx context.Context, in *AddDynamicNeighborRequest, opts ...grpc.CallOption) (*AddDynamicNeighborResponse, error)
	AddCollector(ctx context.Context, in *AddCollectorRequest, opts ...grpc.CallOption) (*AddCollectorResponse, error)
	Shutdown(ctx context.Context, in *ShutdownRequest, opts ...grpc.CallOption) (*ShutdownResponse, error)
}

type gobgpApiClient struct {
	cc *grpc.ClientConn
}

func NewGobgpApiClient(cc *grpc.ClientConn) GobgpApiClient {
	return &gobgpApiClient{cc}
}

func (c *gobgpApiClient) StartServer(ctx context.Context, in *StartServerRequest, opts ...grpc.CallOption) (*StartServerResponse, error) {
	out := new(StartServerResponse)
	err := grpc.Invoke(ctx, "/gobgpapi.GobgpApi/StartServer", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobgpApiClient) StopServer(ctx context.Context, in *StopServerRequest, opts ...grpc.CallOption) (*StopServerResponse, error) {
	out := new(StopServerResponse)
	err := grpc.Invoke(ctx, "/gobgpapi.GobgpApi/StopServer", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobgpApiClient) GetServer(ctx context.Context, in *GetServerRequest, opts ...grpc.CallOption) (*GetServerResponse, error) {
	out := new(GetServerResponse)
	err := grpc.Invoke(ctx, "/gobgpapi.GobgpApi/GetServer", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobgpApiClient) AddNeighbor(ctx context.Context, in *AddNeighborRequest, opts ...grpc.CallOption) (*AddNeighborResponse, error) {
	out := new(AddNeighborResponse)
	err := grpc.Invoke(ctx, "/gobgpapi.GobgpApi/AddNeighbor", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobgpApiClient) DeleteNeighbor(ctx context.Context, in *DeleteNeighborRequest, opts ...grpc.CallOption) (*DeleteNeighborResponse, error) {
	out := new(DeleteNeighborResponse)
	err := grpc.Invoke(ctx, "/gobgpapi.GobgpApi/DeleteNeighbor", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobgpApiClient) UpdateNeighbor(ctx context.Context, in *UpdateNeighborRequest, opts ...grpc.CallOption) (*UpdateNeighborResponse, error) {
	out := new(UpdateNeighborResponse)
	err := grpc.Invoke(ctx, "/gobgpapi.GobgpApi/UpdateNeighbor", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobgpApiClient) GetNeighbor(ctx context.Context, in *GetNeighborRequest, opts ...grpc.CallOption) (*GetNeighborResponse, error) {
	out := new(GetNeighborResponse)
	err := grpc.Invoke(ctx, "/gobgpapi.GobgpApi/GetNeighbor", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobgpApiClient) ResetNeighbor(ctx context.Context, in *ResetNeighborRequest, opts ...grpc.CallOption) (*ResetNeighborResponse, error) {
	out := new(ResetNeighborResponse)
	err := grpc.Invoke(ctx, "/gobgpapi.GobgpApi/ResetNeighbor", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobgpApiClient) SoftResetNeighbor(ctx context.Context, in *SoftResetNeighborRequest, opts ...grpc.CallOption) (*SoftResetNeighborResponse, error) {
	out := new(SoftResetNeighborResponse)
	err := grpc.Invoke(ctx, "/gobgpapi.GobgpApi/SoftResetNeighbor", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobgpApiClient) ShutdownNeighbor(ctx context.Context, in *ShutdownNeighborRequest, opts ...grpc.CallOption) (*ShutdownNeighborResponse, error) {
	out := new(ShutdownNeighborResponse)
	err := grpc.Invoke(ctx, "/gobgpapi.GobgpApi/ShutdownNeighbor", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobgpApiClient) EnableNeighbor(ctx context.Context, in *EnableNeighborRequest, opts ...grpc.CallOption) (*EnableNeighborResponse, error) {
	out := new(EnableNeighborResponse)
	err := grpc.Invoke(ctx, "/gobgpapi.GobgpApi/EnableNeighbor", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobgpApiClient) DisableNeighbor(ctx context.Context, in *DisableNeighborRequest, opts ...grpc.CallOption) (*DisableNeighborResponse, error) {
	out := new(DisableNeighborResponse)
	err := grpc.Invoke(ctx, "/gobgpapi.GobgpApi/DisableNeighbor", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobgpApiClient) GetRib(ctx context.Context, in *GetRibRequest, opts ...grpc.CallOption) (*GetRibResponse, error) {
	out := new(GetRibResponse)
	err := grpc.Invoke(ctx, "/gobgpapi.GobgpApi/GetRib", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobgpApiClient) GetPath(ctx context.Context, in *GetPathRequest, opts ...grpc.CallOption) (GobgpApi_GetPathClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_GobgpApi_serviceDesc.Streams[0], c.cc, "/gobgpapi.GobgpApi/GetPath", opts...)
	if err != nil {
		return nil, err
	}
	x := &gobgpApiGetPathClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type GobgpApi_GetPathClient interface {
	Recv() (*Path, error)
	grpc.ClientStream
}

type gobgpApiGetPathClient struct {
	grpc.ClientStream
}

func (x *gobgpApiGetPathClient) Recv() (*Path, error) {
	m := new(Path)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *gobgpApiClient) ValidateRib(ctx context.Context, in *ValidateRibRequest, opts ...grpc.CallOption) (*ValidateRibResponse, error) {
	out := new(ValidateRibResponse)
	err := grpc.Invoke(ctx, "/gobgpapi.GobgpApi/ValidateRib", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobgpApiClient) AddPath(ctx context.Context, in *AddPathRequest, opts ...grpc.CallOption) (*AddPathResponse, error) {
	out := new(AddPathResponse)
	err := grpc.Invoke(ctx, "/gobgpapi.GobgpApi/AddPath", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobgpApiClient) DeletePath(ctx context.Context, in *DeletePathRequest, opts ...grpc.CallOption) (*DeletePathResponse, error) {
	out := new(DeletePathResponse)
	err := grpc.Invoke(ctx, "/gobgpapi.GobgpApi/DeletePath", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobgpApiClient) MonitorRib(ctx context.Context, in *MonitorRibRequest, opts ...grpc.CallOption) (GobgpApi_MonitorRibClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_GobgpApi_serviceDesc.Streams[1], c.cc, "/gobgpapi.GobgpApi/MonitorRib", opts...)
	if err != nil {
		return nil, err
	}
	x := &gobgpApiMonitorRibClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type GobgpApi_MonitorRibClient interface {
	Recv() (*Destination, error)
	grpc.ClientStream
}

type gobgpApiMonitorRibClient struct {
	grpc.ClientStream
}

func (x *gobgpApiMonitorRibClient) Recv() (*Destination, error) {
	m := new(Destination)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *gobgpApiClient) MonitorPeerState(ctx context.Context, in *Arguments, opts ...grpc.CallOption) (GobgpApi_MonitorPeerStateClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_GobgpApi_serviceDesc.Streams[2], c.cc, "/gobgpapi.GobgpApi/MonitorPeerState", opts...)
	if err != nil {
		return nil, err
	}
	x := &gobgpApiMonitorPeerStateClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type GobgpApi_MonitorPeerStateClient interface {
	Recv() (*Peer, error)
	grpc.ClientStream
}

type gobgpApiMonitorPeerStateClient struct {
	grpc.ClientStream
}

func (x *gobgpApiMonitorPeerStateClient) Recv() (*Peer, error) {
	m := new(Peer)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *gobgpApiClient) EnableMrt(ctx context.Context, in *EnableMrtRequest, opts ...grpc.CallOption) (*EnableMrtResponse, error) {
	out := new(EnableMrtResponse)
	err := grpc.Invoke(ctx, "/gobgpapi.GobgpApi/EnableMrt", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobgpApiClient) DisableMrt(ctx context.Context, in *DisableMrtRequest, opts ...grpc.CallOption) (*DisableMrtResponse, error) {
	out := new(DisableMrtResponse)
	err := grpc.Invoke(ctx, "/gobgpapi.GobgpApi/DisableMrt", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobgpApiClient) InjectMrt(ctx context.Context, opts ...grpc.CallOption) (GobgpApi_InjectMrtClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_GobgpApi_serviceDesc.Streams[3], c.cc, "/gobgpapi.GobgpApi/InjectMrt", opts...)
	if err != nil {
		return nil, err
	}
	x := &gobgpApiInjectMrtClient{stream}
	return x, nil
}

type GobgpApi_InjectMrtClient interface {
	Send(*InjectMrtRequest) error
	CloseAndRecv() (*InjectMrtResponse, error)
	grpc.ClientStream
}

type gobgpApiInjectMrtClient struct {
	grpc.ClientStream
}

func (x *gobgpApiInjectMrtClient) Send(m *InjectMrtRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *gobgpApiInjectMrtClient) CloseAndRecv() (*InjectMrtResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(InjectMrtResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *gobgpApiClient) AddBmp(ctx context.Context, in *AddBmpRequest, opts ...grpc.CallOption) (*AddBmpResponse, error) {
	out := new(AddBmpResponse)
	err := grpc.Invoke(ctx, "/gobgpapi.GobgpApi/AddBmp", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobgpApiClient) DeleteBmp(ctx context.Context, in *DeleteBmpRequest, opts ...grpc.CallOption) (*DeleteBmpResponse, error) {
	out := new(DeleteBmpResponse)
	err := grpc.Invoke(ctx, "/gobgpapi.GobgpApi/DeleteBmp", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobgpApiClient) GetRpki(ctx context.Context, in *GetRpkiRequest, opts ...grpc.CallOption) (*GetRpkiResponse, error) {
	out := new(GetRpkiResponse)
	err := grpc.Invoke(ctx, "/gobgpapi.GobgpApi/GetRpki", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobgpApiClient) AddRpki(ctx context.Context, in *AddRpkiRequest, opts ...grpc.CallOption) (*AddRpkiResponse, error) {
	out := new(AddRpkiResponse)
	err := grpc.Invoke(ctx, "/gobgpapi.GobgpApi/AddRpki", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobgpApiClient) DeleteRpki(ctx context.Context, in *DeleteRpkiRequest, opts ...grpc.CallOption) (*DeleteRpkiResponse, error) {
	out := new(DeleteRpkiResponse)
	err := grpc.Invoke(ctx, "/gobgpapi.GobgpApi/DeleteRpki", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobgpApiClient) EnableRpki(ctx context.Context, in *EnableRpkiRequest, opts ...grpc.CallOption) (*EnableRpkiResponse, error) {
	out := new(EnableRpkiResponse)
	err := grpc.Invoke(ctx, "/gobgpapi.GobgpApi/EnableRpki", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobgpApiClient) DisableRpki(ctx context.Context, in *DisableRpkiRequest, opts ...grpc.CallOption) (*DisableRpkiResponse, error) {
	out := new(DisableRpkiResponse)
	err := grpc.Invoke(ctx, "/gobgpapi.GobgpApi/DisableRpki", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobgpApiClient) ResetRpki(ctx context.Context, in *ResetRpkiRequest, opts ...grpc.CallOption) (*ResetRpkiResponse, error) {
	out := new(ResetRpkiResponse)
	err := grpc.Invoke(ctx, "/gobgpapi.GobgpApi/ResetRpki", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobgpApiClient) SoftResetRpki(ctx context.Context, in *SoftResetRpkiRequest, opts ...grpc.CallOption) (*SoftResetRpkiResponse, error) {
	out := new(SoftResetRpkiResponse)
	err := grpc.Invoke(ctx, "/gobgpapi.GobgpApi/SoftResetRpki", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobgpApiClient) GetRoa(ctx context.Context, in *GetRoaRequest, opts ...grpc.CallOption) (*GetRoaResponse, error) {
	out := new(GetRoaResponse)
	err := grpc.Invoke(ctx, "/gobgpapi.GobgpApi/GetRoa", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobgpApiClient) EnableZebra(ctx context.Context, in *EnableZebraRequest, opts ...grpc.CallOption) (*EnableZebraResponse, error) {
	out := new(EnableZebraResponse)
	err := grpc.Invoke(ctx, "/gobgpapi.GobgpApi/EnableZebra", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobgpApiClient) AddVrf(ctx context.Context, in *AddVrfRequest, opts ...grpc.CallOption) (*AddVrfResponse, error) {
	out := new(AddVrfResponse)
	err := grpc.Invoke(ctx, "/gobgpapi.GobgpApi/AddVrf", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobgpApiClient) DeleteVrf(ctx context.Context, in *DeleteVrfRequest, opts ...grpc.CallOption) (*DeleteVrfResponse, error) {
	out := new(DeleteVrfResponse)
	err := grpc.Invoke(ctx, "/gobgpapi.GobgpApi/DeleteVrf", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobgpApiClient) GetVrf(ctx context.Context, in *GetVrfRequest, opts ...grpc.CallOption) (*GetVrfResponse, error) {
	out := new(GetVrfResponse)
	err := grpc.Invoke(ctx, "/gobgpapi.GobgpApi/GetVrf", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobgpApiClient) GetDefinedSet(ctx context.Context, in *GetDefinedSetRequest, opts ...grpc.CallOption) (*GetDefinedSetResponse, error) {
	out := new(GetDefinedSetResponse)
	err := grpc.Invoke(ctx, "/gobgpapi.GobgpApi/GetDefinedSet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobgpApiClient) AddDefinedSet(ctx context.Context, in *AddDefinedSetRequest, opts ...grpc.CallOption) (*AddDefinedSetResponse, error) {
	out := new(AddDefinedSetResponse)
	err := grpc.Invoke(ctx, "/gobgpapi.GobgpApi/AddDefinedSet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobgpApiClient) DeleteDefinedSet(ctx context.Context, in *DeleteDefinedSetRequest, opts ...grpc.CallOption) (*DeleteDefinedSetResponse, error) {
	out := new(DeleteDefinedSetResponse)
	err := grpc.Invoke(ctx, "/gobgpapi.GobgpApi/DeleteDefinedSet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobgpApiClient) ReplaceDefinedSet(ctx context.Context, in *ReplaceDefinedSetRequest, opts ...grpc.CallOption) (*ReplaceDefinedSetResponse, error) {
	out := new(ReplaceDefinedSetResponse)
	err := grpc.Invoke(ctx, "/gobgpapi.GobgpApi/ReplaceDefinedSet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobgpApiClient) GetStatement(ctx context.Context, in *GetStatementRequest, opts ...grpc.CallOption) (*GetStatementResponse, error) {
	out := new(GetStatementResponse)
	err := grpc.Invoke(ctx, "/gobgpapi.GobgpApi/GetStatement", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobgpApiClient) AddStatement(ctx context.Context, in *AddStatementRequest, opts ...grpc.CallOption) (*AddStatementResponse, error) {
	out := new(AddStatementResponse)
	err := grpc.Invoke(ctx, "/gobgpapi.GobgpApi/AddStatement", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobgpApiClient) DeleteStatement(ctx context.Context, in *DeleteStatementRequest, opts ...grpc.CallOption) (*DeleteStatementResponse, error) {
	out := new(DeleteStatementResponse)
	err := grpc.Invoke(ctx, "/gobgpapi.GobgpApi/DeleteStatement", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobgpApiClient) ReplaceStatement(ctx context.Context, in *ReplaceStatementRequest, opts ...grpc.CallOption) (*ReplaceStatementResponse, error) {
	out := new(ReplaceStatementResponse)
	err := grpc.Invoke(ctx, "/gobgpapi.GobgpApi/ReplaceStatement", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobgpApiClient) GetPolicy(ctx context.Context, in *GetPolicyRequest, opts ...grpc.CallOption) (*GetPolicyResponse, error) {
	out := new(GetPolicyResponse)
	err := grpc.Invoke(ctx, "/gobgpapi.GobgpApi/GetPolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobgpApiClient) AddPolicy(ctx context.Context, in *AddPolicyRequest, opts ...grpc.CallOption) (*AddPolicyResponse, error) {
	out := new(AddPolicyResponse)
	err := grpc.Invoke(ctx, "/gobgpapi.GobgpApi/AddPolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobgpApiClient) DeletePolicy(ctx context.Context, in *DeletePolicyRequest, opts ...grpc.CallOption) (*DeletePolicyResponse, error) {
	out := new(DeletePolicyResponse)
	err := grpc.Invoke(ctx, "/gobgpapi.GobgpApi/DeletePolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobgpApiClient) ReplacePolicy(ctx context.Context, in *ReplacePolicyRequest, opts ...grpc.CallOption) (*ReplacePolicyResponse, error) {
	out := new(ReplacePolicyResponse)
	err := grpc.Invoke(ctx, "/gobgpapi.GobgpApi/ReplacePolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobgpApiClient) UpdatePolicy(ctx context.Context, in *UpdatePolicyRequest, opts ...grpc.CallOption) (*UpdatePolicyResponse, error) {
	out := new(UpdatePolicyResponse)
	err := grpc.Invoke(ctx, "/gobgpapi.GobgpApi/UpdatePolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobgpApiClient) GetPolicyAssignment(ctx context.Context, in *GetPolicyAssignmentRequest, opts ...grpc.CallOption) (*GetPolicyAssignmentResponse, error) {
	out := new(GetPolicyAssignmentResponse)
	err := grpc.Invoke(ctx, "/gobgpapi.GobgpApi/GetPolicyAssignment", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobgpApiClient) AddPolicyAssignment(ctx context.Context, in *AddPolicyAssignmentRequest, opts ...grpc.CallOption) (*AddPolicyAssignmentResponse, error) {
	out := new(AddPolicyAssignmentResponse)
	err := grpc.Invoke(ctx, "/gobgpapi.GobgpApi/AddPolicyAssignment", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobgpApiClient) DeletePolicyAssignment(ctx context.Context, in *DeletePolicyAssignmentRequest, opts ...grpc.CallOption) (*DeletePolicyAssignmentResponse, error) {
	out := new(DeletePolicyAssignmentResponse)
	err := grpc.Invoke(ctx, "/gobgpapi.GobgpApi/DeletePolicyAssignment", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobgpApiClient) ReplacePolicyAssignment(ctx context.Context, in *ReplacePolicyAssignmentRequest, opts ...grpc.CallOption) (*ReplacePolicyAssignmentResponse, error) {
	out := new(ReplacePolicyAssignmentResponse)
	err := grpc.Invoke(ctx, "/gobgpapi.GobgpApi/ReplacePolicyAssignment", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobgpApiClient) GetRibInfo(ctx context.Context, in *GetRibInfoRequest, opts ...grpc.CallOption) (*GetRibInfoResponse, error) {
	out := new(GetRibInfoResponse)
	err := grpc.Invoke(ctx, "/gobgpapi.GobgpApi/GetRibInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobgpApiClient) AddPeerGroup(ctx context.Context, in *AddPeerGroupRequest, opts ...grpc.CallOption) (*AddPeerGroupResponse, error) {
	out := new(AddPeerGroupResponse)
	err := grpc.Invoke(ctx, "/gobgpapi.GobgpApi/AddPeerGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobgpApiClient) DeletePeerGroup(ctx context.Context, in *DeletePeerGroupRequest, opts ...grpc.CallOption) (*DeletePeerGroupResponse, error) {
	out := new(DeletePeerGroupResponse)
	err := grpc.Invoke(ctx, "/gobgpapi.GobgpApi/DeletePeerGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobgpApiClient) UpdatePeerGroup(ctx context.Context, in *UpdatePeerGroupRequest, opts ...grpc.CallOption) (*UpdatePeerGroupResponse, error) {
	out := new(UpdatePeerGroupResponse)
	err := grpc.Invoke(ctx, "/gobgpapi.GobgpApi/UpdatePeerGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobgpApiClient) AddDynamicNeighbor(ctx context.Context, in *AddDynamicNeighborRequest, opts ...grpc.CallOption) (*AddDynamicNeighborResponse, error) {
	out := new(AddDynamicNeighborResponse)
	err := grpc.Invoke(ctx, "/gobgpapi.GobgpApi/AddDynamicNeighbor", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobgpApiClient) AddCollector(ctx context.Context, in *AddCollectorRequest, opts ...grpc.CallOption) (*AddCollectorResponse, error) {
	out := new(AddCollectorResponse)
	err := grpc.Invoke(ctx, "/gobgpapi.GobgpApi/AddCollector", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobgpApiClient) Shutdown(ctx context.Context, in *ShutdownRequest, opts ...grpc.CallOption) (*ShutdownResponse, error) {
	out := new(ShutdownResponse)
	err := grpc.Invoke(ctx, "/gobgpapi.GobgpApi/Shutdown", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for GobgpApi service

type GobgpApiServer interface {
	StartServer(context.Context, *StartServerRequest) (*StartServerResponse, error)
	StopServer(context.Context, *StopServerRequest) (*StopServerResponse, error)
	GetServer(context.Context, *GetServerRequest) (*GetServerResponse, error)
	AddNeighbor(context.Context, *AddNeighborRequest) (*AddNeighborResponse, error)
	DeleteNeighbor(context.Context, *DeleteNeighborRequest) (*DeleteNeighborResponse, error)
	UpdateNeighbor(context.Context, *UpdateNeighborRequest) (*UpdateNeighborResponse, error)
	GetNeighbor(context.Context, *GetNeighborRequest) (*GetNeighborResponse, error)
	ResetNeighbor(context.Context, *ResetNeighborRequest) (*ResetNeighborResponse, error)
	SoftResetNeighbor(context.Context, *SoftResetNeighborRequest) (*SoftResetNeighborResponse, error)
	ShutdownNeighbor(context.Context, *ShutdownNeighborRequest) (*ShutdownNeighborResponse, error)
	EnableNeighbor(context.Context, *EnableNeighborRequest) (*EnableNeighborResponse, error)
	DisableNeighbor(context.Context, *DisableNeighborRequest) (*DisableNeighborResponse, error)
	GetRib(context.Context, *GetRibRequest) (*GetRibResponse, error)
	GetPath(*GetPathRequest, GobgpApi_GetPathServer) error
	ValidateRib(context.Context, *ValidateRibRequest) (*ValidateRibResponse, error)
	AddPath(context.Context, *AddPathRequest) (*AddPathResponse, error)
	DeletePath(context.Context, *DeletePathRequest) (*DeletePathResponse, error)
	MonitorRib(*MonitorRibRequest, GobgpApi_MonitorRibServer) error
	MonitorPeerState(*Arguments, GobgpApi_MonitorPeerStateServer) error
	EnableMrt(context.Context, *EnableMrtRequest) (*EnableMrtResponse, error)
	DisableMrt(context.Context, *DisableMrtRequest) (*DisableMrtResponse, error)
	InjectMrt(GobgpApi_InjectMrtServer) error
	AddBmp(context.Context, *AddBmpRequest) (*AddBmpResponse, error)
	DeleteBmp(context.Context, *DeleteBmpRequest) (*DeleteBmpResponse, error)
	GetRpki(context.Context, *GetRpkiRequest) (*GetRpkiResponse, error)
	AddRpki(context.Context, *AddRpkiRequest) (*AddRpkiResponse, error)
	DeleteRpki(context.Context, *DeleteRpkiRequest) (*DeleteRpkiResponse, error)
	EnableRpki(context.Context, *EnableRpkiRequest) (*EnableRpkiResponse, error)
	DisableRpki(context.Context, *DisableRpkiRequest) (*DisableRpkiResponse, error)
	ResetRpki(context.Context, *ResetRpkiRequest) (*ResetRpkiResponse, error)
	SoftResetRpki(context.Context, *SoftResetRpkiRequest) (*SoftResetRpkiResponse, error)
	GetRoa(context.Context, *GetRoaRequest) (*GetRoaResponse, error)
	EnableZebra(context.Context, *EnableZebraRequest) (*EnableZebraResponse, error)
	AddVrf(context.Context, *AddVrfRequest) (*AddVrfResponse, error)
	DeleteVrf(context.Context, *DeleteVrfRequest) (*DeleteVrfResponse, error)
	GetVrf(context.Context, *GetVrfRequest) (*GetVrfResponse, error)
	GetDefinedSet(context.Context, *GetDefinedSetRequest) (*GetDefinedSetResponse, error)
	AddDefinedSet(context.Context, *AddDefinedSetRequest) (*AddDefinedSetResponse, error)
	DeleteDefinedSet(context.Context, *DeleteDefinedSetRequest) (*DeleteDefinedSetResponse, error)
	ReplaceDefinedSet(context.Context, *ReplaceDefinedSetRequest) (*ReplaceDefinedSetResponse, error)
	GetStatement(context.Context, *GetStatementRequest) (*GetStatementResponse, error)
	AddStatement(context.Context, *AddStatementRequest) (*AddStatementResponse, error)
	DeleteStatement(context.Context, *DeleteStatementRequest) (*DeleteStatementResponse, error)
	ReplaceStatement(context.Context, *ReplaceStatementRequest) (*ReplaceStatementResponse, error)
	GetPolicy(context.Context, *GetPolicyRequest) (*GetPolicyResponse, error)
	AddPolicy(context.Context, *AddPolicyRequest) (*AddPolicyResponse, error)
	DeletePolicy(context.Context, *DeletePolicyRequest) (*DeletePolicyResponse, error)
	ReplacePolicy(context.Context, *ReplacePolicyRequest) (*ReplacePolicyResponse, error)
	UpdatePolicy(context.Context, *UpdatePolicyRequest) (*UpdatePolicyResponse, error)
	GetPolicyAssignment(context.Context, *GetPolicyAssignmentRequest) (*GetPolicyAssignmentResponse, error)
	AddPolicyAssignment(context.Context, *AddPolicyAssignmentRequest) (*AddPolicyAssignmentResponse, error)
	DeletePolicyAssignment(context.Context, *DeletePolicyAssignmentRequest) (*DeletePolicyAssignmentResponse, error)
	ReplacePolicyAssignment(context.Context, *ReplacePolicyAssignmentRequest) (*ReplacePolicyAssignmentResponse, error)
	GetRibInfo(context.Context, *GetRibInfoRequest) (*GetRibInfoResponse, error)
	AddPeerGroup(context.Context, *AddPeerGroupRequest) (*AddPeerGroupResponse, error)
	DeletePeerGroup(context.Context, *DeletePeerGroupRequest) (*DeletePeerGroupResponse, error)
	UpdatePeerGroup(context.Context, *UpdatePeerGroupRequest) (*UpdatePeerGroupResponse, error)
	AddDynamicNeighbor(context.Context, *AddDynamicNeighborRequest) (*AddDynamicNeighborResponse, error)
	AddCollector(context.Context, *AddCollectorRequest) (*AddCollectorResponse, error)
	Shutdown(context.Context, *ShutdownRequest) (*ShutdownResponse, error)
}

func RegisterGobgpApiServer(s *grpc.Server, srv GobgpApiServer) {
	s.RegisterService(&_GobgpApi_serviceDesc, srv)
}

func _GobgpApi_StartServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartServerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobgpApiServer).StartServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gobgpapi.GobgpApi/StartServer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobgpApiServer).StartServer(ctx, req.(*StartServerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobgpApi_StopServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopServerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobgpApiServer).StopServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gobgpapi.GobgpApi/StopServer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobgpApiServer).StopServer(ctx, req.(*StopServerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobgpApi_GetServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetServerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobgpApiServer).GetServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gobgpapi.GobgpApi/GetServer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobgpApiServer).GetServer(ctx, req.(*GetServerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobgpApi_AddNeighbor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddNeighborRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobgpApiServer).AddNeighbor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gobgpapi.GobgpApi/AddNeighbor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobgpApiServer).AddNeighbor(ctx, req.(*AddNeighborRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobgpApi_DeleteNeighbor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteNeighborRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobgpApiServer).DeleteNeighbor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gobgpapi.GobgpApi/DeleteNeighbor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobgpApiServer).DeleteNeighbor(ctx, req.(*DeleteNeighborRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobgpApi_UpdateNeighbor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateNeighborRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobgpApiServer).UpdateNeighbor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gobgpapi.GobgpApi/UpdateNeighbor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobgpApiServer).UpdateNeighbor(ctx, req.(*UpdateNeighborRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobgpApi_GetNeighbor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNeighborRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobgpApiServer).GetNeighbor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gobgpapi.GobgpApi/GetNeighbor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobgpApiServer).GetNeighbor(ctx, req.(*GetNeighborRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobgpApi_ResetNeighbor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetNeighborRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobgpApiServer).ResetNeighbor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gobgpapi.GobgpApi/ResetNeighbor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobgpApiServer).ResetNeighbor(ctx, req.(*ResetNeighborRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobgpApi_SoftResetNeighbor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SoftResetNeighborRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobgpApiServer).SoftResetNeighbor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gobgpapi.GobgpApi/SoftResetNeighbor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobgpApiServer).SoftResetNeighbor(ctx, req.(*SoftResetNeighborRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobgpApi_ShutdownNeighbor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShutdownNeighborRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobgpApiServer).ShutdownNeighbor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gobgpapi.GobgpApi/ShutdownNeighbor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobgpApiServer).ShutdownNeighbor(ctx, req.(*ShutdownNeighborRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobgpApi_EnableNeighbor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnableNeighborRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobgpApiServer).EnableNeighbor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gobgpapi.GobgpApi/EnableNeighbor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobgpApiServer).EnableNeighbor(ctx, req.(*EnableNeighborRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobgpApi_DisableNeighbor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisableNeighborRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobgpApiServer).DisableNeighbor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gobgpapi.GobgpApi/DisableNeighbor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobgpApiServer).DisableNeighbor(ctx, req.(*DisableNeighborRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobgpApi_GetRib_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRibRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobgpApiServer).GetRib(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gobgpapi.GobgpApi/GetRib",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobgpApiServer).GetRib(ctx, req.(*GetRibRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobgpApi_GetPath_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetPathRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GobgpApiServer).GetPath(m, &gobgpApiGetPathServer{stream})
}

type GobgpApi_GetPathServer interface {
	Send(*Path) error
	grpc.ServerStream
}

type gobgpApiGetPathServer struct {
	grpc.ServerStream
}

func (x *gobgpApiGetPathServer) Send(m *Path) error {
	return x.ServerStream.SendMsg(m)
}

func _GobgpApi_ValidateRib_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateRibRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobgpApiServer).ValidateRib(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gobgpapi.GobgpApi/ValidateRib",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobgpApiServer).ValidateRib(ctx, req.(*ValidateRibRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobgpApi_AddPath_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddPathRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobgpApiServer).AddPath(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gobgpapi.GobgpApi/AddPath",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobgpApiServer).AddPath(ctx, req.(*AddPathRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobgpApi_DeletePath_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletePathRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobgpApiServer).DeletePath(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gobgpapi.GobgpApi/DeletePath",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobgpApiServer).DeletePath(ctx, req.(*DeletePathRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobgpApi_MonitorRib_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(MonitorRibRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GobgpApiServer).MonitorRib(m, &gobgpApiMonitorRibServer{stream})
}

type GobgpApi_MonitorRibServer interface {
	Send(*Destination) error
	grpc.ServerStream
}

type gobgpApiMonitorRibServer struct {
	grpc.ServerStream
}

func (x *gobgpApiMonitorRibServer) Send(m *Destination) error {
	return x.ServerStream.SendMsg(m)
}

func _GobgpApi_MonitorPeerState_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Arguments)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GobgpApiServer).MonitorPeerState(m, &gobgpApiMonitorPeerStateServer{stream})
}

type GobgpApi_MonitorPeerStateServer interface {
	Send(*Peer) error
	grpc.ServerStream
}

type gobgpApiMonitorPeerStateServer struct {
	grpc.ServerStream
}

func (x *gobgpApiMonitorPeerStateServer) Send(m *Peer) error {
	return x.ServerStream.SendMsg(m)
}

func _GobgpApi_EnableMrt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnableMrtRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobgpApiServer).EnableMrt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gobgpapi.GobgpApi/EnableMrt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobgpApiServer).EnableMrt(ctx, req.(*EnableMrtRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobgpApi_DisableMrt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisableMrtRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobgpApiServer).DisableMrt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gobgpapi.GobgpApi/DisableMrt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobgpApiServer).DisableMrt(ctx, req.(*DisableMrtRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobgpApi_InjectMrt_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GobgpApiServer).InjectMrt(&gobgpApiInjectMrtServer{stream})
}

type GobgpApi_InjectMrtServer interface {
	SendAndClose(*InjectMrtResponse) error
	Recv() (*InjectMrtRequest, error)
	grpc.ServerStream
}

type gobgpApiInjectMrtServer struct {
	grpc.ServerStream
}

func (x *gobgpApiInjectMrtServer) SendAndClose(m *InjectMrtResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *gobgpApiInjectMrtServer) Recv() (*InjectMrtRequest, error) {
	m := new(InjectMrtRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _GobgpApi_AddBmp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddBmpRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobgpApiServer).AddBmp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gobgpapi.GobgpApi/AddBmp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobgpApiServer).AddBmp(ctx, req.(*AddBmpRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobgpApi_DeleteBmp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteBmpRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobgpApiServer).DeleteBmp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gobgpapi.GobgpApi/DeleteBmp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobgpApiServer).DeleteBmp(ctx, req.(*DeleteBmpRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobgpApi_GetRpki_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRpkiRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobgpApiServer).GetRpki(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gobgpapi.GobgpApi/GetRpki",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobgpApiServer).GetRpki(ctx, req.(*GetRpkiRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobgpApi_AddRpki_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddRpkiRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobgpApiServer).AddRpki(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gobgpapi.GobgpApi/AddRpki",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobgpApiServer).AddRpki(ctx, req.(*AddRpkiRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobgpApi_DeleteRpki_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRpkiRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobgpApiServer).DeleteRpki(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gobgpapi.GobgpApi/DeleteRpki",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobgpApiServer).DeleteRpki(ctx, req.(*DeleteRpkiRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobgpApi_EnableRpki_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnableRpkiRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobgpApiServer).EnableRpki(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gobgpapi.GobgpApi/EnableRpki",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobgpApiServer).EnableRpki(ctx, req.(*EnableRpkiRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobgpApi_DisableRpki_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisableRpkiRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobgpApiServer).DisableRpki(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gobgpapi.GobgpApi/DisableRpki",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobgpApiServer).DisableRpki(ctx, req.(*DisableRpkiRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobgpApi_ResetRpki_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetRpkiRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobgpApiServer).ResetRpki(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gobgpapi.GobgpApi/ResetRpki",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobgpApiServer).ResetRpki(ctx, req.(*ResetRpkiRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobgpApi_SoftResetRpki_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SoftResetRpkiRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobgpApiServer).SoftResetRpki(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gobgpapi.GobgpApi/SoftResetRpki",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobgpApiServer).SoftResetRpki(ctx, req.(*SoftResetRpkiRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobgpApi_GetRoa_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRoaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobgpApiServer).GetRoa(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gobgpapi.GobgpApi/GetRoa",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobgpApiServer).GetRoa(ctx, req.(*GetRoaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobgpApi_EnableZebra_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnableZebraRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobgpApiServer).EnableZebra(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gobgpapi.GobgpApi/EnableZebra",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobgpApiServer).EnableZebra(ctx, req.(*EnableZebraRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobgpApi_AddVrf_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddVrfRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobgpApiServer).AddVrf(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gobgpapi.GobgpApi/AddVrf",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobgpApiServer).AddVrf(ctx, req.(*AddVrfRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobgpApi_DeleteVrf_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteVrfRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobgpApiServer).DeleteVrf(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gobgpapi.GobgpApi/DeleteVrf",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobgpApiServer).DeleteVrf(ctx, req.(*DeleteVrfRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobgpApi_GetVrf_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVrfRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobgpApiServer).GetVrf(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gobgpapi.GobgpApi/GetVrf",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobgpApiServer).GetVrf(ctx, req.(*GetVrfRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobgpApi_GetDefinedSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDefinedSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobgpApiServer).GetDefinedSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gobgpapi.GobgpApi/GetDefinedSet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobgpApiServer).GetDefinedSet(ctx, req.(*GetDefinedSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobgpApi_AddDefinedSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddDefinedSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobgpApiServer).AddDefinedSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gobgpapi.GobgpApi/AddDefinedSet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobgpApiServer).AddDefinedSet(ctx, req.(*AddDefinedSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobgpApi_DeleteDefinedSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteDefinedSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobgpApiServer).DeleteDefinedSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gobgpapi.GobgpApi/DeleteDefinedSet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobgpApiServer).DeleteDefinedSet(ctx, req.(*DeleteDefinedSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobgpApi_ReplaceDefinedSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReplaceDefinedSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobgpApiServer).ReplaceDefinedSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gobgpapi.GobgpApi/ReplaceDefinedSet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobgpApiServer).ReplaceDefinedSet(ctx, req.(*ReplaceDefinedSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobgpApi_GetStatement_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStatementRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobgpApiServer).GetStatement(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gobgpapi.GobgpApi/GetStatement",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobgpApiServer).GetStatement(ctx, req.(*GetStatementRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobgpApi_AddStatement_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddStatementRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobgpApiServer).AddStatement(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gobgpapi.GobgpApi/AddStatement",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobgpApiServer).AddStatement(ctx, req.(*AddStatementRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobgpApi_DeleteStatement_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteStatementRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobgpApiServer).DeleteStatement(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gobgpapi.GobgpApi/DeleteStatement",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobgpApiServer).DeleteStatement(ctx, req.(*DeleteStatementRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobgpApi_ReplaceStatement_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReplaceStatementRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobgpApiServer).ReplaceStatement(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gobgpapi.GobgpApi/ReplaceStatement",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobgpApiServer).ReplaceStatement(ctx, req.(*ReplaceStatementRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobgpApi_GetPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobgpApiServer).GetPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gobgpapi.GobgpApi/GetPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobgpApiServer).GetPolicy(ctx, req.(*GetPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobgpApi_AddPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobgpApiServer).AddPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gobgpapi.GobgpApi/AddPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobgpApiServer).AddPolicy(ctx, req.(*AddPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobgpApi_DeletePolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletePolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobgpApiServer).DeletePolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gobgpapi.GobgpApi/DeletePolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobgpApiServer).DeletePolicy(ctx, req.(*DeletePolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobgpApi_ReplacePolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReplacePolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobgpApiServer).ReplacePolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gobgpapi.GobgpApi/ReplacePolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobgpApiServer).ReplacePolicy(ctx, req.(*ReplacePolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobgpApi_UpdatePolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobgpApiServer).UpdatePolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gobgpapi.GobgpApi/UpdatePolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobgpApiServer).UpdatePolicy(ctx, req.(*UpdatePolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobgpApi_GetPolicyAssignment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPolicyAssignmentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobgpApiServer).GetPolicyAssignment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gobgpapi.GobgpApi/GetPolicyAssignment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobgpApiServer).GetPolicyAssignment(ctx, req.(*GetPolicyAssignmentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobgpApi_AddPolicyAssignment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddPolicyAssignmentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobgpApiServer).AddPolicyAssignment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gobgpapi.GobgpApi/AddPolicyAssignment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobgpApiServer).AddPolicyAssignment(ctx, req.(*AddPolicyAssignmentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobgpApi_DeletePolicyAssignment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletePolicyAssignmentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobgpApiServer).DeletePolicyAssignment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gobgpapi.GobgpApi/DeletePolicyAssignment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobgpApiServer).DeletePolicyAssignment(ctx, req.(*DeletePolicyAssignmentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobgpApi_ReplacePolicyAssignment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReplacePolicyAssignmentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobgpApiServer).ReplacePolicyAssignment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gobgpapi.GobgpApi/ReplacePolicyAssignment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobgpApiServer).ReplacePolicyAssignment(ctx, req.(*ReplacePolicyAssignmentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobgpApi_GetRibInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRibInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobgpApiServer).GetRibInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gobgpapi.GobgpApi/GetRibInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobgpApiServer).GetRibInfo(ctx, req.(*GetRibInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobgpApi_AddPeerGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddPeerGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobgpApiServer).AddPeerGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gobgpapi.GobgpApi/AddPeerGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobgpApiServer).AddPeerGroup(ctx, req.(*AddPeerGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobgpApi_DeletePeerGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletePeerGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobgpApiServer).DeletePeerGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gobgpapi.GobgpApi/DeletePeerGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobgpApiServer).DeletePeerGroup(ctx, req.(*DeletePeerGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobgpApi_UpdatePeerGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePeerGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobgpApiServer).UpdatePeerGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gobgpapi.GobgpApi/UpdatePeerGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobgpApiServer).UpdatePeerGroup(ctx, req.(*UpdatePeerGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobgpApi_AddDynamicNeighbor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddDynamicNeighborRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobgpApiServer).AddDynamicNeighbor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gobgpapi.GobgpApi/AddDynamicNeighbor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobgpApiServer).AddDynamicNeighbor(ctx, req.(*AddDynamicNeighborRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobgpApi_AddCollector_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddCollectorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobgpApiServer).AddCollector(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gobgpapi.GobgpApi/AddCollector",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobgpApiServer).AddCollector(ctx, req.(*AddCollectorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobgpApi_Shutdown_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShutdownRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobgpApiServer).Shutdown(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gobgpapi.GobgpApi/Shutdown",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobgpApiServer).Shutdown(ctx, req.(*ShutdownRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _GobgpApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "gobgpapi.GobgpApi",
	HandlerType: (*GobgpApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StartServer",
			Handler:    _GobgpApi_StartServer_Handler,
		},
		{
			MethodName: "StopServer",
			Handler:    _GobgpApi_StopServer_Handler,
		},
		{
			MethodName: "GetServer",
			Handler:    _GobgpApi_GetServer_Handler,
		},
		{
			MethodName: "AddNeighbor",
			Handler:    _GobgpApi_AddNeighbor_Handler,
		},
		{
			MethodName: "DeleteNeighbor",
			Handler:    _GobgpApi_DeleteNeighbor_Handler,
		},
		{
			MethodName: "UpdateNeighbor",
			Handler:    _GobgpApi_UpdateNeighbor_Handler,
		},
		{
			MethodName: "GetNeighbor",
			Handler:    _GobgpApi_GetNeighbor_Handler,
		},
		{
			MethodName: "ResetNeighbor",
			Handler:    _GobgpApi_ResetNeighbor_Handler,
		},
		{
			MethodName: "SoftResetNeighbor",
			Handler:    _GobgpApi_SoftResetNeighbor_Handler,
		},
		{
			MethodName: "ShutdownNeighbor",
			Handler:    _GobgpApi_ShutdownNeighbor_Handler,
		},
		{
			MethodName: "EnableNeighbor",
			Handler:    _GobgpApi_EnableNeighbor_Handler,
		},
		{
			MethodName: "DisableNeighbor",
			Handler:    _GobgpApi_DisableNeighbor_Handler,
		},
		{
			MethodName: "GetRib",
			Handler:    _GobgpApi_GetRib_Handler,
		},
		{
			MethodName: "ValidateRib",
			Handler:    _GobgpApi_ValidateRib_Handler,
		},
		{
			MethodName: "AddPath",
			Handler:    _GobgpApi_AddPath_Handler,
		},
		{
			MethodName: "DeletePath",
			Handler:    _GobgpApi_DeletePath_Handler,
		},
		{
			MethodName: "EnableMrt",
			Handler:    _GobgpApi_EnableMrt_Handler,
		},
		{
			MethodName: "DisableMrt",
			Handler:    _GobgpApi_DisableMrt_Handler,
		},
		{
			MethodName: "AddBmp",
			Handler:    _GobgpApi_AddBmp_Handler,
		},
		{
			MethodName: "DeleteBmp",
			Handler:    _GobgpApi_DeleteBmp_Handler,
		},
		{
			MethodName: "GetRpki",
			Handler:    _GobgpApi_GetRpki_Handler,
		},
		{
			MethodName: "AddRpki",
			Handler:    _GobgpApi_AddRpki_Handler,
		},
		{
			MethodName: "DeleteRpki",
			Handler:    _GobgpApi_DeleteRpki_Handler,
		},
		{
			MethodName: "EnableRpki",
			Handler:    _GobgpApi_EnableRpki_Handler,
		},
		{
			MethodName: "DisableRpki",
			Handler:    _GobgpApi_DisableRpki_Handler,
		},
		{
			MethodName: "ResetRpki",
			Handler:    _GobgpApi_ResetRpki_Handler,
		},
		{
			MethodName: "SoftResetRpki",
			Handler:    _GobgpApi_SoftResetRpki_Handler,
		},
		{
			MethodName: "GetRoa",
			Handler:    _GobgpApi_GetRoa_Handler,
		},
		{
			MethodName: "EnableZebra",
			Handler:    _GobgpApi_EnableZebra_Handler,
		},
		{
			MethodName: "AddVrf",
			Handler:    _GobgpApi_AddVrf_Handler,
		},
		{
			MethodName: "DeleteVrf",
			Handler:    _GobgpApi_DeleteVrf_Handler,
		},
		{
			MethodName: "GetVrf",
			Handler:    _GobgpApi_GetVrf_Handler,
		},
		{
			MethodName: "GetDefinedSet",
			Handler:    _GobgpApi_GetDefinedSet_Handler,
		},
		{
			MethodName: "AddDefinedSet",
			Handler:    _GobgpApi_AddDefinedSet_Handler,
		},
		{
			MethodName: "DeleteDefinedSet",
			Handler:    _GobgpApi_DeleteDefinedSet_Handler,
		},
		{
			MethodName: "ReplaceDefinedSet",
			Handler:    _GobgpApi_ReplaceDefinedSet_Handler,
		},
		{
			MethodName: "GetStatement",
			Handler:    _GobgpApi_GetStatement_Handler,
		},
		{
			MethodName: "AddStatement",
			Handler:    _GobgpApi_AddStatement_Handler,
		},
		{
			MethodName: "DeleteStatement",
			Handler:    _GobgpApi_DeleteStatement_Handler,
		},
		{
			MethodName: "ReplaceStatement",
			Handler:    _GobgpApi_ReplaceStatement_Handler,
		},
		{
			MethodName: "GetPolicy",
			Handler:    _GobgpApi_GetPolicy_Handler,
		},
		{
			MethodName: "AddPolicy",
			Handler:    _GobgpApi_AddPolicy_Handler,
		},
		{
			MethodName: "DeletePolicy",
			Handler:    _GobgpApi_DeletePolicy_Handler,
		},
		{
			MethodName: "ReplacePolicy",
			Handler:    _GobgpApi_ReplacePolicy_Handler,
		},
		{
			MethodName: "UpdatePolicy",
			Handler:    _GobgpApi_UpdatePolicy_Handler,
		},
		{
			MethodName: "GetPolicyAssignment",
			Handler:    _GobgpApi_GetPolicyAssignment_Handler,
		},
		{
			MethodName: "AddPolicyAssignment",
			Handler:    _GobgpApi_AddPolicyAssignment_Handler,
		},
		{
			MethodName: "DeletePolicyAssignment",
			Handler:    _GobgpApi_DeletePolicyAssignment_Handler,
		},
		{
			MethodName: "ReplacePolicyAssignment",
			Handler:    _GobgpApi_ReplacePolicyAssignment_Handler,
		},
		{
			MethodName: "GetRibInfo",
			Handler:    _GobgpApi_GetRibInfo_Handler,
		},
		{
			MethodName: "AddPeerGroup",
			Handler:    _GobgpApi_AddPeerGroup_Handler,
		},
		{
			MethodName: "DeletePeerGroup",
			Handler:    _GobgpApi_DeletePeerGroup_Handler,
		},
		{
			MethodName: "UpdatePeerGroup",
			Handler:    _GobgpApi_UpdatePeerGroup_Handler,
		},
		{
			MethodName: "AddDynamicNeighbor",
			Handler:    _GobgpApi_AddDynamicNeighbor_Handler,
		},
		{
			MethodName: "AddCollector",
			Handler:    _GobgpApi_AddCollector_Handler,
		},
		{
			MethodName: "Shutdown",
			Handler:    _GobgpApi_Shutdown_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetPath",
			Handler:       _GobgpApi_GetPath_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "MonitorRib",
			Handler:       _GobgpApi_MonitorRib_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "MonitorPeerState",
			Handler:       _GobgpApi_MonitorPeerState_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "InjectMrt",
			Handler:       _GobgpApi_InjectMrt_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "gobgp.proto",
}

func (m *GetNeighborRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetNeighborRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EnableAdvertised {
		dAtA[i] = 0x8
		i++
		if m.EnableAdvertised {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Address) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	return i, nil
}

func (m *GetNeighborResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetNeighborResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Peers) > 0 {
		for _, msg := range m.Peers {
			dAtA[i] = 0xa
			i++
			i = encodeVarintGobgp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Arguments) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Arguments) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Resource != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Resource))
	}
	if m.Family != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Family))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Current {
		dAtA[i] = 0x20
		i++
		if m.Current {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *AddPathRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddPathRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Resource != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Resource))
	}
	if len(m.VrfId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.VrfId)))
		i += copy(dAtA[i:], m.VrfId)
	}
	if m.Path != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Path.Size()))
		n1, err := m.Path.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *AddPathResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddPathResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	return i, nil
}

func (m *DeletePathRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeletePathRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Resource != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Resource))
	}
	if len(m.VrfId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.VrfId)))
		i += copy(dAtA[i:], m.VrfId)
	}
	if m.Family != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Family))
	}
	if m.Path != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Path.Size()))
		n2, err := m.Path.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.Uuid) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	return i, nil
}

func (m *DeletePathResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeletePathResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *AddNeighborRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddNeighborRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Peer != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Peer.Size()))
		n3, err := m.Peer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *AddNeighborResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddNeighborResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *DeleteNeighborRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteNeighborRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Peer != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Peer.Size()))
		n4, err := m.Peer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *DeleteNeighborResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteNeighborResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *UpdateNeighborRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateNeighborRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Peer != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Peer.Size()))
		n5, err := m.Peer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.DoSoftResetIn {
		dAtA[i] = 0x10
		i++
		if m.DoSoftResetIn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *UpdateNeighborResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateNeighborResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NeedsSoftResetIn {
		dAtA[i] = 0x8
		i++
		if m.NeedsSoftResetIn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *AddPeerGroupRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddPeerGroupRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PeerGroup != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.PeerGroup.Size()))
		n6, err := m.PeerGroup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *AddPeerGroupResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddPeerGroupResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *DeletePeerGroupRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeletePeerGroupRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PeerGroup != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.PeerGroup.Size()))
		n7, err := m.PeerGroup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *DeletePeerGroupResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeletePeerGroupResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *UpdatePeerGroupRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdatePeerGroupRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PeerGroup != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.PeerGroup.Size()))
		n8, err := m.PeerGroup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.DoSoftResetIn {
		dAtA[i] = 0x10
		i++
		if m.DoSoftResetIn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *UpdatePeerGroupResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdatePeerGroupResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NeedsSoftResetIn {
		dAtA[i] = 0x8
		i++
		if m.NeedsSoftResetIn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *AddDynamicNeighborRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddDynamicNeighborRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DynamicNeighbor != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.DynamicNeighbor.Size()))
		n9, err := m.DynamicNeighbor.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}

func (m *AddDynamicNeighborResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddDynamicNeighborResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ResetNeighborRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResetNeighborRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if len(m.Communication) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.Communication)))
		i += copy(dAtA[i:], m.Communication)
	}
	return i, nil
}

func (m *ResetNeighborResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResetNeighborResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *SoftResetNeighborRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SoftResetNeighborRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if m.Direction != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Direction))
	}
	return i, nil
}

func (m *SoftResetNeighborResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SoftResetNeighborResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ShutdownNeighborRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShutdownNeighborRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if len(m.Communication) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.Communication)))
		i += copy(dAtA[i:], m.Communication)
	}
	return i, nil
}

func (m *ShutdownNeighborResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShutdownNeighborResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *EnableNeighborRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnableNeighborRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	return i, nil
}

func (m *EnableNeighborResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnableNeighborResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *DisableNeighborRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DisableNeighborRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if len(m.Communication) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.Communication)))
		i += copy(dAtA[i:], m.Communication)
	}
	return i, nil
}

func (m *DisableNeighborResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DisableNeighborResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *UpdatePolicyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdatePolicyRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Sets) > 0 {
		for _, msg := range m.Sets {
			dAtA[i] = 0xa
			i++
			i = encodeVarintGobgp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Policies) > 0 {
		for _, msg := range m.Policies {
			dAtA[i] = 0x12
			i++
			i = encodeVarintGobgp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *UpdatePolicyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdatePolicyResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *EnableMrtRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnableMrtRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DumpType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.DumpType))
	}
	if len(m.Filename) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.Filename)))
		i += copy(dAtA[i:], m.Filename)
	}
	if m.Interval != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Interval))
	}
	return i, nil
}

func (m *EnableMrtResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnableMrtResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *DisableMrtRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DisableMrtRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *DisableMrtResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DisableMrtResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *InjectMrtRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InjectMrtRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Resource != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Resource))
	}
	if len(m.VrfId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.VrfId)))
		i += copy(dAtA[i:], m.VrfId)
	}
	if len(m.Paths) > 0 {
		for _, msg := range m.Paths {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintGobgp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *InjectMrtResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InjectMrtResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *AddBmpRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddBmpRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if m.Port != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Port))
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Type))
	}
	return i, nil
}

func (m *AddBmpResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddBmpResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *DeleteBmpRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteBmpRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if m.Port != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Port))
	}
	return i, nil
}

func (m *DeleteBmpResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteBmpResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *MonitorRibRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MonitorRibRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Table != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Table.Size()))
		n10, err := m.Table.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.Current {
		dAtA[i] = 0x10
		i++
		if m.Current {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *RPKIConf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RPKIConf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if len(m.RemotePort) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.RemotePort)))
		i += copy(dAtA[i:], m.RemotePort)
	}
	return i, nil
}

func (m *RPKIState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RPKIState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uptime != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Uptime))
	}
	if m.Downtime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Downtime))
	}
	if m.Up {
		dAtA[i] = 0x18
		i++
		if m.Up {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RecordIpv4 != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.RecordIpv4))
	}
	if m.RecordIpv6 != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.RecordIpv6))
	}
	if m.PrefixIpv4 != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.PrefixIpv4))
	}
	if m.PrefixIpv6 != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.PrefixIpv6))
	}
	if m.Serial != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Serial))
	}
	if m.ReceivedIpv4 != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.ReceivedIpv4))
	}
	if m.ReceivedIpv6 != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.ReceivedIpv6))
	}
	if m.SerialNotify != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.SerialNotify))
	}
	if m.CacheReset != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.CacheReset))
	}
	if m.CacheResponse != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.CacheResponse))
	}
	if m.EndOfData != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.EndOfData))
	}
	if m.Error != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Error))
	}
	if m.SerialQuery != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.SerialQuery))
	}
	if m.ResetQuery != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.ResetQuery))
	}
	return i, nil
}

func (m *Rpki) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Rpki) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Conf != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Conf.Size()))
		n11, err := m.Conf.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.State != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.State.Size()))
		n12, err := m.State.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}

func (m *GetRpkiRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRpkiRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Family != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Family))
	}
	return i, nil
}

func (m *GetRpkiResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRpkiResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Servers) > 0 {
		for _, msg := range m.Servers {
			dAtA[i] = 0xa
			i++
			i = encodeVarintGobgp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AddRpkiRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddRpkiRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if m.Port != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Port))
	}
	if m.Lifetime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Lifetime))
	}
	return i, nil
}

func (m *AddRpkiResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddRpkiResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *DeleteRpkiRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteRpkiRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if m.Port != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Port))
	}
	return i, nil
}

func (m *DeleteRpkiResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteRpkiResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *EnableRpkiRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnableRpkiRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	return i, nil
}

func (m *EnableRpkiResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnableRpkiResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *DisableRpkiRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DisableRpkiRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	return i, nil
}

func (m *DisableRpkiResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DisableRpkiResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ResetRpkiRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResetRpkiRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	return i, nil
}

func (m *ResetRpkiResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResetRpkiResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *SoftResetRpkiRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SoftResetRpkiRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	return i, nil
}

func (m *SoftResetRpkiResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SoftResetRpkiResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *EnableZebraRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnableZebraRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Url) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	if len(m.RouteTypes) > 0 {
		for _, s := range m.RouteTypes {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Version != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Version))
	}
	if m.NexthopTriggerEnable {
		dAtA[i] = 0x20
		i++
		if m.NexthopTriggerEnable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.NexthopTriggerDelay != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.NexthopTriggerDelay))
	}
	return i, nil
}

func (m *EnableZebraResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnableZebraResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GetVrfRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetVrfRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GetVrfResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetVrfResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vrfs) > 0 {
		for _, msg := range m.Vrfs {
			dAtA[i] = 0xa
			i++
			i = encodeVarintGobgp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AddVrfRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddVrfRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Vrf != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Vrf.Size()))
		n13, err := m.Vrf.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}

func (m *AddVrfResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddVrfResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *DeleteVrfRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteVrfRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Vrf != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Vrf.Size()))
		n14, err := m.Vrf.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}

func (m *DeleteVrfResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteVrfResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GetDefinedSetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetDefinedSetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Type))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *GetDefinedSetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetDefinedSetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Sets) > 0 {
		for _, msg := range m.Sets {
			dAtA[i] = 0xa
			i++
			i = encodeVarintGobgp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AddDefinedSetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddDefinedSetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Set != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Set.Size()))
		n15, err := m.Set.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}

func (m *AddDefinedSetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddDefinedSetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *DeleteDefinedSetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteDefinedSetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Set != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Set.Size()))
		n16, err := m.Set.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.All {
		dAtA[i] = 0x10
		i++
		if m.All {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *DeleteDefinedSetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteDefinedSetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ReplaceDefinedSetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceDefinedSetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Set != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Set.Size()))
		n17, err := m.Set.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}

func (m *ReplaceDefinedSetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceDefinedSetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GetStatementRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetStatementRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GetStatementResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetStatementResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Statements) > 0 {
		for _, msg := range m.Statements {
			dAtA[i] = 0xa
			i++
			i = encodeVarintGobgp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AddStatementRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddStatementRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Statement != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Statement.Size()))
		n18, err := m.Statement.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}

func (m *AddStatementResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddStatementResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *DeleteStatementRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteStatementRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Statement != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Statement.Size()))
		n19, err := m.Statement.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.All {
		dAtA[i] = 0x10
		i++
		if m.All {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *DeleteStatementResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteStatementResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ReplaceStatementRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceStatementRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Statement != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Statement.Size()))
		n20, err := m.Statement.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	return i, nil
}

func (m *ReplaceStatementResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceStatementResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GetPolicyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetPolicyRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GetPolicyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetPolicyResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Policies) > 0 {
		for _, msg := range m.Policies {
			dAtA[i] = 0xa
			i++
			i = encodeVarintGobgp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AddPolicyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddPolicyRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Policy != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Policy.Size()))
		n21, err := m.Policy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.ReferExistingStatements {
		dAtA[i] = 0x10
		i++
		if m.ReferExistingStatements {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *AddPolicyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddPolicyResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *DeletePolicyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeletePolicyRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Policy != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Policy.Size()))
		n22, err := m.Policy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.PreserveStatements {
		dAtA[i] = 0x10
		i++
		if m.PreserveStatements {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.All {
		dAtA[i] = 0x18
		i++
		if m.All {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *DeletePolicyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeletePolicyResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ReplacePolicyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplacePolicyRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Policy != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Policy.Size()))
		n23, err := m.Policy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.ReferExistingStatements {
		dAtA[i] = 0x10
		i++
		if m.ReferExistingStatements {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PreserveStatements {
		dAtA[i] = 0x18
		i++
		if m.PreserveStatements {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ReplacePolicyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplacePolicyResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GetPolicyAssignmentRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetPolicyAssignmentRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Assignment != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Assignment.Size()))
		n24, err := m.Assignment.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	return i, nil
}

func (m *GetPolicyAssignmentResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetPolicyAssignmentResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Assignment != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Assignment.Size()))
		n25, err := m.Assignment.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}

func (m *AddPolicyAssignmentRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddPolicyAssignmentRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Assignment != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Assignment.Size()))
		n26, err := m.Assignment.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	return i, nil
}

func (m *AddPolicyAssignmentResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddPolicyAssignmentResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *DeletePolicyAssignmentRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeletePolicyAssignmentRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Assignment != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Assignment.Size()))
		n27, err := m.Assignment.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.All {
		dAtA[i] = 0x10
		i++
		if m.All {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *DeletePolicyAssignmentResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeletePolicyAssignmentResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ReplacePolicyAssignmentRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplacePolicyAssignmentRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Assignment != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Assignment.Size()))
		n28, err := m.Assignment.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	return i, nil
}

func (m *ReplacePolicyAssignmentResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplacePolicyAssignmentResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GetServerRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetServerRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GetServerResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetServerResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Global != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Global.Size()))
		n29, err := m.Global.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	return i, nil
}

func (m *StartServerRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StartServerRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Global != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Global.Size()))
		n30, err := m.Global.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	return i, nil
}

func (m *StartServerResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StartServerResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *StopServerRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StopServerRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *StopServerResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StopServerResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *RPKIValidation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RPKIValidation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.State != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.State))
	}
	if m.Reason != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Reason))
	}
	if len(m.Matched) > 0 {
		for _, msg := range m.Matched {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintGobgp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.UnmatchedAs) > 0 {
		for _, msg := range m.UnmatchedAs {
			dAtA[i] = 0x22
			i++
			i = encodeVarintGobgp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.UnmatchedLength) > 0 {
		for _, msg := range m.UnmatchedLength {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintGobgp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Path) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Path) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Nlri) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.Nlri)))
		i += copy(dAtA[i:], m.Nlri)
	}
	if len(m.Pattrs) > 0 {
		for _, b := range m.Pattrs {
			dAtA[i] = 0x12
			i++
			i = encodeVarintGobgp(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.Age != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Age))
	}
	if m.Best {
		dAtA[i] = 0x20
		i++
		if m.Best {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsWithdraw {
		dAtA[i] = 0x28
		i++
		if m.IsWithdraw {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Validation != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Validation))
	}
	if m.ValidationDetail != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.ValidationDetail.Size()))
		n31, err := m.ValidationDetail.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if m.NoImplicitWithdraw {
		dAtA[i] = 0x40
		i++
		if m.NoImplicitWithdraw {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Family != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Family))
	}
	if m.SourceAsn != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.SourceAsn))
	}
	if len(m.SourceId) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.SourceId)))
		i += copy(dAtA[i:], m.SourceId)
	}
	if m.Filtered {
		dAtA[i] = 0x60
		i++
		if m.Filtered {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Stale {
		dAtA[i] = 0x68
		i++
		if m.Stale {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsFromExternal {
		dAtA[i] = 0x70
		i++
		if m.IsFromExternal {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.NeighborIp) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.NeighborIp)))
		i += copy(dAtA[i:], m.NeighborIp)
	}
	if len(m.Uuid) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if m.IsNexthopInvalid {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		if m.IsNexthopInvalid {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Identifier != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Identifier))
	}
	if m.LocalIdentifier != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.LocalIdentifier))
	}
	if m.AnyNlri != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.AnyNlri.Size()))
		n32, err := m.AnyNlri.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	if len(m.AnyPattrs) > 0 {
		for _, msg := range m.AnyPattrs {
			dAtA[i] = 0xaa
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintGobgp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Destination) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Destination) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Prefix) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.Prefix)))
		i += copy(dAtA[i:], m.Prefix)
	}
	if len(m.Paths) > 0 {
		for _, msg := range m.Paths {
			dAtA[i] = 0x12
			i++
			i = encodeVarintGobgp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.LongerPrefixes {
		dAtA[i] = 0x18
		i++
		if m.LongerPrefixes {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ShorterPrefixes {
		dAtA[i] = 0x20
		i++
		if m.ShorterPrefixes {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *Table) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Table) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Type))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Family != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Family))
	}
	if len(m.Destinations) > 0 {
		for _, msg := range m.Destinations {
			dAtA[i] = 0x22
			i++
			i = encodeVarintGobgp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.PostPolicy {
		dAtA[i] = 0x28
		i++
		if m.PostPolicy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *GetRibRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRibRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Table != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Table.Size()))
		n33, err := m.Table.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	return i, nil
}

func (m *GetRibResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRibResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Table != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Table.Size()))
		n34, err := m.Table.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	return i, nil
}

func (m *TableLookupPrefix) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableLookupPrefix) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Prefix) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.Prefix)))
		i += copy(dAtA[i:], m.Prefix)
	}
	if m.LookupOption != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.LookupOption))
	}
	return i, nil
}

func (m *GetPathRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetPathRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Type))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Family != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Family))
	}
	if len(m.Prefixes) > 0 {
		for _, msg := range m.Prefixes {
			dAtA[i] = 0x22
			i++
			i = encodeVarintGobgp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ValidateRibRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidateRibRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Type))
	}
	if m.Family != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Family))
	}
	if len(m.Prefix) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.Prefix)))
		i += copy(dAtA[i:], m.Prefix)
	}
	return i, nil
}

func (m *ValidateRibResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidateRibResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *Peer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Peer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Families) > 0 {
		dAtA36 := make([]byte, len(m.Families)*10)
		var j35 int
		for _, num := range m.Families {
			for num >= 1<<7 {
				dAtA36[j35] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j35++
			}
			dAtA36[j35] = uint8(num)
			j35++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(j35))
		i += copy(dAtA[i:], dAtA36[:j35])
	}
	if m.ApplyPolicy != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.ApplyPolicy.Size()))
		n37, err := m.ApplyPolicy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	if m.Conf != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Conf.Size()))
		n38, err := m.Conf.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	if m.EbgpMultihop != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.EbgpMultihop.Size()))
		n39, err := m.EbgpMultihop.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	if m.RouteReflector != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.RouteReflector.Size()))
		n40, err := m.RouteReflector.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	if m.Info != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Info.Size()))
		n41, err := m.Info.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	if m.Timers != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Timers.Size()))
		n42, err := m.Timers.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	if m.Transport != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Transport.Size()))
		n43, err := m.Transport.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	if m.RouteServer != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.RouteServer.Size()))
		n44, err := m.RouteServer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	if m.GracefulRestart != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.GracefulRestart.Size()))
		n45, err := m.GracefulRestart.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	if len(m.AfiSafis) > 0 {
		for _, msg := range m.AfiSafis {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintGobgp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.AddPaths != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.AddPaths.Size()))
		n46, err := m.AddPaths.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n46
	}
	return i, nil
}

func (m *PeerGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PeerGroup) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Families) > 0 {
		dAtA48 := make([]byte, len(m.Families)*10)
		var j47 int
		for _, num := range m.Families {
			for num >= 1<<7 {
				dAtA48[j47] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j47++
			}
			dAtA48[j47] = uint8(num)
			j47++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(j47))
		i += copy(dAtA[i:], dAtA48[:j47])
	}
	if m.ApplyPolicy != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.ApplyPolicy.Size()))
		n49, err := m.ApplyPolicy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n49
	}
	if m.Conf != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Conf.Size()))
		n50, err := m.Conf.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n50
	}
	if m.EbgpMultihop != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.EbgpMultihop.Size()))
		n51, err := m.EbgpMultihop.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n51
	}
	if m.RouteReflector != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.RouteReflector.Size()))
		n52, err := m.RouteReflector.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n52
	}
	if m.Info != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Info.Size()))
		n53, err := m.Info.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n53
	}
	if m.Timers != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Timers.Size()))
		n54, err := m.Timers.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n54
	}
	if m.Transport != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Transport.Size()))
		n55, err := m.Transport.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n55
	}
	if m.RouteServer != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.RouteServer.Size()))
		n56, err := m.RouteServer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n56
	}
	if m.GracefulRestart != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.GracefulRestart.Size()))
		n57, err := m.GracefulRestart.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n57
	}
	if len(m.AfiSafis) > 0 {
		for _, msg := range m.AfiSafis {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintGobgp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.AddPaths != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.AddPaths.Size()))
		n58, err := m.AddPaths.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n58
	}
	return i, nil
}

func (m *DynamicNeighbor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DynamicNeighbor) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Prefix) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.Prefix)))
		i += copy(dAtA[i:], m.Prefix)
	}
	if len(m.PeerGroup) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.PeerGroup)))
		i += copy(dAtA[i:], m.PeerGroup)
	}
	return i, nil
}

func (m *ApplyPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplyPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.InPolicy != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.InPolicy.Size()))
		n59, err := m.InPolicy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n59
	}
	if m.ExportPolicy != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.ExportPolicy.Size()))
		n60, err := m.ExportPolicy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n60
	}
	if m.ImportPolicy != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.ImportPolicy.Size()))
		n61, err := m.ImportPolicy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n61
	}
	return i, nil
}

func (m *PrefixLimit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrefixLimit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Family != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Family))
	}
	if m.MaxPrefixes != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.MaxPrefixes))
	}
	if m.ShutdownThresholdPct != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.ShutdownThresholdPct))
	}
	return i, nil
}

func (m *PeerConf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PeerConf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AuthPassword) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.AuthPassword)))
		i += copy(dAtA[i:], m.AuthPassword)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if m.LocalAs != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.LocalAs))
	}
	if len(m.NeighborAddress) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.NeighborAddress)))
		i += copy(dAtA[i:], m.NeighborAddress)
	}
	if m.PeerAs != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.PeerAs))
	}
	if len(m.PeerGroup) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.PeerGroup)))
		i += copy(dAtA[i:], m.PeerGroup)
	}
	if m.PeerType != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.PeerType))
	}
	if m.RemovePrivateAs != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.RemovePrivateAs))
	}
	if m.RouteFlapDamping {
		dAtA[i] = 0x48
		i++
		if m.RouteFlapDamping {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SendCommunity != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.SendCommunity))
	}
	if len(m.RemoteCap) > 0 {
		for _, b := range m.RemoteCap {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintGobgp(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.LocalCap) > 0 {
		for _, b := range m.LocalCap {
			dAtA[i] = 0x62
			i++
			i = encodeVarintGobgp(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.Id) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.PrefixLimits) > 0 {
		for _, msg := range m.PrefixLimits {
			dAtA[i] = 0x72
			i++
			i = encodeVarintGobgp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.LocalAddress) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.LocalAddress)))
		i += copy(dAtA[i:], m.LocalAddress)
	}
	if len(m.NeighborInterface) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.NeighborInterface)))
		i += copy(dAtA[i:], m.NeighborInterface)
	}
	if len(m.Vrf) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.Vrf)))
		i += copy(dAtA[i:], m.Vrf)
	}
	if m.AllowOwnAs != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.AllowOwnAs))
	}
	if m.ReplacePeerAs {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		if m.ReplacePeerAs {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *PeerGroupConf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PeerGroupConf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AuthPassword) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.AuthPassword)))
		i += copy(dAtA[i:], m.AuthPassword)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if m.LocalAs != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.LocalAs))
	}
	if m.PeerAs != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.PeerAs))
	}
	if len(m.PeerGroupName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.PeerGroupName)))
		i += copy(dAtA[i:], m.PeerGroupName)
	}
	if m.PeerType != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.PeerType))
	}
	if m.RemovePrivateAs != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.RemovePrivateAs))
	}
	if m.RouteFlapDamping {
		dAtA[i] = 0x48
		i++
		if m.RouteFlapDamping {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SendCommunity != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.SendCommunity))
	}
	return i, nil
}

func (m *PeerGroupState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PeerGroupState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AuthPassword) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.AuthPassword)))
		i += copy(dAtA[i:], m.AuthPassword)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if m.LocalAs != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.LocalAs))
	}
	if m.PeerAs != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.PeerAs))
	}
	if len(m.PeerGroupName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.PeerGroupName)))
		i += copy(dAtA[i:], m.PeerGroupName)
	}
	if m.PeerType != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.PeerType))
	}
	if m.RemovePrivateAs != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.RemovePrivateAs))
	}
	if m.RouteFlapDamping {
		dAtA[i] = 0x48
		i++
		if m.RouteFlapDamping {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SendCommunity != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.SendCommunity))
	}
	if m.TotalPaths != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.TotalPaths))
	}
	if m.TotalPrefixes != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.TotalPrefixes))
	}
	return i, nil
}

func (m *EbgpMultihop) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EbgpMultihop) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled {
		dAtA[i] = 0x8
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MultihopTtl != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.MultihopTtl))
	}
	return i, nil
}

func (m *RouteReflector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteReflector) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RouteReflectorClient {
		dAtA[i] = 0x8
		i++
		if m.RouteReflectorClient {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.RouteReflectorClusterId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.RouteReflectorClusterId)))
		i += copy(dAtA[i:], m.RouteReflectorClusterId)
	}
	return i, nil
}

func (m *PeerState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PeerState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AuthPassword) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.AuthPassword)))
		i += copy(dAtA[i:], m.AuthPassword)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if m.LocalAs != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.LocalAs))
	}
	if m.Messages != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Messages.Size()))
		n62, err := m.Messages.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n62
	}
	if len(m.NeighborAddress) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.NeighborAddress)))
		i += copy(dAtA[i:], m.NeighborAddress)
	}
	if m.PeerAs != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.PeerAs))
	}
	if len(m.PeerGroup) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.PeerGroup)))
		i += copy(dAtA[i:], m.PeerGroup)
	}
	if m.PeerType != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.PeerType))
	}
	if m.Queues != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Queues.Size()))
		n63, err := m.Queues.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n63
	}
	if m.RemovePrivateAs != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.RemovePrivateAs))
	}
	if m.RouteFlapDamping {
		dAtA[i] = 0x58
		i++
		if m.RouteFlapDamping {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SendCommunity != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.SendCommunity))
	}
	if m.SessionState != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.SessionState))
	}
	if len(m.SupportedCapabilities) > 0 {
		for _, s := range m.SupportedCapabilities {
			dAtA[i] = 0x72
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.BgpState) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.BgpState)))
		i += copy(dAtA[i:], m.BgpState)
	}
	if m.AdminState != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.AdminState))
	}
	if m.Received != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Received))
	}
	if m.Accepted != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Accepted))
	}
	if m.Advertised != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Advertised))
	}
	if m.OutQ != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.OutQ))
	}
	if m.Flops != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Flops))
	}
	return i, nil
}

func (m *Messages) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Messages) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Received != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Received.Size()))
		n64, err := m.Received.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n64
	}
	if m.Sent != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Sent.Size()))
		n65, err := m.Sent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n65
	}
	return i, nil
}

func (m *Message) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Message) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NOTIFICATION != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.NOTIFICATION))
	}
	if m.UPDATE != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.UPDATE))
	}
	if m.OPEN != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.OPEN))
	}
	if m.KEEPALIVE != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.KEEPALIVE))
	}
	if m.REFRESH != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.REFRESH))
	}
	if m.DISCARDED != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.DISCARDED))
	}
	if m.TOTAL != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.TOTAL))
	}
	return i, nil
}

func (m *Queues) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Queues) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Input != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Input))
	}
	if m.Output != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Output))
	}
	return i, nil
}

func (m *Timers) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Timers) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Config != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Config.Size()))
		n66, err := m.Config.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n66
	}
	if m.State != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.State.Size()))
		n67, err := m.State.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n67
	}
	return i, nil
}

func (m *TimersConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimersConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ConnectRetry != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.ConnectRetry))
	}
	if m.HoldTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.HoldTime))
	}
	if m.KeepaliveInterval != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.KeepaliveInterval))
	}
	if m.MinimumAdvertisementInterval != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.MinimumAdvertisementInterval))
	}
	return i, nil
}

func (m *TimersState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimersState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ConnectRetry != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.ConnectRetry))
	}
	if m.HoldTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.HoldTime))
	}
	if m.KeepaliveInterval != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.KeepaliveInterval))
	}
	if m.MinimumAdvertisementInterval != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.MinimumAdvertisementInterval))
	}
	if m.NegotiatedHoldTime != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.NegotiatedHoldTime))
	}
	if m.Uptime != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Uptime))
	}
	if m.Downtime != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Downtime))
	}
	return i, nil
}

func (m *Transport) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Transport) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.LocalAddress) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.LocalAddress)))
		i += copy(dAtA[i:], m.LocalAddress)
	}
	if m.LocalPort != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.LocalPort))
	}
	if m.MtuDiscovery {
		dAtA[i] = 0x18
		i++
		if m.MtuDiscovery {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PassiveMode {
		dAtA[i] = 0x20
		i++
		if m.PassiveMode {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.RemoteAddress) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.RemoteAddress)))
		i += copy(dAtA[i:], m.RemoteAddress)
	}
	if m.RemotePort != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.RemotePort))
	}
	if m.TcpMss != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.TcpMss))
	}
	return i, nil
}

func (m *RouteServer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteServer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RouteServerClient {
		dAtA[i] = 0x8
		i++
		if m.RouteServerClient {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *GracefulRestart) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GracefulRestart) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled {
		dAtA[i] = 0x8
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RestartTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.RestartTime))
	}
	if m.HelperOnly {
		dAtA[i] = 0x18
		i++
		if m.HelperOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DeferralTime != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.DeferralTime))
	}
	if m.NotificationEnabled {
		dAtA[i] = 0x28
		i++
		if m.NotificationEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.LonglivedEnabled {
		dAtA[i] = 0x30
		i++
		if m.LonglivedEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.StaleRoutesTime != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.StaleRoutesTime))
	}
	if m.PeerRestartTime != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.PeerRestartTime))
	}
	if m.PeerRestarting {
		dAtA[i] = 0x48
		i++
		if m.PeerRestarting {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.LocalRestarting {
		dAtA[i] = 0x50
		i++
		if m.LocalRestarting {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Mode) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.Mode)))
		i += copy(dAtA[i:], m.Mode)
	}
	return i, nil
}

func (m *MpGracefulRestartConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MpGracefulRestartConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled {
		dAtA[i] = 0x8
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *MpGracefulRestartState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MpGracefulRestartState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled {
		dAtA[i] = 0x8
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Received {
		dAtA[i] = 0x10
		i++
		if m.Received {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Advertised {
		dAtA[i] = 0x18
		i++
		if m.Advertised {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.EndOfRibReceived {
		dAtA[i] = 0x20
		i++
		if m.EndOfRibReceived {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.EndOfRibSent {
		dAtA[i] = 0x28
		i++
		if m.EndOfRibSent {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *MpGracefulRestart) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MpGracefulRestart) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Config != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Config.Size()))
		n68, err := m.Config.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n68
	}
	if m.State != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.State.Size()))
		n69, err := m.State.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n69
	}
	return i, nil
}

func (m *AfiSafiConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AfiSafiConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Family != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Family))
	}
	if m.Enabled {
		dAtA[i] = 0x10
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *AfiSafiState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AfiSafiState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Family != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Family))
	}
	if m.Enabled {
		dAtA[i] = 0x10
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TotalPaths != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.TotalPaths))
	}
	if m.TotalPrefixes != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.TotalPrefixes))
	}
	return i, nil
}

func (m *RouteSelectionOptionsConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteSelectionOptionsConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AlwaysCompareMed {
		dAtA[i] = 0x8
		i++
		if m.AlwaysCompareMed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IgnoreAsPathLength {
		dAtA[i] = 0x10
		i++
		if m.IgnoreAsPathLength {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ExternalCompareRouterId {
		dAtA[i] = 0x18
		i++
		if m.ExternalCompareRouterId {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AdvertiseInactiveRoutes {
		dAtA[i] = 0x20
		i++
		if m.AdvertiseInactiveRoutes {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.EnableAigp {
		dAtA[i] = 0x28
		i++
		if m.EnableAigp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IgnoreNextHopIgpMetric {
		dAtA[i] = 0x30
		i++
		if m.IgnoreNextHopIgpMetric {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DisableBestPathSelection {
		dAtA[i] = 0x38
		i++
		if m.DisableBestPathSelection {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *RouteSelectionOptionsState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteSelectionOptionsState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AlwaysCompareMed {
		dAtA[i] = 0x8
		i++
		if m.AlwaysCompareMed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IgnoreAsPathLength {
		dAtA[i] = 0x10
		i++
		if m.IgnoreAsPathLength {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ExternalCompareRouterId {
		dAtA[i] = 0x18
		i++
		if m.ExternalCompareRouterId {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AdvertiseInactiveRoutes {
		dAtA[i] = 0x20
		i++
		if m.AdvertiseInactiveRoutes {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.EnableAigp {
		dAtA[i] = 0x28
		i++
		if m.EnableAigp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IgnoreNextHopIgpMetric {
		dAtA[i] = 0x30
		i++
		if m.IgnoreNextHopIgpMetric {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DisableBestPathSelection {
		dAtA[i] = 0x38
		i++
		if m.DisableBestPathSelection {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *RouteSelectionOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteSelectionOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Config != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Config.Size()))
		n70, err := m.Config.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n70
	}
	if m.State != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.State.Size()))
		n71, err := m.State.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n71
	}
	return i, nil
}

func (m *UseMultiplePathsConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UseMultiplePathsConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled {
		dAtA[i] = 0x8
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *UseMultiplePathsState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UseMultiplePathsState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled {
		dAtA[i] = 0x8
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *EbgpConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EbgpConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AllowMultipleAs {
		dAtA[i] = 0x8
		i++
		if m.AllowMultipleAs {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MaximumPaths != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.MaximumPaths))
	}
	return i, nil
}

func (m *EbgpState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EbgpState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AllowMultipleAs {
		dAtA[i] = 0x8
		i++
		if m.AllowMultipleAs {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MaximumPaths != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.MaximumPaths))
	}
	return i, nil
}

func (m *Ebgp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ebgp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Config != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Config.Size()))
		n72, err := m.Config.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n72
	}
	if m.State != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.State.Size()))
		n73, err := m.State.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n73
	}
	return i, nil
}

func (m *IbgpConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IbgpConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MaximumPaths != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.MaximumPaths))
	}
	return i, nil
}

func (m *IbgpState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IbgpState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MaximumPaths != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.MaximumPaths))
	}
	return i, nil
}

func (m *Ibgp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ibgp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Config != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Config.Size()))
		n74, err := m.Config.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n74
	}
	if m.State != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.State.Size()))
		n75, err := m.State.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n75
	}
	return i, nil
}

func (m *UseMultiplePaths) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UseMultiplePaths) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Config != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Config.Size()))
		n76, err := m.Config.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n76
	}
	if m.State != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.State.Size()))
		n77, err := m.State.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n77
	}
	if m.Ebgp != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Ebgp.Size()))
		n78, err := m.Ebgp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n78
	}
	if m.Ibgp != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Ibgp.Size()))
		n79, err := m.Ibgp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n79
	}
	return i, nil
}

func (m *RouteTargetMembershipConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteTargetMembershipConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DeferralTime != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.DeferralTime))
	}
	return i, nil
}

func (m *RouteTargetMembershipState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteTargetMembershipState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DeferralTime != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.DeferralTime))
	}
	return i, nil
}

func (m *RouteTargetMembership) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteTargetMembership) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Config != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Config.Size()))
		n80, err := m.Config.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n80
	}
	if m.State != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.State.Size()))
		n81, err := m.State.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n81
	}
	return i, nil
}

func (m *LongLivedGracefulRestartConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LongLivedGracefulRestartConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled {
		dAtA[i] = 0x8
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RestartTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.RestartTime))
	}
	return i, nil
}

func (m *LongLivedGracefulRestartState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LongLivedGracefulRestartState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled {
		dAtA[i] = 0x8
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Received {
		dAtA[i] = 0x10
		i++
		if m.Received {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Advertised {
		dAtA[i] = 0x18
		i++
		if m.Advertised {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PeerRestartTime != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.PeerRestartTime))
	}
	if m.PeerRestartTimerExpired {
		dAtA[i] = 0x28
		i++
		if m.PeerRestartTimerExpired {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *LongLivedGracefulRestart) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LongLivedGracefulRestart) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Config != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Config.Size()))
		n82, err := m.Config.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n82
	}
	if m.State != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.State.Size()))
		n83, err := m.State.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n83
	}
	return i, nil
}

func (m *AfiSafi) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AfiSafi) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MpGracefulRestart != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.MpGracefulRestart.Size()))
		n84, err := m.MpGracefulRestart.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n84
	}
	if m.Config != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Config.Size()))
		n85, err := m.Config.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n85
	}
	if m.ApplyPolicy != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.ApplyPolicy.Size()))
		n86, err := m.ApplyPolicy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n86
	}
	if m.RouteSelectionOptions != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.RouteSelectionOptions.Size()))
		n87, err := m.RouteSelectionOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n87
	}
	if m.UseMultiplePaths != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.UseMultiplePaths.Size()))
		n88, err := m.UseMultiplePaths.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n88
	}
	if m.PrefixLimits != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.PrefixLimits.Size()))
		n89, err := m.PrefixLimits.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n89
	}
	if m.RouteTargetMembership != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.RouteTargetMembership.Size()))
		n90, err := m.RouteTargetMembership.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n90
	}
	if m.LongLivedGracefulRestart != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.LongLivedGracefulRestart.Size()))
		n91, err := m.LongLivedGracefulRestart.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n91
	}
	if m.AddPaths != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.AddPaths.Size()))
		n92, err := m.AddPaths.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n92
	}
	return i, nil
}

func (m *AddPathsConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddPathsConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Receive {
		dAtA[i] = 0x8
		i++
		if m.Receive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SendMax != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.SendMax))
	}
	return i, nil
}

func (m *AddPathsState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddPathsState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Receive {
		dAtA[i] = 0x8
		i++
		if m.Receive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SendMax != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.SendMax))
	}
	return i, nil
}

func (m *AddPaths) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddPaths) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Config != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Config.Size()))
		n93, err := m.Config.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n93
	}
	if m.State != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.State.Size()))
		n94, err := m.State.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n94
	}
	return i, nil
}

func (m *Prefix) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Prefix) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.IpPrefix) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.IpPrefix)))
		i += copy(dAtA[i:], m.IpPrefix)
	}
	if m.MaskLengthMin != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.MaskLengthMin))
	}
	if m.MaskLengthMax != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.MaskLengthMax))
	}
	return i, nil
}

func (m *DefinedSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DefinedSet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Type))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.List) > 0 {
		for _, s := range m.List {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Prefixes) > 0 {
		for _, msg := range m.Prefixes {
			dAtA[i] = 0x22
			i++
			i = encodeVarintGobgp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MatchSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatchSet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Type))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *AsPathLength) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AsPathLength) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Type))
	}
	if m.Length != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Length))
	}
	return i, nil
}

func (m *Conditions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Conditions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PrefixSet != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.PrefixSet.Size()))
		n95, err := m.PrefixSet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n95
	}
	if m.NeighborSet != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.NeighborSet.Size()))
		n96, err := m.NeighborSet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n96
	}
	if m.AsPathLength != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.AsPathLength.Size()))
		n97, err := m.AsPathLength.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n97
	}
	if m.AsPathSet != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.AsPathSet.Size()))
		n98, err := m.AsPathSet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n98
	}
	if m.CommunitySet != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.CommunitySet.Size()))
		n99, err := m.CommunitySet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n99
	}
	if m.ExtCommunitySet != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.ExtCommunitySet.Size()))
		n100, err := m.ExtCommunitySet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n100
	}
	if m.RpkiResult != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.RpkiResult))
	}
	if m.RouteType != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.RouteType))
	}
	if m.LargeCommunitySet != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.LargeCommunitySet.Size()))
		n101, err := m.LargeCommunitySet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n101
	}
	if len(m.NextHopInList) > 0 {
		for _, s := range m.NextHopInList {
			dAtA[i] = 0x52
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *CommunityAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommunityAction) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Type))
	}
	if len(m.Communities) > 0 {
		for _, s := range m.Communities {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *MedAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MedAction) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Type))
	}
	if m.Value != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Value))
	}
	return i, nil
}

func (m *AsPrependAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AsPrependAction) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Asn != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Asn))
	}
	if m.Repeat != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Repeat))
	}
	if m.UseLeftMost {
		dAtA[i] = 0x18
		i++
		if m.UseLeftMost {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *NexthopAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NexthopAction) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if m.Self {
		dAtA[i] = 0x10
		i++
		if m.Self {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *LocalPrefAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocalPrefAction) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Value != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Value))
	}
	return i, nil
}

func (m *Actions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Actions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RouteAction != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.RouteAction))
	}
	if m.Community != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Community.Size()))
		n102, err := m.Community.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n102
	}
	if m.Med != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Med.Size()))
		n103, err := m.Med.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n103
	}
	if m.AsPrepend != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.AsPrepend.Size()))
		n104, err := m.AsPrepend.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n104
	}
	if m.ExtCommunity != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.ExtCommunity.Size()))
		n105, err := m.ExtCommunity.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n105
	}
	if m.Nexthop != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Nexthop.Size()))
		n106, err := m.Nexthop.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n106
	}
	if m.LocalPref != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.LocalPref.Size()))
		n107, err := m.LocalPref.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n107
	}
	if m.LargeCommunity != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.LargeCommunity.Size()))
		n108, err := m.LargeCommunity.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n108
	}
	return i, nil
}

func (m *Statement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Statement) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Conditions != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Conditions.Size()))
		n109, err := m.Conditions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n109
	}
	if m.Actions != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Actions.Size()))
		n110, err := m.Actions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n110
	}
	return i, nil
}

func (m *Policy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Policy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Statements) > 0 {
		for _, msg := range m.Statements {
			dAtA[i] = 0x12
			i++
			i = encodeVarintGobgp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *PolicyAssignment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicyAssignment) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Type))
	}
	if m.Resource != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Resource))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Policies) > 0 {
		for _, msg := range m.Policies {
			dAtA[i] = 0x22
			i++
			i = encodeVarintGobgp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Default != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Default))
	}
	return i, nil
}

func (m *RoutingPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoutingPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DefinedSet) > 0 {
		for _, msg := range m.DefinedSet {
			dAtA[i] = 0xa
			i++
			i = encodeVarintGobgp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.PolicyDefinition) > 0 {
		for _, msg := range m.PolicyDefinition {
			dAtA[i] = 0x12
			i++
			i = encodeVarintGobgp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Roa) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Roa) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.As != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.As))
	}
	if m.Prefixlen != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Prefixlen))
	}
	if m.Maxlen != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Maxlen))
	}
	if len(m.Prefix) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.Prefix)))
		i += copy(dAtA[i:], m.Prefix)
	}
	if m.Conf != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Conf.Size()))
		n111, err := m.Conf.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n111
	}
	return i, nil
}

func (m *GetRoaRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRoaRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Family != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Family))
	}
	return i, nil
}

func (m *GetRoaResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRoaResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Roas) > 0 {
		for _, msg := range m.Roas {
			dAtA[i] = 0xa
			i++
			i = encodeVarintGobgp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Vrf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Vrf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Rd) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.Rd)))
		i += copy(dAtA[i:], m.Rd)
	}
	if len(m.ImportRt) > 0 {
		for _, b := range m.ImportRt {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintGobgp(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.ExportRt) > 0 {
		for _, b := range m.ExportRt {
			dAtA[i] = 0x22
			i++
			i = encodeVarintGobgp(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.Id != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Id))
	}
	return i, nil
}

func (m *DefaultRouteDistance) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DefaultRouteDistance) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ExternalRouteDistance != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.ExternalRouteDistance))
	}
	if m.InternalRouteDistance != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.InternalRouteDistance))
	}
	return i, nil
}

func (m *Global) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Global) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.As != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.As))
	}
	if len(m.RouterId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.RouterId)))
		i += copy(dAtA[i:], m.RouterId)
	}
	if m.ListenPort != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.ListenPort))
	}
	if len(m.ListenAddresses) > 0 {
		for _, s := range m.ListenAddresses {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Families) > 0 {
		dAtA113 := make([]byte, len(m.Families)*10)
		var j112 int
		for _, num := range m.Families {
			for num >= 1<<7 {
				dAtA113[j112] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j112++
			}
			dAtA113[j112] = uint8(num)
			j112++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(j112))
		i += copy(dAtA[i:], dAtA113[:j112])
	}
	if m.UseMultiplePaths {
		dAtA[i] = 0x30
		i++
		if m.UseMultiplePaths {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RouteSelectionOptions != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.RouteSelectionOptions.Size()))
		n114, err := m.RouteSelectionOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n114
	}
	if m.DefaultRouteDistance != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.DefaultRouteDistance.Size()))
		n115, err := m.DefaultRouteDistance.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n115
	}
	if m.Confederation != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Confederation.Size()))
		n116, err := m.Confederation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n116
	}
	if m.GracefulRestart != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.GracefulRestart.Size()))
		n117, err := m.GracefulRestart.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n117
	}
	if m.ApplyPolicy != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.ApplyPolicy.Size()))
		n118, err := m.ApplyPolicy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n118
	}
	return i, nil
}

func (m *Confederation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Confederation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled {
		dAtA[i] = 0x8
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Identifier != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Identifier))
	}
	if len(m.MemberAsList) > 0 {
		dAtA120 := make([]byte, len(m.MemberAsList)*10)
		var j119 int
		for _, num := range m.MemberAsList {
			for num >= 1<<7 {
				dAtA120[j119] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j119++
			}
			dAtA120[j119] = uint8(num)
			j119++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(j119))
		i += copy(dAtA[i:], dAtA120[:j119])
	}
	return i, nil
}

func (m *TableInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Type))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Family != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Family))
	}
	if m.NumDestination != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.NumDestination))
	}
	if m.NumPath != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.NumPath))
	}
	if m.NumAccepted != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.NumAccepted))
	}
	return i, nil
}

func (m *GetRibInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRibInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Info != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Info.Size()))
		n121, err := m.Info.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n121
	}
	return i, nil
}

func (m *GetRibInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRibInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Info != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.Info.Size()))
		n122, err := m.Info.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n122
	}
	return i, nil
}

func (m *AddCollectorRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddCollectorRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Url) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	if len(m.DbName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(len(m.DbName)))
		i += copy(dAtA[i:], m.DbName)
	}
	if m.TableDumpInterval != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGobgp(dAtA, i, uint64(m.TableDumpInterval))
	}
	return i, nil
}

func (m *AddCollectorResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddCollectorResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ShutdownRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShutdownRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ShutdownResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShutdownResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func encodeVarintGobgp(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *GetNeighborRequest) Size() (n int) {
	var l int
	_ = l
	if m.EnableAdvertised {
		n += 2
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	return n
}

func (m *GetNeighborResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Peers) > 0 {
		for _, e := range m.Peers {
			l = e.Size()
			n += 1 + l + sovGobgp(uint64(l))
		}
	}
	return n
}

func (m *Arguments) Size() (n int) {
	var l int
	_ = l
	if m.Resource != 0 {
		n += 1 + sovGobgp(uint64(m.Resource))
	}
	if m.Family != 0 {
		n += 1 + sovGobgp(uint64(m.Family))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.Current {
		n += 2
	}
	return n
}

func (m *AddPathRequest) Size() (n int) {
	var l int
	_ = l
	if m.Resource != 0 {
		n += 1 + sovGobgp(uint64(m.Resource))
	}
	l = len(m.VrfId)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.Path != nil {
		l = m.Path.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	return n
}

func (m *AddPathResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	return n
}

func (m *DeletePathRequest) Size() (n int) {
	var l int
	_ = l
	if m.Resource != 0 {
		n += 1 + sovGobgp(uint64(m.Resource))
	}
	l = len(m.VrfId)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.Family != 0 {
		n += 1 + sovGobgp(uint64(m.Family))
	}
	if m.Path != nil {
		l = m.Path.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	return n
}

func (m *DeletePathResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *AddNeighborRequest) Size() (n int) {
	var l int
	_ = l
	if m.Peer != nil {
		l = m.Peer.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	return n
}

func (m *AddNeighborResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *DeleteNeighborRequest) Size() (n int) {
	var l int
	_ = l
	if m.Peer != nil {
		l = m.Peer.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	return n
}

func (m *DeleteNeighborResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *UpdateNeighborRequest) Size() (n int) {
	var l int
	_ = l
	if m.Peer != nil {
		l = m.Peer.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.DoSoftResetIn {
		n += 2
	}
	return n
}

func (m *UpdateNeighborResponse) Size() (n int) {
	var l int
	_ = l
	if m.NeedsSoftResetIn {
		n += 2
	}
	return n
}

func (m *AddPeerGroupRequest) Size() (n int) {
	var l int
	_ = l
	if m.PeerGroup != nil {
		l = m.PeerGroup.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	return n
}

func (m *AddPeerGroupResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *DeletePeerGroupRequest) Size() (n int) {
	var l int
	_ = l
	if m.PeerGroup != nil {
		l = m.PeerGroup.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	return n
}

func (m *DeletePeerGroupResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *UpdatePeerGroupRequest) Size() (n int) {
	var l int
	_ = l
	if m.PeerGroup != nil {
		l = m.PeerGroup.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.DoSoftResetIn {
		n += 2
	}
	return n
}

func (m *UpdatePeerGroupResponse) Size() (n int) {
	var l int
	_ = l
	if m.NeedsSoftResetIn {
		n += 2
	}
	return n
}

func (m *AddDynamicNeighborRequest) Size() (n int) {
	var l int
	_ = l
	if m.DynamicNeighbor != nil {
		l = m.DynamicNeighbor.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	return n
}

func (m *AddDynamicNeighborResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ResetNeighborRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	l = len(m.Communication)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	return n
}

func (m *ResetNeighborResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *SoftResetNeighborRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.Direction != 0 {
		n += 1 + sovGobgp(uint64(m.Direction))
	}
	return n
}

func (m *SoftResetNeighborResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ShutdownNeighborRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	l = len(m.Communication)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	return n
}

func (m *ShutdownNeighborResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *EnableNeighborRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	return n
}

func (m *EnableNeighborResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *DisableNeighborRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	l = len(m.Communication)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	return n
}

func (m *DisableNeighborResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *UpdatePolicyRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Sets) > 0 {
		for _, e := range m.Sets {
			l = e.Size()
			n += 1 + l + sovGobgp(uint64(l))
		}
	}
	if len(m.Policies) > 0 {
		for _, e := range m.Policies {
			l = e.Size()
			n += 1 + l + sovGobgp(uint64(l))
		}
	}
	return n
}

func (m *UpdatePolicyResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *EnableMrtRequest) Size() (n int) {
	var l int
	_ = l
	if m.DumpType != 0 {
		n += 1 + sovGobgp(uint64(m.DumpType))
	}
	l = len(m.Filename)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.Interval != 0 {
		n += 1 + sovGobgp(uint64(m.Interval))
	}
	return n
}

func (m *EnableMrtResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *DisableMrtRequest) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *DisableMrtResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *InjectMrtRequest) Size() (n int) {
	var l int
	_ = l
	if m.Resource != 0 {
		n += 1 + sovGobgp(uint64(m.Resource))
	}
	l = len(m.VrfId)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	if len(m.Paths) > 0 {
		for _, e := range m.Paths {
			l = e.Size()
			n += 1 + l + sovGobgp(uint64(l))
		}
	}
	return n
}

func (m *InjectMrtResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *AddBmpRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovGobgp(uint64(m.Port))
	}
	if m.Type != 0 {
		n += 1 + sovGobgp(uint64(m.Type))
	}
	return n
}

func (m *AddBmpResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *DeleteBmpRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovGobgp(uint64(m.Port))
	}
	return n
}

func (m *DeleteBmpResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *MonitorRibRequest) Size() (n int) {
	var l int
	_ = l
	if m.Table != nil {
		l = m.Table.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.Current {
		n += 2
	}
	return n
}

func (m *RPKIConf) Size() (n int) {
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	l = len(m.RemotePort)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	return n
}

func (m *RPKIState) Size() (n int) {
	var l int
	_ = l
	if m.Uptime != 0 {
		n += 1 + sovGobgp(uint64(m.Uptime))
	}
	if m.Downtime != 0 {
		n += 1 + sovGobgp(uint64(m.Downtime))
	}
	if m.Up {
		n += 2
	}
	if m.RecordIpv4 != 0 {
		n += 1 + sovGobgp(uint64(m.RecordIpv4))
	}
	if m.RecordIpv6 != 0 {
		n += 1 + sovGobgp(uint64(m.RecordIpv6))
	}
	if m.PrefixIpv4 != 0 {
		n += 1 + sovGobgp(uint64(m.PrefixIpv4))
	}
	if m.PrefixIpv6 != 0 {
		n += 1 + sovGobgp(uint64(m.PrefixIpv6))
	}
	if m.Serial != 0 {
		n += 1 + sovGobgp(uint64(m.Serial))
	}
	if m.ReceivedIpv4 != 0 {
		n += 1 + sovGobgp(uint64(m.ReceivedIpv4))
	}
	if m.ReceivedIpv6 != 0 {
		n += 1 + sovGobgp(uint64(m.ReceivedIpv6))
	}
	if m.SerialNotify != 0 {
		n += 1 + sovGobgp(uint64(m.SerialNotify))
	}
	if m.CacheReset != 0 {
		n += 1 + sovGobgp(uint64(m.CacheReset))
	}
	if m.CacheResponse != 0 {
		n += 1 + sovGobgp(uint64(m.CacheResponse))
	}
	if m.EndOfData != 0 {
		n += 1 + sovGobgp(uint64(m.EndOfData))
	}
	if m.Error != 0 {
		n += 1 + sovGobgp(uint64(m.Error))
	}
	if m.SerialQuery != 0 {
		n += 2 + sovGobgp(uint64(m.SerialQuery))
	}
	if m.ResetQuery != 0 {
		n += 2 + sovGobgp(uint64(m.ResetQuery))
	}
	return n
}

func (m *Rpki) Size() (n int) {
	var l int
	_ = l
	if m.Conf != nil {
		l = m.Conf.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	return n
}

func (m *GetRpkiRequest) Size() (n int) {
	var l int
	_ = l
	if m.Family != 0 {
		n += 1 + sovGobgp(uint64(m.Family))
	}
	return n
}

func (m *GetRpkiResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Servers) > 0 {
		for _, e := range m.Servers {
			l = e.Size()
			n += 1 + l + sovGobgp(uint64(l))
		}
	}
	return n
}

func (m *AddRpkiRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovGobgp(uint64(m.Port))
	}
	if m.Lifetime != 0 {
		n += 1 + sovGobgp(uint64(m.Lifetime))
	}
	return n
}

func (m *AddRpkiResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *DeleteRpkiRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovGobgp(uint64(m.Port))
	}
	return n
}

func (m *DeleteRpkiResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *EnableRpkiRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	return n
}

func (m *EnableRpkiResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *DisableRpkiRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	return n
}

func (m *DisableRpkiResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ResetRpkiRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	return n
}

func (m *ResetRpkiResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *SoftResetRpkiRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	return n
}

func (m *SoftResetRpkiResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *EnableZebraRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	if len(m.RouteTypes) > 0 {
		for _, s := range m.RouteTypes {
			l = len(s)
			n += 1 + l + sovGobgp(uint64(l))
		}
	}
	if m.Version != 0 {
		n += 1 + sovGobgp(uint64(m.Version))
	}
	if m.NexthopTriggerEnable {
		n += 2
	}
	if m.NexthopTriggerDelay != 0 {
		n += 1 + sovGobgp(uint64(m.NexthopTriggerDelay))
	}
	return n
}

func (m *EnableZebraResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GetVrfRequest) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GetVrfResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Vrfs) > 0 {
		for _, e := range m.Vrfs {
			l = e.Size()
			n += 1 + l + sovGobgp(uint64(l))
		}
	}
	return n
}

func (m *AddVrfRequest) Size() (n int) {
	var l int
	_ = l
	if m.Vrf != nil {
		l = m.Vrf.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	return n
}

func (m *AddVrfResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *DeleteVrfRequest) Size() (n int) {
	var l int
	_ = l
	if m.Vrf != nil {
		l = m.Vrf.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	return n
}

func (m *DeleteVrfResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GetDefinedSetRequest) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovGobgp(uint64(m.Type))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	return n
}

func (m *GetDefinedSetResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Sets) > 0 {
		for _, e := range m.Sets {
			l = e.Size()
			n += 1 + l + sovGobgp(uint64(l))
		}
	}
	return n
}

func (m *AddDefinedSetRequest) Size() (n int) {
	var l int
	_ = l
	if m.Set != nil {
		l = m.Set.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	return n
}

func (m *AddDefinedSetResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *DeleteDefinedSetRequest) Size() (n int) {
	var l int
	_ = l
	if m.Set != nil {
		l = m.Set.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.All {
		n += 2
	}
	return n
}

func (m *DeleteDefinedSetResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ReplaceDefinedSetRequest) Size() (n int) {
	var l int
	_ = l
	if m.Set != nil {
		l = m.Set.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	return n
}

func (m *ReplaceDefinedSetResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GetStatementRequest) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GetStatementResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Statements) > 0 {
		for _, e := range m.Statements {
			l = e.Size()
			n += 1 + l + sovGobgp(uint64(l))
		}
	}
	return n
}

func (m *AddStatementRequest) Size() (n int) {
	var l int
	_ = l
	if m.Statement != nil {
		l = m.Statement.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	return n
}

func (m *AddStatementResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *DeleteStatementRequest) Size() (n int) {
	var l int
	_ = l
	if m.Statement != nil {
		l = m.Statement.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.All {
		n += 2
	}
	return n
}

func (m *DeleteStatementResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ReplaceStatementRequest) Size() (n int) {
	var l int
	_ = l
	if m.Statement != nil {
		l = m.Statement.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	return n
}

func (m *ReplaceStatementResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GetPolicyRequest) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GetPolicyResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Policies) > 0 {
		for _, e := range m.Policies {
			l = e.Size()
			n += 1 + l + sovGobgp(uint64(l))
		}
	}
	return n
}

func (m *AddPolicyRequest) Size() (n int) {
	var l int
	_ = l
	if m.Policy != nil {
		l = m.Policy.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.ReferExistingStatements {
		n += 2
	}
	return n
}

func (m *AddPolicyResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *DeletePolicyRequest) Size() (n int) {
	var l int
	_ = l
	if m.Policy != nil {
		l = m.Policy.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.PreserveStatements {
		n += 2
	}
	if m.All {
		n += 2
	}
	return n
}

func (m *DeletePolicyResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ReplacePolicyRequest) Size() (n int) {
	var l int
	_ = l
	if m.Policy != nil {
		l = m.Policy.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.ReferExistingStatements {
		n += 2
	}
	if m.PreserveStatements {
		n += 2
	}
	return n
}

func (m *ReplacePolicyResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GetPolicyAssignmentRequest) Size() (n int) {
	var l int
	_ = l
	if m.Assignment != nil {
		l = m.Assignment.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	return n
}

func (m *GetPolicyAssignmentResponse) Size() (n int) {
	var l int
	_ = l
	if m.Assignment != nil {
		l = m.Assignment.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	return n
}

func (m *AddPolicyAssignmentRequest) Size() (n int) {
	var l int
	_ = l
	if m.Assignment != nil {
		l = m.Assignment.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	return n
}

func (m *AddPolicyAssignmentResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *DeletePolicyAssignmentRequest) Size() (n int) {
	var l int
	_ = l
	if m.Assignment != nil {
		l = m.Assignment.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.All {
		n += 2
	}
	return n
}

func (m *DeletePolicyAssignmentResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ReplacePolicyAssignmentRequest) Size() (n int) {
	var l int
	_ = l
	if m.Assignment != nil {
		l = m.Assignment.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	return n
}

func (m *ReplacePolicyAssignmentResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GetServerRequest) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GetServerResponse) Size() (n int) {
	var l int
	_ = l
	if m.Global != nil {
		l = m.Global.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	return n
}

func (m *StartServerRequest) Size() (n int) {
	var l int
	_ = l
	if m.Global != nil {
		l = m.Global.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	return n
}

func (m *StartServerResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *StopServerRequest) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *StopServerResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *RPKIValidation) Size() (n int) {
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovGobgp(uint64(m.State))
	}
	if m.Reason != 0 {
		n += 1 + sovGobgp(uint64(m.Reason))
	}
	if len(m.Matched) > 0 {
		for _, e := range m.Matched {
			l = e.Size()
			n += 1 + l + sovGobgp(uint64(l))
		}
	}
	if len(m.UnmatchedAs) > 0 {
		for _, e := range m.UnmatchedAs {
			l = e.Size()
			n += 1 + l + sovGobgp(uint64(l))
		}
	}
	if len(m.UnmatchedLength) > 0 {
		for _, e := range m.UnmatchedLength {
			l = e.Size()
			n += 1 + l + sovGobgp(uint64(l))
		}
	}
	return n
}

func (m *Path) Size() (n int) {
	var l int
	_ = l
	l = len(m.Nlri)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	if len(m.Pattrs) > 0 {
		for _, b := range m.Pattrs {
			l = len(b)
			n += 1 + l + sovGobgp(uint64(l))
		}
	}
	if m.Age != 0 {
		n += 1 + sovGobgp(uint64(m.Age))
	}
	if m.Best {
		n += 2
	}
	if m.IsWithdraw {
		n += 2
	}
	if m.Validation != 0 {
		n += 1 + sovGobgp(uint64(m.Validation))
	}
	if m.ValidationDetail != nil {
		l = m.ValidationDetail.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.NoImplicitWithdraw {
		n += 2
	}
	if m.Family != 0 {
		n += 1 + sovGobgp(uint64(m.Family))
	}
	if m.SourceAsn != 0 {
		n += 1 + sovGobgp(uint64(m.SourceAsn))
	}
	l = len(m.SourceId)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.Filtered {
		n += 2
	}
	if m.Stale {
		n += 2
	}
	if m.IsFromExternal {
		n += 2
	}
	l = len(m.NeighborIp)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	l = len(m.Uuid)
	if l > 0 {
		n += 2 + l + sovGobgp(uint64(l))
	}
	if m.IsNexthopInvalid {
		n += 3
	}
	if m.Identifier != 0 {
		n += 2 + sovGobgp(uint64(m.Identifier))
	}
	if m.LocalIdentifier != 0 {
		n += 2 + sovGobgp(uint64(m.LocalIdentifier))
	}
	if m.AnyNlri != nil {
		l = m.AnyNlri.Size()
		n += 2 + l + sovGobgp(uint64(l))
	}
	if len(m.AnyPattrs) > 0 {
		for _, e := range m.AnyPattrs {
			l = e.Size()
			n += 2 + l + sovGobgp(uint64(l))
		}
	}
	return n
}

func (m *Destination) Size() (n int) {
	var l int
	_ = l
	l = len(m.Prefix)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	if len(m.Paths) > 0 {
		for _, e := range m.Paths {
			l = e.Size()
			n += 1 + l + sovGobgp(uint64(l))
		}
	}
	if m.LongerPrefixes {
		n += 2
	}
	if m.ShorterPrefixes {
		n += 2
	}
	return n
}

func (m *Table) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovGobgp(uint64(m.Type))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.Family != 0 {
		n += 1 + sovGobgp(uint64(m.Family))
	}
	if len(m.Destinations) > 0 {
		for _, e := range m.Destinations {
			l = e.Size()
			n += 1 + l + sovGobgp(uint64(l))
		}
	}
	if m.PostPolicy {
		n += 2
	}
	return n
}

func (m *GetRibRequest) Size() (n int) {
	var l int
	_ = l
	if m.Table != nil {
		l = m.Table.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	return n
}

func (m *GetRibResponse) Size() (n int) {
	var l int
	_ = l
	if m.Table != nil {
		l = m.Table.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	return n
}

func (m *TableLookupPrefix) Size() (n int) {
	var l int
	_ = l
	l = len(m.Prefix)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.LookupOption != 0 {
		n += 1 + sovGobgp(uint64(m.LookupOption))
	}
	return n
}

func (m *GetPathRequest) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovGobgp(uint64(m.Type))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.Family != 0 {
		n += 1 + sovGobgp(uint64(m.Family))
	}
	if len(m.Prefixes) > 0 {
		for _, e := range m.Prefixes {
			l = e.Size()
			n += 1 + l + sovGobgp(uint64(l))
		}
	}
	return n
}

func (m *ValidateRibRequest) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovGobgp(uint64(m.Type))
	}
	if m.Family != 0 {
		n += 1 + sovGobgp(uint64(m.Family))
	}
	l = len(m.Prefix)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	return n
}

func (m *ValidateRibResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *Peer) Size() (n int) {
	var l int
	_ = l
	if len(m.Families) > 0 {
		l = 0
		for _, e := range m.Families {
			l += sovGobgp(uint64(e))
		}
		n += 1 + sovGobgp(uint64(l)) + l
	}
	if m.ApplyPolicy != nil {
		l = m.ApplyPolicy.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.Conf != nil {
		l = m.Conf.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.EbgpMultihop != nil {
		l = m.EbgpMultihop.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.RouteReflector != nil {
		l = m.RouteReflector.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.Timers != nil {
		l = m.Timers.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.Transport != nil {
		l = m.Transport.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.RouteServer != nil {
		l = m.RouteServer.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.GracefulRestart != nil {
		l = m.GracefulRestart.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if len(m.AfiSafis) > 0 {
		for _, e := range m.AfiSafis {
			l = e.Size()
			n += 1 + l + sovGobgp(uint64(l))
		}
	}
	if m.AddPaths != nil {
		l = m.AddPaths.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	return n
}

func (m *PeerGroup) Size() (n int) {
	var l int
	_ = l
	if len(m.Families) > 0 {
		l = 0
		for _, e := range m.Families {
			l += sovGobgp(uint64(e))
		}
		n += 1 + sovGobgp(uint64(l)) + l
	}
	if m.ApplyPolicy != nil {
		l = m.ApplyPolicy.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.Conf != nil {
		l = m.Conf.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.EbgpMultihop != nil {
		l = m.EbgpMultihop.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.RouteReflector != nil {
		l = m.RouteReflector.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.Timers != nil {
		l = m.Timers.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.Transport != nil {
		l = m.Transport.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.RouteServer != nil {
		l = m.RouteServer.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.GracefulRestart != nil {
		l = m.GracefulRestart.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if len(m.AfiSafis) > 0 {
		for _, e := range m.AfiSafis {
			l = e.Size()
			n += 1 + l + sovGobgp(uint64(l))
		}
	}
	if m.AddPaths != nil {
		l = m.AddPaths.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	return n
}

func (m *DynamicNeighbor) Size() (n int) {
	var l int
	_ = l
	l = len(m.Prefix)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	l = len(m.PeerGroup)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	return n
}

func (m *ApplyPolicy) Size() (n int) {
	var l int
	_ = l
	if m.InPolicy != nil {
		l = m.InPolicy.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.ExportPolicy != nil {
		l = m.ExportPolicy.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.ImportPolicy != nil {
		l = m.ImportPolicy.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	return n
}

func (m *PrefixLimit) Size() (n int) {
	var l int
	_ = l
	if m.Family != 0 {
		n += 1 + sovGobgp(uint64(m.Family))
	}
	if m.MaxPrefixes != 0 {
		n += 1 + sovGobgp(uint64(m.MaxPrefixes))
	}
	if m.ShutdownThresholdPct != 0 {
		n += 1 + sovGobgp(uint64(m.ShutdownThresholdPct))
	}
	return n
}

func (m *PeerConf) Size() (n int) {
	var l int
	_ = l
	l = len(m.AuthPassword)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.LocalAs != 0 {
		n += 1 + sovGobgp(uint64(m.LocalAs))
	}
	l = len(m.NeighborAddress)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.PeerAs != 0 {
		n += 1 + sovGobgp(uint64(m.PeerAs))
	}
	l = len(m.PeerGroup)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.PeerType != 0 {
		n += 1 + sovGobgp(uint64(m.PeerType))
	}
	if m.RemovePrivateAs != 0 {
		n += 1 + sovGobgp(uint64(m.RemovePrivateAs))
	}
	if m.RouteFlapDamping {
		n += 2
	}
	if m.SendCommunity != 0 {
		n += 1 + sovGobgp(uint64(m.SendCommunity))
	}
	if len(m.RemoteCap) > 0 {
		for _, b := range m.RemoteCap {
			l = len(b)
			n += 1 + l + sovGobgp(uint64(l))
		}
	}
	if len(m.LocalCap) > 0 {
		for _, b := range m.LocalCap {
			l = len(b)
			n += 1 + l + sovGobgp(uint64(l))
		}
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	if len(m.PrefixLimits) > 0 {
		for _, e := range m.PrefixLimits {
			l = e.Size()
			n += 1 + l + sovGobgp(uint64(l))
		}
	}
	l = len(m.LocalAddress)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	l = len(m.NeighborInterface)
	if l > 0 {
		n += 2 + l + sovGobgp(uint64(l))
	}
	l = len(m.Vrf)
	if l > 0 {
		n += 2 + l + sovGobgp(uint64(l))
	}
	if m.AllowOwnAs != 0 {
		n += 2 + sovGobgp(uint64(m.AllowOwnAs))
	}
	if m.ReplacePeerAs {
		n += 3
	}
	return n
}

func (m *PeerGroupConf) Size() (n int) {
	var l int
	_ = l
	l = len(m.AuthPassword)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.LocalAs != 0 {
		n += 1 + sovGobgp(uint64(m.LocalAs))
	}
	if m.PeerAs != 0 {
		n += 1 + sovGobgp(uint64(m.PeerAs))
	}
	l = len(m.PeerGroupName)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.PeerType != 0 {
		n += 1 + sovGobgp(uint64(m.PeerType))
	}
	if m.RemovePrivateAs != 0 {
		n += 1 + sovGobgp(uint64(m.RemovePrivateAs))
	}
	if m.RouteFlapDamping {
		n += 2
	}
	if m.SendCommunity != 0 {
		n += 1 + sovGobgp(uint64(m.SendCommunity))
	}
	return n
}

func (m *PeerGroupState) Size() (n int) {
	var l int
	_ = l
	l = len(m.AuthPassword)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.LocalAs != 0 {
		n += 1 + sovGobgp(uint64(m.LocalAs))
	}
	if m.PeerAs != 0 {
		n += 1 + sovGobgp(uint64(m.PeerAs))
	}
	l = len(m.PeerGroupName)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.PeerType != 0 {
		n += 1 + sovGobgp(uint64(m.PeerType))
	}
	if m.RemovePrivateAs != 0 {
		n += 1 + sovGobgp(uint64(m.RemovePrivateAs))
	}
	if m.RouteFlapDamping {
		n += 2
	}
	if m.SendCommunity != 0 {
		n += 1 + sovGobgp(uint64(m.SendCommunity))
	}
	if m.TotalPaths != 0 {
		n += 1 + sovGobgp(uint64(m.TotalPaths))
	}
	if m.TotalPrefixes != 0 {
		n += 1 + sovGobgp(uint64(m.TotalPrefixes))
	}
	return n
}

func (m *EbgpMultihop) Size() (n int) {
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	if m.MultihopTtl != 0 {
		n += 1 + sovGobgp(uint64(m.MultihopTtl))
	}
	return n
}

func (m *RouteReflector) Size() (n int) {
	var l int
	_ = l
	if m.RouteReflectorClient {
		n += 2
	}
	l = len(m.RouteReflectorClusterId)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	return n
}

func (m *PeerState) Size() (n int) {
	var l int
	_ = l
	l = len(m.AuthPassword)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.LocalAs != 0 {
		n += 1 + sovGobgp(uint64(m.LocalAs))
	}
	if m.Messages != nil {
		l = m.Messages.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	l = len(m.NeighborAddress)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.PeerAs != 0 {
		n += 1 + sovGobgp(uint64(m.PeerAs))
	}
	l = len(m.PeerGroup)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.PeerType != 0 {
		n += 1 + sovGobgp(uint64(m.PeerType))
	}
	if m.Queues != nil {
		l = m.Queues.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.RemovePrivateAs != 0 {
		n += 1 + sovGobgp(uint64(m.RemovePrivateAs))
	}
	if m.RouteFlapDamping {
		n += 2
	}
	if m.SendCommunity != 0 {
		n += 1 + sovGobgp(uint64(m.SendCommunity))
	}
	if m.SessionState != 0 {
		n += 1 + sovGobgp(uint64(m.SessionState))
	}
	if len(m.SupportedCapabilities) > 0 {
		for _, s := range m.SupportedCapabilities {
			l = len(s)
			n += 1 + l + sovGobgp(uint64(l))
		}
	}
	l = len(m.BgpState)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.AdminState != 0 {
		n += 2 + sovGobgp(uint64(m.AdminState))
	}
	if m.Received != 0 {
		n += 2 + sovGobgp(uint64(m.Received))
	}
	if m.Accepted != 0 {
		n += 2 + sovGobgp(uint64(m.Accepted))
	}
	if m.Advertised != 0 {
		n += 2 + sovGobgp(uint64(m.Advertised))
	}
	if m.OutQ != 0 {
		n += 2 + sovGobgp(uint64(m.OutQ))
	}
	if m.Flops != 0 {
		n += 2 + sovGobgp(uint64(m.Flops))
	}
	return n
}

func (m *Messages) Size() (n int) {
	var l int
	_ = l
	if m.Received != nil {
		l = m.Received.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.Sent != nil {
		l = m.Sent.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	return n
}

func (m *Message) Size() (n int) {
	var l int
	_ = l
	if m.NOTIFICATION != 0 {
		n += 1 + sovGobgp(uint64(m.NOTIFICATION))
	}
	if m.UPDATE != 0 {
		n += 1 + sovGobgp(uint64(m.UPDATE))
	}
	if m.OPEN != 0 {
		n += 1 + sovGobgp(uint64(m.OPEN))
	}
	if m.KEEPALIVE != 0 {
		n += 1 + sovGobgp(uint64(m.KEEPALIVE))
	}
	if m.REFRESH != 0 {
		n += 1 + sovGobgp(uint64(m.REFRESH))
	}
	if m.DISCARDED != 0 {
		n += 1 + sovGobgp(uint64(m.DISCARDED))
	}
	if m.TOTAL != 0 {
		n += 1 + sovGobgp(uint64(m.TOTAL))
	}
	return n
}

func (m *Queues) Size() (n int) {
	var l int
	_ = l
	if m.Input != 0 {
		n += 1 + sovGobgp(uint64(m.Input))
	}
	if m.Output != 0 {
		n += 1 + sovGobgp(uint64(m.Output))
	}
	return n
}

func (m *Timers) Size() (n int) {
	var l int
	_ = l
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	return n
}

func (m *TimersConfig) Size() (n int) {
	var l int
	_ = l
	if m.ConnectRetry != 0 {
		n += 1 + sovGobgp(uint64(m.ConnectRetry))
	}
	if m.HoldTime != 0 {
		n += 1 + sovGobgp(uint64(m.HoldTime))
	}
	if m.KeepaliveInterval != 0 {
		n += 1 + sovGobgp(uint64(m.KeepaliveInterval))
	}
	if m.MinimumAdvertisementInterval != 0 {
		n += 1 + sovGobgp(uint64(m.MinimumAdvertisementInterval))
	}
	return n
}

func (m *TimersState) Size() (n int) {
	var l int
	_ = l
	if m.ConnectRetry != 0 {
		n += 1 + sovGobgp(uint64(m.ConnectRetry))
	}
	if m.HoldTime != 0 {
		n += 1 + sovGobgp(uint64(m.HoldTime))
	}
	if m.KeepaliveInterval != 0 {
		n += 1 + sovGobgp(uint64(m.KeepaliveInterval))
	}
	if m.MinimumAdvertisementInterval != 0 {
		n += 1 + sovGobgp(uint64(m.MinimumAdvertisementInterval))
	}
	if m.NegotiatedHoldTime != 0 {
		n += 1 + sovGobgp(uint64(m.NegotiatedHoldTime))
	}
	if m.Uptime != 0 {
		n += 1 + sovGobgp(uint64(m.Uptime))
	}
	if m.Downtime != 0 {
		n += 1 + sovGobgp(uint64(m.Downtime))
	}
	return n
}

func (m *Transport) Size() (n int) {
	var l int
	_ = l
	l = len(m.LocalAddress)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.LocalPort != 0 {
		n += 1 + sovGobgp(uint64(m.LocalPort))
	}
	if m.MtuDiscovery {
		n += 2
	}
	if m.PassiveMode {
		n += 2
	}
	l = len(m.RemoteAddress)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.RemotePort != 0 {
		n += 1 + sovGobgp(uint64(m.RemotePort))
	}
	if m.TcpMss != 0 {
		n += 1 + sovGobgp(uint64(m.TcpMss))
	}
	return n
}

func (m *RouteServer) Size() (n int) {
	var l int
	_ = l
	if m.RouteServerClient {
		n += 2
	}
	return n
}

func (m *GracefulRestart) Size() (n int) {
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	if m.RestartTime != 0 {
		n += 1 + sovGobgp(uint64(m.RestartTime))
	}
	if m.HelperOnly {
		n += 2
	}
	if m.DeferralTime != 0 {
		n += 1 + sovGobgp(uint64(m.DeferralTime))
	}
	if m.NotificationEnabled {
		n += 2
	}
	if m.LonglivedEnabled {
		n += 2
	}
	if m.StaleRoutesTime != 0 {
		n += 1 + sovGobgp(uint64(m.StaleRoutesTime))
	}
	if m.PeerRestartTime != 0 {
		n += 1 + sovGobgp(uint64(m.PeerRestartTime))
	}
	if m.PeerRestarting {
		n += 2
	}
	if m.LocalRestarting {
		n += 2
	}
	l = len(m.Mode)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	return n
}

func (m *MpGracefulRestartConfig) Size() (n int) {
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	return n
}

func (m *MpGracefulRestartState) Size() (n int) {
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	if m.Received {
		n += 2
	}
	if m.Advertised {
		n += 2
	}
	if m.EndOfRibReceived {
		n += 2
	}
	if m.EndOfRibSent {
		n += 2
	}
	return n
}

func (m *MpGracefulRestart) Size() (n int) {
	var l int
	_ = l
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	return n
}

func (m *AfiSafiConfig) Size() (n int) {
	var l int
	_ = l
	if m.Family != 0 {
		n += 1 + sovGobgp(uint64(m.Family))
	}
	if m.Enabled {
		n += 2
	}
	return n
}

func (m *AfiSafiState) Size() (n int) {
	var l int
	_ = l
	if m.Family != 0 {
		n += 1 + sovGobgp(uint64(m.Family))
	}
	if m.Enabled {
		n += 2
	}
	if m.TotalPaths != 0 {
		n += 1 + sovGobgp(uint64(m.TotalPaths))
	}
	if m.TotalPrefixes != 0 {
		n += 1 + sovGobgp(uint64(m.TotalPrefixes))
	}
	return n
}

func (m *RouteSelectionOptionsConfig) Size() (n int) {
	var l int
	_ = l
	if m.AlwaysCompareMed {
		n += 2
	}
	if m.IgnoreAsPathLength {
		n += 2
	}
	if m.ExternalCompareRouterId {
		n += 2
	}
	if m.AdvertiseInactiveRoutes {
		n += 2
	}
	if m.EnableAigp {
		n += 2
	}
	if m.IgnoreNextHopIgpMetric {
		n += 2
	}
	if m.DisableBestPathSelection {
		n += 2
	}
	return n
}

func (m *RouteSelectionOptionsState) Size() (n int) {
	var l int
	_ = l
	if m.AlwaysCompareMed {
		n += 2
	}
	if m.IgnoreAsPathLength {
		n += 2
	}
	if m.ExternalCompareRouterId {
		n += 2
	}
	if m.AdvertiseInactiveRoutes {
		n += 2
	}
	if m.EnableAigp {
		n += 2
	}
	if m.IgnoreNextHopIgpMetric {
		n += 2
	}
	if m.DisableBestPathSelection {
		n += 2
	}
	return n
}

func (m *RouteSelectionOptions) Size() (n int) {
	var l int
	_ = l
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	return n
}

func (m *UseMultiplePathsConfig) Size() (n int) {
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	return n
}

func (m *UseMultiplePathsState) Size() (n int) {
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	return n
}

func (m *EbgpConfig) Size() (n int) {
	var l int
	_ = l
	if m.AllowMultipleAs {
		n += 2
	}
	if m.MaximumPaths != 0 {
		n += 1 + sovGobgp(uint64(m.MaximumPaths))
	}
	return n
}

func (m *EbgpState) Size() (n int) {
	var l int
	_ = l
	if m.AllowMultipleAs {
		n += 2
	}
	if m.MaximumPaths != 0 {
		n += 1 + sovGobgp(uint64(m.MaximumPaths))
	}
	return n
}

func (m *Ebgp) Size() (n int) {
	var l int
	_ = l
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	return n
}

func (m *IbgpConfig) Size() (n int) {
	var l int
	_ = l
	if m.MaximumPaths != 0 {
		n += 1 + sovGobgp(uint64(m.MaximumPaths))
	}
	return n
}

func (m *IbgpState) Size() (n int) {
	var l int
	_ = l
	if m.MaximumPaths != 0 {
		n += 1 + sovGobgp(uint64(m.MaximumPaths))
	}
	return n
}

func (m *Ibgp) Size() (n int) {
	var l int
	_ = l
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	return n
}

func (m *UseMultiplePaths) Size() (n int) {
	var l int
	_ = l
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.Ebgp != nil {
		l = m.Ebgp.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.Ibgp != nil {
		l = m.Ibgp.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	return n
}

func (m *RouteTargetMembershipConfig) Size() (n int) {
	var l int
	_ = l
	if m.DeferralTime != 0 {
		n += 1 + sovGobgp(uint64(m.DeferralTime))
	}
	return n
}

func (m *RouteTargetMembershipState) Size() (n int) {
	var l int
	_ = l
	if m.DeferralTime != 0 {
		n += 1 + sovGobgp(uint64(m.DeferralTime))
	}
	return n
}

func (m *RouteTargetMembership) Size() (n int) {
	var l int
	_ = l
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	return n
}

func (m *LongLivedGracefulRestartConfig) Size() (n int) {
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	if m.RestartTime != 0 {
		n += 1 + sovGobgp(uint64(m.RestartTime))
	}
	return n
}

func (m *LongLivedGracefulRestartState) Size() (n int) {
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	if m.Received {
		n += 2
	}
	if m.Advertised {
		n += 2
	}
	if m.PeerRestartTime != 0 {
		n += 1 + sovGobgp(uint64(m.PeerRestartTime))
	}
	if m.PeerRestartTimerExpired {
		n += 2
	}
	return n
}

func (m *LongLivedGracefulRestart) Size() (n int) {
	var l int
	_ = l
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	return n
}

func (m *AfiSafi) Size() (n int) {
	var l int
	_ = l
	if m.MpGracefulRestart != nil {
		l = m.MpGracefulRestart.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.ApplyPolicy != nil {
		l = m.ApplyPolicy.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.RouteSelectionOptions != nil {
		l = m.RouteSelectionOptions.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.UseMultiplePaths != nil {
		l = m.UseMultiplePaths.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.PrefixLimits != nil {
		l = m.PrefixLimits.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.RouteTargetMembership != nil {
		l = m.RouteTargetMembership.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.LongLivedGracefulRestart != nil {
		l = m.LongLivedGracefulRestart.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.AddPaths != nil {
		l = m.AddPaths.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	return n
}

func (m *AddPathsConfig) Size() (n int) {
	var l int
	_ = l
	if m.Receive {
		n += 2
	}
	if m.SendMax != 0 {
		n += 1 + sovGobgp(uint64(m.SendMax))
	}
	return n
}

func (m *AddPathsState) Size() (n int) {
	var l int
	_ = l
	if m.Receive {
		n += 2
	}
	if m.SendMax != 0 {
		n += 1 + sovGobgp(uint64(m.SendMax))
	}
	return n
}

func (m *AddPaths) Size() (n int) {
	var l int
	_ = l
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	return n
}

func (m *Prefix) Size() (n int) {
	var l int
	_ = l
	l = len(m.IpPrefix)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.MaskLengthMin != 0 {
		n += 1 + sovGobgp(uint64(m.MaskLengthMin))
	}
	if m.MaskLengthMax != 0 {
		n += 1 + sovGobgp(uint64(m.MaskLengthMax))
	}
	return n
}

func (m *DefinedSet) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovGobgp(uint64(m.Type))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	if len(m.List) > 0 {
		for _, s := range m.List {
			l = len(s)
			n += 1 + l + sovGobgp(uint64(l))
		}
	}
	if len(m.Prefixes) > 0 {
		for _, e := range m.Prefixes {
			l = e.Size()
			n += 1 + l + sovGobgp(uint64(l))
		}
	}
	return n
}

func (m *MatchSet) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovGobgp(uint64(m.Type))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	return n
}

func (m *AsPathLength) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovGobgp(uint64(m.Type))
	}
	if m.Length != 0 {
		n += 1 + sovGobgp(uint64(m.Length))
	}
	return n
}

func (m *Conditions) Size() (n int) {
	var l int
	_ = l
	if m.PrefixSet != nil {
		l = m.PrefixSet.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.NeighborSet != nil {
		l = m.NeighborSet.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.AsPathLength != nil {
		l = m.AsPathLength.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.AsPathSet != nil {
		l = m.AsPathSet.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.CommunitySet != nil {
		l = m.CommunitySet.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.ExtCommunitySet != nil {
		l = m.ExtCommunitySet.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.RpkiResult != 0 {
		n += 1 + sovGobgp(uint64(m.RpkiResult))
	}
	if m.RouteType != 0 {
		n += 1 + sovGobgp(uint64(m.RouteType))
	}
	if m.LargeCommunitySet != nil {
		l = m.LargeCommunitySet.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if len(m.NextHopInList) > 0 {
		for _, s := range m.NextHopInList {
			l = len(s)
			n += 1 + l + sovGobgp(uint64(l))
		}
	}
	return n
}

func (m *CommunityAction) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovGobgp(uint64(m.Type))
	}
	if len(m.Communities) > 0 {
		for _, s := range m.Communities {
			l = len(s)
			n += 1 + l + sovGobgp(uint64(l))
		}
	}
	return n
}

func (m *MedAction) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovGobgp(uint64(m.Type))
	}
	if m.Value != 0 {
		n += 1 + sovGobgp(uint64(m.Value))
	}
	return n
}

func (m *AsPrependAction) Size() (n int) {
	var l int
	_ = l
	if m.Asn != 0 {
		n += 1 + sovGobgp(uint64(m.Asn))
	}
	if m.Repeat != 0 {
		n += 1 + sovGobgp(uint64(m.Repeat))
	}
	if m.UseLeftMost {
		n += 2
	}
	return n
}

func (m *NexthopAction) Size() (n int) {
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.Self {
		n += 2
	}
	return n
}

func (m *LocalPrefAction) Size() (n int) {
	var l int
	_ = l
	if m.Value != 0 {
		n += 1 + sovGobgp(uint64(m.Value))
	}
	return n
}

func (m *Actions) Size() (n int) {
	var l int
	_ = l
	if m.RouteAction != 0 {
		n += 1 + sovGobgp(uint64(m.RouteAction))
	}
	if m.Community != nil {
		l = m.Community.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.Med != nil {
		l = m.Med.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.AsPrepend != nil {
		l = m.AsPrepend.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.ExtCommunity != nil {
		l = m.ExtCommunity.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.Nexthop != nil {
		l = m.Nexthop.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.LocalPref != nil {
		l = m.LocalPref.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.LargeCommunity != nil {
		l = m.LargeCommunity.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	return n
}

func (m *Statement) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.Conditions != nil {
		l = m.Conditions.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.Actions != nil {
		l = m.Actions.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	return n
}

func (m *Policy) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	if len(m.Statements) > 0 {
		for _, e := range m.Statements {
			l = e.Size()
			n += 1 + l + sovGobgp(uint64(l))
		}
	}
	return n
}

func (m *PolicyAssignment) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovGobgp(uint64(m.Type))
	}
	if m.Resource != 0 {
		n += 1 + sovGobgp(uint64(m.Resource))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	if len(m.Policies) > 0 {
		for _, e := range m.Policies {
			l = e.Size()
			n += 1 + l + sovGobgp(uint64(l))
		}
	}
	if m.Default != 0 {
		n += 1 + sovGobgp(uint64(m.Default))
	}
	return n
}

func (m *RoutingPolicy) Size() (n int) {
	var l int
	_ = l
	if len(m.DefinedSet) > 0 {
		for _, e := range m.DefinedSet {
			l = e.Size()
			n += 1 + l + sovGobgp(uint64(l))
		}
	}
	if len(m.PolicyDefinition) > 0 {
		for _, e := range m.PolicyDefinition {
			l = e.Size()
			n += 1 + l + sovGobgp(uint64(l))
		}
	}
	return n
}

func (m *Roa) Size() (n int) {
	var l int
	_ = l
	if m.As != 0 {
		n += 1 + sovGobgp(uint64(m.As))
	}
	if m.Prefixlen != 0 {
		n += 1 + sovGobgp(uint64(m.Prefixlen))
	}
	if m.Maxlen != 0 {
		n += 1 + sovGobgp(uint64(m.Maxlen))
	}
	l = len(m.Prefix)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.Conf != nil {
		l = m.Conf.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	return n
}

func (m *GetRoaRequest) Size() (n int) {
	var l int
	_ = l
	if m.Family != 0 {
		n += 1 + sovGobgp(uint64(m.Family))
	}
	return n
}

func (m *GetRoaResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Roas) > 0 {
		for _, e := range m.Roas {
			l = e.Size()
			n += 1 + l + sovGobgp(uint64(l))
		}
	}
	return n
}

func (m *Vrf) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	l = len(m.Rd)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	if len(m.ImportRt) > 0 {
		for _, b := range m.ImportRt {
			l = len(b)
			n += 1 + l + sovGobgp(uint64(l))
		}
	}
	if len(m.ExportRt) > 0 {
		for _, b := range m.ExportRt {
			l = len(b)
			n += 1 + l + sovGobgp(uint64(l))
		}
	}
	if m.Id != 0 {
		n += 1 + sovGobgp(uint64(m.Id))
	}
	return n
}

func (m *DefaultRouteDistance) Size() (n int) {
	var l int
	_ = l
	if m.ExternalRouteDistance != 0 {
		n += 1 + sovGobgp(uint64(m.ExternalRouteDistance))
	}
	if m.InternalRouteDistance != 0 {
		n += 1 + sovGobgp(uint64(m.InternalRouteDistance))
	}
	return n
}

func (m *Global) Size() (n int) {
	var l int
	_ = l
	if m.As != 0 {
		n += 1 + sovGobgp(uint64(m.As))
	}
	l = len(m.RouterId)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.ListenPort != 0 {
		n += 1 + sovGobgp(uint64(m.ListenPort))
	}
	if len(m.ListenAddresses) > 0 {
		for _, s := range m.ListenAddresses {
			l = len(s)
			n += 1 + l + sovGobgp(uint64(l))
		}
	}
	if len(m.Families) > 0 {
		l = 0
		for _, e := range m.Families {
			l += sovGobgp(uint64(e))
		}
		n += 1 + sovGobgp(uint64(l)) + l
	}
	if m.UseMultiplePaths {
		n += 2
	}
	if m.RouteSelectionOptions != nil {
		l = m.RouteSelectionOptions.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.DefaultRouteDistance != nil {
		l = m.DefaultRouteDistance.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.Confederation != nil {
		l = m.Confederation.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.GracefulRestart != nil {
		l = m.GracefulRestart.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.ApplyPolicy != nil {
		l = m.ApplyPolicy.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	return n
}

func (m *Confederation) Size() (n int) {
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	if m.Identifier != 0 {
		n += 1 + sovGobgp(uint64(m.Identifier))
	}
	if len(m.MemberAsList) > 0 {
		l = 0
		for _, e := range m.MemberAsList {
			l += sovGobgp(uint64(e))
		}
		n += 1 + sovGobgp(uint64(l)) + l
	}
	return n
}

func (m *TableInfo) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovGobgp(uint64(m.Type))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.Family != 0 {
		n += 1 + sovGobgp(uint64(m.Family))
	}
	if m.NumDestination != 0 {
		n += 1 + sovGobgp(uint64(m.NumDestination))
	}
	if m.NumPath != 0 {
		n += 1 + sovGobgp(uint64(m.NumPath))
	}
	if m.NumAccepted != 0 {
		n += 1 + sovGobgp(uint64(m.NumAccepted))
	}
	return n
}

func (m *GetRibInfoRequest) Size() (n int) {
	var l int
	_ = l
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	return n
}

func (m *GetRibInfoResponse) Size() (n int) {
	var l int
	_ = l
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovGobgp(uint64(l))
	}
	return n
}

func (m *AddCollectorRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	l = len(m.DbName)
	if l > 0 {
		n += 1 + l + sovGobgp(uint64(l))
	}
	if m.TableDumpInterval != 0 {
		n += 1 + sovGobgp(uint64(m.TableDumpInterval))
	}
	return n
}

func (m *AddCollectorResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ShutdownRequest) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ShutdownResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func sovGobgp(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozGobgp(x uint64) (n int) {
	return sovGobgp(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GetNeighborRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetNeighborRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetNeighborRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableAdvertised", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableAdvertised = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetNeighborResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetNeighborResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetNeighborResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Peers = append(m.Peers, &Peer{})
			if err := m.Peers[len(m.Peers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Arguments) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Arguments: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Arguments: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resource", wireType)
			}
			m.Resource = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Resource |= (Resource(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Family", wireType)
			}
			m.Family = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Family |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Current", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Current = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddPathRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddPathRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddPathRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resource", wireType)
			}
			m.Resource = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Resource |= (Resource(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VrfId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VrfId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Path == nil {
				m.Path = &Path{}
			}
			if err := m.Path.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddPathResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddPathResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddPathResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = append(m.Uuid[:0], dAtA[iNdEx:postIndex]...)
			if m.Uuid == nil {
				m.Uuid = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeletePathRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeletePathRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeletePathRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resource", wireType)
			}
			m.Resource = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Resource |= (Resource(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VrfId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VrfId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Family", wireType)
			}
			m.Family = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Family |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Path == nil {
				m.Path = &Path{}
			}
			if err := m.Path.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = append(m.Uuid[:0], dAtA[iNdEx:postIndex]...)
			if m.Uuid == nil {
				m.Uuid = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeletePathResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeletePathResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeletePathResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddNeighborRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddNeighborRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddNeighborRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Peer == nil {
				m.Peer = &Peer{}
			}
			if err := m.Peer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddNeighborResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddNeighborResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddNeighborResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteNeighborRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteNeighborRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteNeighborRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Peer == nil {
				m.Peer = &Peer{}
			}
			if err := m.Peer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteNeighborResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteNeighborResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteNeighborResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateNeighborRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateNeighborRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateNeighborRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Peer == nil {
				m.Peer = &Peer{}
			}
			if err := m.Peer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoSoftResetIn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DoSoftResetIn = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateNeighborResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateNeighborResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateNeighborResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedsSoftResetIn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NeedsSoftResetIn = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddPeerGroupRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddPeerGroupRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddPeerGroupRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PeerGroup == nil {
				m.PeerGroup = &PeerGroup{}
			}
			if err := m.PeerGroup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddPeerGroupResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddPeerGroupResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddPeerGroupResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeletePeerGroupRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeletePeerGroupRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeletePeerGroupRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PeerGroup == nil {
				m.PeerGroup = &PeerGroup{}
			}
			if err := m.PeerGroup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeletePeerGroupResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeletePeerGroupResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeletePeerGroupResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdatePeerGroupRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdatePeerGroupRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdatePeerGroupRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PeerGroup == nil {
				m.PeerGroup = &PeerGroup{}
			}
			if err := m.PeerGroup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoSoftResetIn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DoSoftResetIn = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdatePeerGroupResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdatePeerGroupResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdatePeerGroupResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedsSoftResetIn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NeedsSoftResetIn = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddDynamicNeighborRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddDynamicNeighborRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddDynamicNeighborRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DynamicNeighbor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DynamicNeighbor == nil {
				m.DynamicNeighbor = &DynamicNeighbor{}
			}
			if err := m.DynamicNeighbor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddDynamicNeighborResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddDynamicNeighborResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddDynamicNeighborResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResetNeighborRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResetNeighborRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResetNeighborRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Communication", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Communication = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResetNeighborResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResetNeighborResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResetNeighborResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SoftResetNeighborRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SoftResetNeighborRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SoftResetNeighborRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			m.Direction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Direction |= (SoftResetNeighborRequest_SoftResetDirection(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SoftResetNeighborResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SoftResetNeighborResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SoftResetNeighborResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShutdownNeighborRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShutdownNeighborRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShutdownNeighborRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Communication", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Communication = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShutdownNeighborResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShutdownNeighborResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShutdownNeighborResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnableNeighborRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnableNeighborRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnableNeighborRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnableNeighborResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnableNeighborResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnableNeighborResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DisableNeighborRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DisableNeighborRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DisableNeighborRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Communication", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Communication = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DisableNeighborResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DisableNeighborResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DisableNeighborResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdatePolicyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdatePolicyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdatePolicyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sets = append(m.Sets, &DefinedSet{})
			if err := m.Sets[len(m.Sets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Policies = append(m.Policies, &Policy{})
			if err := m.Policies[len(m.Policies)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdatePolicyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdatePolicyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdatePolicyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnableMrtRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnableMrtRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnableMrtRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DumpType", wireType)
			}
			m.DumpType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DumpType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filename", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filename = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			m.Interval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Interval |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnableMrtResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnableMrtResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnableMrtResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DisableMrtRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DisableMrtRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DisableMrtRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DisableMrtResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DisableMrtResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DisableMrtResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InjectMrtRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InjectMrtRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InjectMrtRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resource", wireType)
			}
			m.Resource = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Resource |= (Resource(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VrfId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VrfId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paths", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Paths = append(m.Paths, &Path{})
			if err := m.Paths[len(m.Paths)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InjectMrtResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InjectMrtResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InjectMrtResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddBmpRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddBmpRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddBmpRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (AddBmpRequest_MonitoringPolicy(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddBmpResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddBmpResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddBmpResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteBmpRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteBmpRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteBmpRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteBmpResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteBmpResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteBmpResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MonitorRibRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MonitorRibRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MonitorRibRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Table == nil {
				m.Table = &Table{}
			}
			if err := m.Table.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Current", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Current = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RPKIConf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RPKIConf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RPKIConf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemotePort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemotePort = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RPKIState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RPKIState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RPKIState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uptime", wireType)
			}
			m.Uptime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uptime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Downtime", wireType)
			}
			m.Downtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Downtime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Up", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Up = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordIpv4", wireType)
			}
			m.RecordIpv4 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecordIpv4 |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordIpv6", wireType)
			}
			m.RecordIpv6 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecordIpv6 |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixIpv4", wireType)
			}
			m.PrefixIpv4 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrefixIpv4 |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixIpv6", wireType)
			}
			m.PrefixIpv6 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrefixIpv6 |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Serial", wireType)
			}
			m.Serial = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Serial |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceivedIpv4", wireType)
			}
			m.ReceivedIpv4 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReceivedIpv4 |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceivedIpv6", wireType)
			}
			m.ReceivedIpv6 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReceivedIpv6 |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerialNotify", wireType)
			}
			m.SerialNotify = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SerialNotify |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheReset", wireType)
			}
			m.CacheReset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CacheReset |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheResponse", wireType)
			}
			m.CacheResponse = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CacheResponse |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndOfData", wireType)
			}
			m.EndOfData = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndOfData |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			m.Error = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Error |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerialQuery", wireType)
			}
			m.SerialQuery = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SerialQuery |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResetQuery", wireType)
			}
			m.ResetQuery = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResetQuery |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Rpki) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Rpki: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Rpki: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Conf == nil {
				m.Conf = &RPKIConf{}
			}
			if err := m.Conf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &RPKIState{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRpkiRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRpkiRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRpkiRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Family", wireType)
			}
			m.Family = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Family |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRpkiResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRpkiResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRpkiResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Servers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Servers = append(m.Servers, &Rpki{})
			if err := m.Servers[len(m.Servers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddRpkiRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddRpkiRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddRpkiRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lifetime", wireType)
			}
			m.Lifetime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lifetime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddRpkiResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddRpkiResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddRpkiResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteRpkiRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteRpkiRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteRpkiRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteRpkiResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteRpkiResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteRpkiResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnableRpkiRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnableRpkiRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnableRpkiRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnableRpkiResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnableRpkiResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnableRpkiResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DisableRpkiRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DisableRpkiRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DisableRpkiRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DisableRpkiResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DisableRpkiResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DisableRpkiResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResetRpkiRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResetRpkiRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResetRpkiRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResetRpkiResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResetRpkiResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResetRpkiResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SoftResetRpkiRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SoftResetRpkiRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SoftResetRpkiRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SoftResetRpkiResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SoftResetRpkiResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SoftResetRpkiResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnableZebraRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnableZebraRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnableZebraRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteTypes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteTypes = append(m.RouteTypes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NexthopTriggerEnable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NexthopTriggerEnable = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NexthopTriggerDelay", wireType)
			}
			m.NexthopTriggerDelay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NexthopTriggerDelay |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnableZebraResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnableZebraResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnableZebraResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetVrfRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetVrfRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetVrfRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetVrfResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetVrfResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetVrfResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vrfs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vrfs = append(m.Vrfs, &Vrf{})
			if err := m.Vrfs[len(m.Vrfs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddVrfRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddVrfRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddVrfRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vrf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Vrf == nil {
				m.Vrf = &Vrf{}
			}
			if err := m.Vrf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddVrfResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddVrfResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddVrfResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteVrfRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteVrfRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteVrfRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vrf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Vrf == nil {
				m.Vrf = &Vrf{}
			}
			if err := m.Vrf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteVrfResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteVrfResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteVrfResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetDefinedSetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetDefinedSetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetDefinedSetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (DefinedType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetDefinedSetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetDefinedSetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetDefinedSetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sets = append(m.Sets, &DefinedSet{})
			if err := m.Sets[len(m.Sets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddDefinedSetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddDefinedSetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddDefinedSetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Set", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Set == nil {
				m.Set = &DefinedSet{}
			}
			if err := m.Set.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddDefinedSetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddDefinedSetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddDefinedSetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteDefinedSetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteDefinedSetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteDefinedSetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Set", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Set == nil {
				m.Set = &DefinedSet{}
			}
			if err := m.Set.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field All", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.All = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteDefinedSetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteDefinedSetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteDefinedSetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceDefinedSetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceDefinedSetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceDefinedSetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Set", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Set == nil {
				m.Set = &DefinedSet{}
			}
			if err := m.Set.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceDefinedSetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceDefinedSetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceDefinedSetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetStatementRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetStatementRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetStatementRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetStatementResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetStatementResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetStatementResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Statements", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Statements = append(m.Statements, &Statement{})
			if err := m.Statements[len(m.Statements)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddStatementRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddStatementRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddStatementRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Statement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Statement == nil {
				m.Statement = &Statement{}
			}
			if err := m.Statement.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddStatementResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddStatementResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddStatementResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteStatementRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteStatementRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteStatementRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Statement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Statement == nil {
				m.Statement = &Statement{}
			}
			if err := m.Statement.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field All", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.All = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteStatementResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteStatementResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteStatementResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceStatementRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceStatementRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceStatementRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Statement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Statement == nil {
				m.Statement = &Statement{}
			}
			if err := m.Statement.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceStatementResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceStatementResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceStatementResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetPolicyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPolicyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPolicyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetPolicyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPolicyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPolicyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Policies = append(m.Policies, &Policy{})
			if err := m.Policies[len(m.Policies)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddPolicyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddPolicyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddPolicyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Policy == nil {
				m.Policy = &Policy{}
			}
			if err := m.Policy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferExistingStatements", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReferExistingStatements = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddPolicyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddPolicyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddPolicyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeletePolicyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeletePolicyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeletePolicyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Policy == nil {
				m.Policy = &Policy{}
			}
			if err := m.Policy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreserveStatements", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PreserveStatements = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field All", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.All = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeletePolicyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeletePolicyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeletePolicyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplacePolicyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplacePolicyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplacePolicyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Policy == nil {
				m.Policy = &Policy{}
			}
			if err := m.Policy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferExistingStatements", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReferExistingStatements = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreserveStatements", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PreserveStatements = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplacePolicyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplacePolicyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplacePolicyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetPolicyAssignmentRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPolicyAssignmentRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPolicyAssignmentRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assignment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Assignment == nil {
				m.Assignment = &PolicyAssignment{}
			}
			if err := m.Assignment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetPolicyAssignmentResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPolicyAssignmentResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPolicyAssignmentResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assignment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Assignment == nil {
				m.Assignment = &PolicyAssignment{}
			}
			if err := m.Assignment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddPolicyAssignmentRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddPolicyAssignmentRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddPolicyAssignmentRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assignment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Assignment == nil {
				m.Assignment = &PolicyAssignment{}
			}
			if err := m.Assignment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddPolicyAssignmentResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddPolicyAssignmentResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddPolicyAssignmentResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeletePolicyAssignmentRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeletePolicyAssignmentRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeletePolicyAssignmentRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assignment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Assignment == nil {
				m.Assignment = &PolicyAssignment{}
			}
			if err := m.Assignment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field All", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.All = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeletePolicyAssignmentResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeletePolicyAssignmentResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeletePolicyAssignmentResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplacePolicyAssignmentRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplacePolicyAssignmentRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplacePolicyAssignmentRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assignment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Assignment == nil {
				m.Assignment = &PolicyAssignment{}
			}
			if err := m.Assignment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplacePolicyAssignmentResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplacePolicyAssignmentResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplacePolicyAssignmentResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetServerRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetServerRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetServerRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetServerResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetServerResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetServerResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Global", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Global == nil {
				m.Global = &Global{}
			}
			if err := m.Global.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StartServerRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartServerRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartServerRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Global", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Global == nil {
				m.Global = &Global{}
			}
			if err := m.Global.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StartServerResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartServerResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartServerResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StopServerRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StopServerRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StopServerRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StopServerResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StopServerResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StopServerResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RPKIValidation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RPKIValidation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RPKIValidation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (RPKIValidation_State(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			m.Reason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reason |= (RPKIValidation_Reason(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Matched", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Matched = append(m.Matched, &Roa{})
			if err := m.Matched[len(m.Matched)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnmatchedAs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnmatchedAs = append(m.UnmatchedAs, &Roa{})
			if err := m.UnmatchedAs[len(m.UnmatchedAs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnmatchedLength", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnmatchedLength = append(m.UnmatchedLength, &Roa{})
			if err := m.UnmatchedLength[len(m.UnmatchedLength)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Path) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Path: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Path: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nlri", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nlri = append(m.Nlri[:0], dAtA[iNdEx:postIndex]...)
			if m.Nlri == nil {
				m.Nlri = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pattrs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pattrs = append(m.Pattrs, make([]byte, postIndex-iNdEx))
			copy(m.Pattrs[len(m.Pattrs)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Age", wireType)
			}
			m.Age = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Age |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Best", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Best = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsWithdraw", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsWithdraw = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validation", wireType)
			}
			m.Validation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Validation |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidationDetail", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ValidationDetail == nil {
				m.ValidationDetail = &RPKIValidation{}
			}
			if err := m.ValidationDetail.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoImplicitWithdraw", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoImplicitWithdraw = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Family", wireType)
			}
			m.Family = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Family |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceAsn", wireType)
			}
			m.SourceAsn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceAsn |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filtered", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Filtered = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stale", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Stale = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFromExternal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFromExternal = bool(v != 0)
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeighborIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NeighborIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = append(m.Uuid[:0], dAtA[iNdEx:postIndex]...)
			if m.Uuid == nil {
				m.Uuid = []byte{}
			}
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsNexthopInvalid", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsNexthopInvalid = bool(v != 0)
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identifier", wireType)
			}
			m.Identifier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Identifier |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalIdentifier", wireType)
			}
			m.LocalIdentifier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocalIdentifier |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyNlri", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AnyNlri == nil {
				m.AnyNlri = &google_protobuf.Any{}
			}
			if err := m.AnyNlri.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyPattrs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AnyPattrs = append(m.AnyPattrs, &google_protobuf.Any{})
			if err := m.AnyPattrs[len(m.AnyPattrs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Destination) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Destination: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Destination: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paths", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Paths = append(m.Paths, &Path{})
			if err := m.Paths[len(m.Paths)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LongerPrefixes", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LongerPrefixes = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShorterPrefixes", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ShorterPrefixes = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Table) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Table: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Table: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (Resource(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Family", wireType)
			}
			m.Family = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Family |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destinations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destinations = append(m.Destinations, &Destination{})
			if err := m.Destinations[len(m.Destinations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PostPolicy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PostPolicy = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRibRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRibRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRibRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Table == nil {
				m.Table = &Table{}
			}
			if err := m.Table.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRibResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRibResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRibResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Table == nil {
				m.Table = &Table{}
			}
			if err := m.Table.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableLookupPrefix) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableLookupPrefix: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableLookupPrefix: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LookupOption", wireType)
			}
			m.LookupOption = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LookupOption |= (TableLookupOption(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetPathRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPathRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPathRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (Resource(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Family", wireType)
			}
			m.Family = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Family |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefixes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefixes = append(m.Prefixes, &TableLookupPrefix{})
			if err := m.Prefixes[len(m.Prefixes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidateRibRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidateRibRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidateRibRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (Resource(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Family", wireType)
			}
			m.Family = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Family |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidateRibResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidateRibResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidateRibResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Peer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Peer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Peer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGobgp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Families = append(m.Families, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGobgp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGobgp
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGobgp
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Families = append(m.Families, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Families", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApplyPolicy == nil {
				m.ApplyPolicy = &ApplyPolicy{}
			}
			if err := m.ApplyPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Conf == nil {
				m.Conf = &PeerConf{}
			}
			if err := m.Conf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EbgpMultihop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EbgpMultihop == nil {
				m.EbgpMultihop = &EbgpMultihop{}
			}
			if err := m.EbgpMultihop.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteReflector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RouteReflector == nil {
				m.RouteReflector = &RouteReflector{}
			}
			if err := m.RouteReflector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &PeerState{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timers == nil {
				m.Timers = &Timers{}
			}
			if err := m.Timers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transport", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Transport == nil {
				m.Transport = &Transport{}
			}
			if err := m.Transport.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteServer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RouteServer == nil {
				m.RouteServer = &RouteServer{}
			}
			if err := m.RouteServer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GracefulRestart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GracefulRestart == nil {
				m.GracefulRestart = &GracefulRestart{}
			}
			if err := m.GracefulRestart.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AfiSafis", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AfiSafis = append(m.AfiSafis, &AfiSafi{})
			if err := m.AfiSafis[len(m.AfiSafis)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddPaths", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AddPaths == nil {
				m.AddPaths = &AddPaths{}
			}
			if err := m.AddPaths.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PeerGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeerGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeerGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGobgp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Families = append(m.Families, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGobgp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGobgp
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGobgp
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Families = append(m.Families, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Families", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApplyPolicy == nil {
				m.ApplyPolicy = &ApplyPolicy{}
			}
			if err := m.ApplyPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Conf == nil {
				m.Conf = &PeerGroupConf{}
			}
			if err := m.Conf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EbgpMultihop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EbgpMultihop == nil {
				m.EbgpMultihop = &EbgpMultihop{}
			}
			if err := m.EbgpMultihop.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteReflector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RouteReflector == nil {
				m.RouteReflector = &RouteReflector{}
			}
			if err := m.RouteReflector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &PeerGroupState{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timers == nil {
				m.Timers = &Timers{}
			}
			if err := m.Timers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transport", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Transport == nil {
				m.Transport = &Transport{}
			}
			if err := m.Transport.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteServer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RouteServer == nil {
				m.RouteServer = &RouteServer{}
			}
			if err := m.RouteServer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GracefulRestart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GracefulRestart == nil {
				m.GracefulRestart = &GracefulRestart{}
			}
			if err := m.GracefulRestart.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AfiSafis", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AfiSafis = append(m.AfiSafis, &AfiSafi{})
			if err := m.AfiSafis[len(m.AfiSafis)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddPaths", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AddPaths == nil {
				m.AddPaths = &AddPaths{}
			}
			if err := m.AddPaths.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DynamicNeighbor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DynamicNeighbor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DynamicNeighbor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerGroup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerGroup = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplyPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplyPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplyPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InPolicy == nil {
				m.InPolicy = &PolicyAssignment{}
			}
			if err := m.InPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExportPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExportPolicy == nil {
				m.ExportPolicy = &PolicyAssignment{}
			}
			if err := m.ExportPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImportPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ImportPolicy == nil {
				m.ImportPolicy = &PolicyAssignment{}
			}
			if err := m.ImportPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrefixLimit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrefixLimit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrefixLimit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Family", wireType)
			}
			m.Family = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Family |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxPrefixes", wireType)
			}
			m.MaxPrefixes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxPrefixes |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShutdownThresholdPct", wireType)
			}
			m.ShutdownThresholdPct = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShutdownThresholdPct |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PeerConf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeerConf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeerConf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthPassword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthPassword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalAs", wireType)
			}
			m.LocalAs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocalAs |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeighborAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NeighborAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerAs", wireType)
			}
			m.PeerAs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerAs |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerGroup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerGroup = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerType", wireType)
			}
			m.PeerType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemovePrivateAs", wireType)
			}
			m.RemovePrivateAs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemovePrivateAs |= (PeerConf_RemovePrivateAs(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteFlapDamping", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RouteFlapDamping = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendCommunity", wireType)
			}
			m.SendCommunity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SendCommunity |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteCap", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoteCap = append(m.RemoteCap, make([]byte, postIndex-iNdEx))
			copy(m.RemoteCap[len(m.RemoteCap)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalCap", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalCap = append(m.LocalCap, make([]byte, postIndex-iNdEx))
			copy(m.LocalCap[len(m.LocalCap)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixLimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrefixLimits = append(m.PrefixLimits, &PrefixLimit{})
			if err := m.PrefixLimits[len(m.PrefixLimits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeighborInterface", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NeighborInterface = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vrf", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vrf = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowOwnAs", wireType)
			}
			m.AllowOwnAs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AllowOwnAs |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplacePeerAs", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReplacePeerAs = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PeerGroupConf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeerGroupConf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeerGroupConf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthPassword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthPassword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalAs", wireType)
			}
			m.LocalAs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocalAs |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerAs", wireType)
			}
			m.PeerAs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerAs |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerGroupName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerGroupName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerType", wireType)
			}
			m.PeerType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemovePrivateAs", wireType)
			}
			m.RemovePrivateAs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemovePrivateAs |= (PeerGroupConf_RemovePrivateAs(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteFlapDamping", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RouteFlapDamping = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendCommunity", wireType)
			}
			m.SendCommunity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SendCommunity |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PeerGroupState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeerGroupState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeerGroupState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthPassword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthPassword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalAs", wireType)
			}
			m.LocalAs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocalAs |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerAs", wireType)
			}
			m.PeerAs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerAs |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerGroupName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerGroupName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerType", wireType)
			}
			m.PeerType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemovePrivateAs", wireType)
			}
			m.RemovePrivateAs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemovePrivateAs |= (PeerGroupState_RemovePrivateAs(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteFlapDamping", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RouteFlapDamping = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendCommunity", wireType)
			}
			m.SendCommunity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SendCommunity |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalPaths", wireType)
			}
			m.TotalPaths = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalPaths |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalPrefixes", wireType)
			}
			m.TotalPrefixes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalPrefixes |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EbgpMultihop) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EbgpMultihop: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EbgpMultihop: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultihopTtl", wireType)
			}
			m.MultihopTtl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MultihopTtl |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteReflector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteReflector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteReflector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteReflectorClient", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RouteReflectorClient = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteReflectorClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteReflectorClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PeerState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeerState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeerState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthPassword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthPassword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalAs", wireType)
			}
			m.LocalAs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocalAs |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Messages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Messages == nil {
				m.Messages = &Messages{}
			}
			if err := m.Messages.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeighborAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NeighborAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerAs", wireType)
			}
			m.PeerAs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerAs |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerGroup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerGroup = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerType", wireType)
			}
			m.PeerType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Queues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Queues == nil {
				m.Queues = &Queues{}
			}
			if err := m.Queues.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemovePrivateAs", wireType)
			}
			m.RemovePrivateAs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemovePrivateAs |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteFlapDamping", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RouteFlapDamping = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendCommunity", wireType)
			}
			m.SendCommunity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SendCommunity |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionState", wireType)
			}
			m.SessionState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionState |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportedCapabilities", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SupportedCapabilities = append(m.SupportedCapabilities, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgpState", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BgpState = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminState", wireType)
			}
			m.AdminState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdminState |= (PeerState_AdminState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Received", wireType)
			}
			m.Received = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Received |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Accepted", wireType)
			}
			m.Accepted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Accepted |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Advertised", wireType)
			}
			m.Advertised = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Advertised |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutQ", wireType)
			}
			m.OutQ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutQ |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flops", wireType)
			}
			m.Flops = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flops |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Messages) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Messages: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Messages: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Received", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Received == nil {
				m.Received = &Message{}
			}
			if err := m.Received.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sent == nil {
				m.Sent = &Message{}
			}
			if err := m.Sent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Message) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NOTIFICATION", wireType)
			}
			m.NOTIFICATION = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NOTIFICATION |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UPDATE", wireType)
			}
			m.UPDATE = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UPDATE |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OPEN", wireType)
			}
			m.OPEN = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OPEN |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KEEPALIVE", wireType)
			}
			m.KEEPALIVE = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KEEPALIVE |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field REFRESH", wireType)
			}
			m.REFRESH = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.REFRESH |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DISCARDED", wireType)
			}
			m.DISCARDED = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DISCARDED |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TOTAL", wireType)
			}
			m.TOTAL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TOTAL |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Queues) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Queues: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Queues: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Input", wireType)
			}
			m.Input = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Input |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			m.Output = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Output |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Timers) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Timers: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Timers: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = &TimersConfig{}
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &TimersState{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimersConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimersConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimersConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectRetry", wireType)
			}
			m.ConnectRetry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConnectRetry |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HoldTime", wireType)
			}
			m.HoldTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HoldTime |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeepaliveInterval", wireType)
			}
			m.KeepaliveInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeepaliveInterval |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinimumAdvertisementInterval", wireType)
			}
			m.MinimumAdvertisementInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinimumAdvertisementInterval |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimersState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimersState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimersState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectRetry", wireType)
			}
			m.ConnectRetry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConnectRetry |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HoldTime", wireType)
			}
			m.HoldTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HoldTime |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeepaliveInterval", wireType)
			}
			m.KeepaliveInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeepaliveInterval |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinimumAdvertisementInterval", wireType)
			}
			m.MinimumAdvertisementInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinimumAdvertisementInterval |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NegotiatedHoldTime", wireType)
			}
			m.NegotiatedHoldTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NegotiatedHoldTime |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uptime", wireType)
			}
			m.Uptime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uptime |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Downtime", wireType)
			}
			m.Downtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Downtime |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Transport) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Transport: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Transport: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalPort", wireType)
			}
			m.LocalPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocalPort |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MtuDiscovery", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MtuDiscovery = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PassiveMode", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PassiveMode = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoteAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemotePort", wireType)
			}
			m.RemotePort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemotePort |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpMss", wireType)
			}
			m.TcpMss = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpMss |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteServer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteServer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteServer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteServerClient", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RouteServerClient = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GracefulRestart) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GracefulRestart: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GracefulRestart: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RestartTime", wireType)
			}
			m.RestartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RestartTime |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HelperOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HelperOnly = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeferralTime", wireType)
			}
			m.DeferralTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeferralTime |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotificationEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NotificationEnabled = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LonglivedEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LonglivedEnabled = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaleRoutesTime", wireType)
			}
			m.StaleRoutesTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StaleRoutesTime |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerRestartTime", wireType)
			}
			m.PeerRestartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerRestartTime |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerRestarting", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PeerRestarting = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalRestarting", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LocalRestarting = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MpGracefulRestartConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MpGracefulRestartConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MpGracefulRestartConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MpGracefulRestartState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MpGracefulRestartState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MpGracefulRestartState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Received", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Received = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Advertised", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Advertised = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndOfRibReceived", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EndOfRibReceived = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndOfRibSent", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EndOfRibSent = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MpGracefulRestart) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MpGracefulRestart: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MpGracefulRestart: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = &MpGracefulRestartConfig{}
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &MpGracefulRestartState{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AfiSafiConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AfiSafiConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AfiSafiConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Family", wireType)
			}
			m.Family = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Family |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AfiSafiState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AfiSafiState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AfiSafiState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Family", wireType)
			}
			m.Family = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Family |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalPaths", wireType)
			}
			m.TotalPaths = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalPaths |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalPrefixes", wireType)
			}
			m.TotalPrefixes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalPrefixes |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteSelectionOptionsConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteSelectionOptionsConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteSelectionOptionsConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlwaysCompareMed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AlwaysCompareMed = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreAsPathLength", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IgnoreAsPathLength = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalCompareRouterId", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExternalCompareRouterId = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdvertiseInactiveRoutes", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AdvertiseInactiveRoutes = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableAigp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableAigp = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreNextHopIgpMetric", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IgnoreNextHopIgpMetric = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableBestPathSelection", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableBestPathSelection = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteSelectionOptionsState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteSelectionOptionsState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteSelectionOptionsState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlwaysCompareMed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AlwaysCompareMed = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreAsPathLength", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IgnoreAsPathLength = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalCompareRouterId", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExternalCompareRouterId = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdvertiseInactiveRoutes", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AdvertiseInactiveRoutes = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableAigp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableAigp = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreNextHopIgpMetric", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IgnoreNextHopIgpMetric = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableBestPathSelection", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableBestPathSelection = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteSelectionOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteSelectionOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteSelectionOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = &RouteSelectionOptionsConfig{}
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &RouteSelectionOptionsState{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UseMultiplePathsConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UseMultiplePathsConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UseMultiplePathsConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UseMultiplePathsState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UseMultiplePathsState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UseMultiplePathsState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EbgpConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EbgpConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EbgpConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowMultipleAs", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowMultipleAs = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaximumPaths", wireType)
			}
			m.MaximumPaths = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaximumPaths |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EbgpState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EbgpState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EbgpState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowMultipleAs", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowMultipleAs = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaximumPaths", wireType)
			}
			m.MaximumPaths = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaximumPaths |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ebgp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ebgp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ebgp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = &EbgpConfig{}
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &EbgpState{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IbgpConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IbgpConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IbgpConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaximumPaths", wireType)
			}
			m.MaximumPaths = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaximumPaths |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IbgpState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IbgpState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IbgpState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaximumPaths", wireType)
			}
			m.MaximumPaths = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaximumPaths |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ibgp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ibgp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ibgp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = &IbgpConfig{}
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &IbgpState{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UseMultiplePaths) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UseMultiplePaths: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UseMultiplePaths: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = &UseMultiplePathsConfig{}
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &UseMultiplePathsState{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ebgp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ebgp == nil {
				m.Ebgp = &Ebgp{}
			}
			if err := m.Ebgp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ibgp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ibgp == nil {
				m.Ibgp = &Ibgp{}
			}
			if err := m.Ibgp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteTargetMembershipConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteTargetMembershipConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteTargetMembershipConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeferralTime", wireType)
			}
			m.DeferralTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeferralTime |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteTargetMembershipState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteTargetMembershipState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteTargetMembershipState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeferralTime", wireType)
			}
			m.DeferralTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeferralTime |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteTargetMembership) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteTargetMembership: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteTargetMembership: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = &RouteTargetMembershipConfig{}
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &RouteTargetMembershipState{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LongLivedGracefulRestartConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LongLivedGracefulRestartConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LongLivedGracefulRestartConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RestartTime", wireType)
			}
			m.RestartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RestartTime |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LongLivedGracefulRestartState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LongLivedGracefulRestartState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LongLivedGracefulRestartState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Received", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Received = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Advertised", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Advertised = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerRestartTime", wireType)
			}
			m.PeerRestartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerRestartTime |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerRestartTimerExpired", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PeerRestartTimerExpired = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LongLivedGracefulRestart) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LongLivedGracefulRestart: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LongLivedGracefulRestart: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = &LongLivedGracefulRestartConfig{}
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &LongLivedGracefulRestartState{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AfiSafi) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AfiSafi: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AfiSafi: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MpGracefulRestart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MpGracefulRestart == nil {
				m.MpGracefulRestart = &MpGracefulRestart{}
			}
			if err := m.MpGracefulRestart.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = &AfiSafiConfig{}
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApplyPolicy == nil {
				m.ApplyPolicy = &ApplyPolicy{}
			}
			if err := m.ApplyPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteSelectionOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RouteSelectionOptions == nil {
				m.RouteSelectionOptions = &RouteSelectionOptions{}
			}
			if err := m.RouteSelectionOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseMultiplePaths", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UseMultiplePaths == nil {
				m.UseMultiplePaths = &UseMultiplePaths{}
			}
			if err := m.UseMultiplePaths.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixLimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrefixLimits == nil {
				m.PrefixLimits = &PrefixLimit{}
			}
			if err := m.PrefixLimits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteTargetMembership", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RouteTargetMembership == nil {
				m.RouteTargetMembership = &RouteTargetMembership{}
			}
			if err := m.RouteTargetMembership.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LongLivedGracefulRestart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LongLivedGracefulRestart == nil {
				m.LongLivedGracefulRestart = &LongLivedGracefulRestart{}
			}
			if err := m.LongLivedGracefulRestart.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddPaths", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AddPaths == nil {
				m.AddPaths = &AddPaths{}
			}
			if err := m.AddPaths.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddPathsConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddPathsConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddPathsConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Receive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Receive = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendMax", wireType)
			}
			m.SendMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SendMax |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddPathsState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddPathsState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddPathsState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Receive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Receive = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendMax", wireType)
			}
			m.SendMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SendMax |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddPaths) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddPaths: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddPaths: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = &AddPathsConfig{}
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &AddPathsState{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Prefix) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Prefix: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Prefix: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpPrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaskLengthMin", wireType)
			}
			m.MaskLengthMin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaskLengthMin |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaskLengthMax", wireType)
			}
			m.MaskLengthMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaskLengthMax |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefinedSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefinedSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefinedSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (DefinedType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefixes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefixes = append(m.Prefixes, &Prefix{})
			if err := m.Prefixes[len(m.Prefixes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatchSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatchSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatchSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (MatchType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AsPathLength) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AsPathLength: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AsPathLength: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (AsPathLengthType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Conditions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Conditions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Conditions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrefixSet == nil {
				m.PrefixSet = &MatchSet{}
			}
			if err := m.PrefixSet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeighborSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NeighborSet == nil {
				m.NeighborSet = &MatchSet{}
			}
			if err := m.NeighborSet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsPathLength", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AsPathLength == nil {
				m.AsPathLength = &AsPathLength{}
			}
			if err := m.AsPathLength.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsPathSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AsPathSet == nil {
				m.AsPathSet = &MatchSet{}
			}
			if err := m.AsPathSet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommunitySet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CommunitySet == nil {
				m.CommunitySet = &MatchSet{}
			}
			if err := m.CommunitySet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtCommunitySet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExtCommunitySet == nil {
				m.ExtCommunitySet = &MatchSet{}
			}
			if err := m.ExtCommunitySet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RpkiResult", wireType)
			}
			m.RpkiResult = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RpkiResult |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteType", wireType)
			}
			m.RouteType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouteType |= (Conditions_RouteType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LargeCommunitySet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LargeCommunitySet == nil {
				m.LargeCommunitySet = &MatchSet{}
			}
			if err := m.LargeCommunitySet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextHopInList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextHopInList = append(m.NextHopInList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommunityAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommunityAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommunityAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (CommunityActionType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Communities", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Communities = append(m.Communities, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MedAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MedAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MedAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (MedActionType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AsPrependAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AsPrependAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AsPrependAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asn", wireType)
			}
			m.Asn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Asn |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repeat", wireType)
			}
			m.Repeat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Repeat |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseLeftMost", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseLeftMost = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NexthopAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NexthopAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NexthopAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Self", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Self = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocalPrefAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocalPrefAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocalPrefAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Actions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Actions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Actions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteAction", wireType)
			}
			m.RouteAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouteAction |= (RouteAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Community", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Community == nil {
				m.Community = &CommunityAction{}
			}
			if err := m.Community.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Med", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Med == nil {
				m.Med = &MedAction{}
			}
			if err := m.Med.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsPrepend", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AsPrepend == nil {
				m.AsPrepend = &AsPrependAction{}
			}
			if err := m.AsPrepend.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtCommunity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExtCommunity == nil {
				m.ExtCommunity = &CommunityAction{}
			}
			if err := m.ExtCommunity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nexthop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Nexthop == nil {
				m.Nexthop = &NexthopAction{}
			}
			if err := m.Nexthop.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalPref", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LocalPref == nil {
				m.LocalPref = &LocalPrefAction{}
			}
			if err := m.LocalPref.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LargeCommunity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LargeCommunity == nil {
				m.LargeCommunity = &CommunityAction{}
			}
			if err := m.LargeCommunity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Statement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Statement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Statement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Conditions == nil {
				m.Conditions = &Conditions{}
			}
			if err := m.Conditions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Actions == nil {
				m.Actions = &Actions{}
			}
			if err := m.Actions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Policy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Policy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Policy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Statements", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Statements = append(m.Statements, &Statement{})
			if err := m.Statements[len(m.Statements)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicyAssignment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicyAssignment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicyAssignment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (PolicyType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resource", wireType)
			}
			m.Resource = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Resource |= (Resource(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Policies = append(m.Policies, &Policy{})
			if err := m.Policies[len(m.Policies)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Default", wireType)
			}
			m.Default = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Default |= (RouteAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoutingPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoutingPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoutingPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefinedSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefinedSet = append(m.DefinedSet, &DefinedSet{})
			if err := m.DefinedSet[len(m.DefinedSet)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicyDefinition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PolicyDefinition = append(m.PolicyDefinition, &Policy{})
			if err := m.PolicyDefinition[len(m.PolicyDefinition)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Roa) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Roa: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Roa: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field As", wireType)
			}
			m.As = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.As |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefixlen", wireType)
			}
			m.Prefixlen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Prefixlen |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Maxlen", wireType)
			}
			m.Maxlen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Maxlen |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Conf == nil {
				m.Conf = &RPKIConf{}
			}
			if err := m.Conf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRoaRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRoaRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRoaRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Family", wireType)
			}
			m.Family = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Family |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRoaResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRoaResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRoaResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roas = append(m.Roas, &Roa{})
			if err := m.Roas[len(m.Roas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Vrf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Vrf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Vrf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rd", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rd = append(m.Rd[:0], dAtA[iNdEx:postIndex]...)
			if m.Rd == nil {
				m.Rd = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImportRt", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImportRt = append(m.ImportRt, make([]byte, postIndex-iNdEx))
			copy(m.ImportRt[len(m.ImportRt)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExportRt", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExportRt = append(m.ExportRt, make([]byte, postIndex-iNdEx))
			copy(m.ExportRt[len(m.ExportRt)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefaultRouteDistance) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefaultRouteDistance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefaultRouteDistance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalRouteDistance", wireType)
			}
			m.ExternalRouteDistance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExternalRouteDistance |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalRouteDistance", wireType)
			}
			m.InternalRouteDistance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InternalRouteDistance |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Global) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Global: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Global: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field As", wireType)
			}
			m.As = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.As |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListenPort", wireType)
			}
			m.ListenPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ListenPort |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListenAddresses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ListenAddresses = append(m.ListenAddresses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGobgp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Families = append(m.Families, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGobgp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGobgp
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGobgp
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Families = append(m.Families, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Families", wireType)
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseMultiplePaths", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseMultiplePaths = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteSelectionOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RouteSelectionOptions == nil {
				m.RouteSelectionOptions = &RouteSelectionOptionsConfig{}
			}
			if err := m.RouteSelectionOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultRouteDistance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultRouteDistance == nil {
				m.DefaultRouteDistance = &DefaultRouteDistance{}
			}
			if err := m.DefaultRouteDistance.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Confederation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Confederation == nil {
				m.Confederation = &Confederation{}
			}
			if err := m.Confederation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GracefulRestart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GracefulRestart == nil {
				m.GracefulRestart = &GracefulRestart{}
			}
			if err := m.GracefulRestart.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApplyPolicy == nil {
				m.ApplyPolicy = &ApplyPolicy{}
			}
			if err := m.ApplyPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Confederation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Confederation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Confederation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identifier", wireType)
			}
			m.Identifier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Identifier |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGobgp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.MemberAsList = append(m.MemberAsList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGobgp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGobgp
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGobgp
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.MemberAsList = append(m.MemberAsList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MemberAsList", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (Resource(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Family", wireType)
			}
			m.Family = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Family |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumDestination", wireType)
			}
			m.NumDestination = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumDestination |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumPath", wireType)
			}
			m.NumPath = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumPath |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumAccepted", wireType)
			}
			m.NumAccepted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumAccepted |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRibInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRibInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRibInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &TableInfo{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRibInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRibInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRibInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &TableInfo{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddCollectorRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddCollectorRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddCollectorRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGobgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DbName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableDumpInterval", wireType)
			}
			m.TableDumpInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableDumpInterval |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddCollectorResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddCollectorResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddCollectorResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShutdownRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShutdownRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShutdownRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShutdownResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShutdownResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShutdownResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGobgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGobgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGobgp(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGobgp
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGobgp
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthGobgp
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowGobgp
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipGobgp(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthGobgp = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGobgp   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("gobgp.proto", fileDescriptorGobgp) }

var fileDescriptorGobgp = []byte{
	// 8314 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x7d, 0x4b, 0x6c, 0x23, 0x49,
	0x96, 0x98, 0xf8, 0x11, 0x45, 0x3e, 0x92, 0x62, 0x2a, 0x24, 0x95, 0x58, 0x52, 0xd7, 0x2f, 0xa7,
	0xab, 0xab, 0xba, 0xba, 0x5b, 0xdd, 0x55, 0xdd, 0xad, 0xee, 0xed, 0x9e, 0x9a, 0x1d, 0x96, 0xc4,
	0x52, 0x71, 0x5b, 0x12, 0xd9, 0x29, 0x56, 0x4d, 0xf5, 0x78, 0xc7, 0xe9, 0x14, 0x33, 0x48, 0xa5,
	0x9b, 0xcc, 0xcc, 0xc9, 0x4c, 0xaa, 0x25, 0x18, 0xb0, 0xab, 0x66, 0x77, 0xc6, 0x06, 0x8c, 0xbd,
	0xd8, 0x17, 0x03, 0xb6, 0xe1, 0x83, 0x6f, 0x0b, 0xfb, 0x60, 0x60, 0x01, 0x03, 0xbe, 0xf8, 0x03,
	0xef, 0x62, 0x81, 0x05, 0x0c, 0x9f, 0x7c, 0xb4, 0x8d, 0xb9, 0xfa, 0xe4, 0x8b, 0x61, 0x18, 0x3e,
	0x18, 0xf1, 0xc9, 0xc8, 0xc8, 0x0f, 0x25, 0x55, 0x6d, 0xf5, 0x8e, 0x17, 0xd8, 0x93, 0x98, 0xef,
	0xbd, 0x78, 0xf1, 0x22, 0xe2, 0x45, 0xbc, 0xf7, 0xe2, 0xf3, 0x04, 0xd5, 0x91, 0x73, 0x34, 0x72,
	0x37, 0x5d, 0xcf, 0x09, 0x1c, 0x54, 0xa6, 0x1f, 0x86, 0x6b, 0xad, 0x5f, 0x1d, 0x39, 0xce, 0x68,
	0x8c, 0x3f, 0xa4, 0xf0, 0xa3, 0xe9, 0xf0, 0x43, 0xc3, 0x3e, 0x63, 0x44, 0xea, 0x4f, 0x01, 0xed,
	0xe2, 0xe0, 0x00, 0x5b, 0xa3, 0xe3, 0x23, 0xc7, 0xd3, 0xf0, 0xcf, 0xa7, 0xd8, 0x0f, 0xd0, 0x3d,
	0x50, 0xb0, 0x6d, 0x1c, 0x8d, 0x71, 0xcb, 0x3c, 0xc1, 0x5e, 0x60, 0xf9, 0xd8, 0x6c, 0xe6, 0x6e,
	0xe6, 0xee, 0x96, 0xb5, 0x14, 0x1c, 0x35, 0x61, 0xc1, 0x30, 0x4d, 0x0f, 0xfb, 0x7e, 0x33, 0x7f,
	0x33, 0x77, 0xb7, 0xa2, 0x85, 0x9f, 0xea, 0x97, 0xb0, 0x1c, 0xe3, 0xed, 0xbb, 0x8e, 0xed, 0x63,
	0xf4, 0x36, 0xcc, 0xbb, 0x18, 0x7b, 0x7e, 0x33, 0x77, 0xb3, 0x70, 0xb7, 0xfa, 0x60, 0x71, 0x33,
	0x94, 0x73, 0xb3, 0x87, 0xb1, 0xa7, 0x31, 0xa4, 0xfa, 0x32, 0x07, 0x95, 0x96, 0x37, 0x9a, 0x4e,
	0xb0, 0x1d, 0xf8, 0x68, 0x13, 0xca, 0x1e, 0xf6, 0x9d, 0xa9, 0x37, 0xc0, 0x54, 0x90, 0xc5, 0x07,
	0x28, 0x2a, 0xa6, 0x71, 0x8c, 0x26, 0x68, 0xd0, 0x15, 0x28, 0x0d, 0x8d, 0x89, 0x35, 0x3e, 0xa3,
	0x32, 0xd5, 0x35, 0xfe, 0x85, 0x10, 0x14, 0x6d, 0x63, 0x82, 0x9b, 0x05, 0x2a, 0x29, 0xfd, 0x4d,
	0x1a, 0x30, 0x98, 0x7a, 0x1e, 0xb6, 0x83, 0x66, 0x91, 0xb6, 0x31, 0xfc, 0x54, 0xff, 0x16, 0x2c,
	0xb6, 0x4c, 0xb3, 0x67, 0x04, 0xc7, 0x61, 0xc7, 0xbc, 0xaa, 0x1c, 0xab, 0x50, 0x3a, 0xf1, 0x86,
	0xba, 0x65, 0xf2, 0xbe, 0x99, 0x3f, 0xf1, 0x86, 0x1d, 0x13, 0xa9, 0x50, 0x74, 0x8d, 0xe0, 0x98,
	0x8a, 0x11, 0xef, 0x01, 0x52, 0x17, 0xc5, 0xa9, 0xb7, 0xa1, 0x21, 0x2a, 0xe7, 0x3d, 0x87, 0xa0,
	0x38, 0x9d, 0x5a, 0x6c, 0x28, 0x6a, 0x1a, 0xfd, 0xad, 0xfe, 0x61, 0x0e, 0x96, 0x76, 0xf0, 0x18,
	0x07, 0xf8, 0x7b, 0x90, 0x33, 0xea, 0xc6, 0x42, 0xac, 0x1b, 0x43, 0xf9, 0x8b, 0xb3, 0xe5, 0x17,
	0xc2, 0xce, 0x4b, 0xc2, 0xae, 0x00, 0x92, 0x65, 0x65, 0xcd, 0x52, 0x3f, 0x07, 0xd4, 0x32, 0xcd,
	0xa4, 0x0e, 0x92, 0x3a, 0x30, 0xf6, 0xa8, 0xf8, 0x69, 0x2d, 0xa1, 0x38, 0x75, 0x15, 0x96, 0x63,
	0x25, 0x39, 0xc3, 0x2f, 0x61, 0x95, 0x55, 0xf3, 0x3a, 0x3c, 0x9b, 0x70, 0x25, 0x59, 0x98, 0xb3,
	0x35, 0x61, 0xf5, 0xa9, 0x6b, 0x1a, 0xaf, 0xc5, 0x16, 0xdd, 0x01, 0xc5, 0x74, 0x74, 0xdf, 0x19,
	0x06, 0xba, 0x87, 0x7d, 0x1c, 0xe8, 0x96, 0x4d, 0xfb, 0xba, 0xac, 0xd5, 0x4d, 0xe7, 0xd0, 0x19,
	0x06, 0x1a, 0x81, 0x76, 0x6c, 0x75, 0x17, 0xae, 0x24, 0x6b, 0xe1, 0xc3, 0xff, 0x01, 0x2c, 0xdb,
	0x18, 0x9b, 0x7e, 0x82, 0x0b, 0x9f, 0x98, 0x14, 0x25, 0x33, 0xea, 0xd0, 0xce, 0x21, 0x22, 0xec,
	0x7a, 0xce, 0xd4, 0x0d, 0x85, 0x7d, 0x00, 0x40, 0x04, 0xd2, 0x47, 0x04, 0xc8, 0x45, 0x5e, 0x8e,
	0x8b, 0xcc, 0xe8, 0x2b, 0x6e, 0xf8, 0x53, 0xbd, 0x02, 0x2b, 0x71, 0x56, 0xbc, 0x47, 0xf6, 0xc2,
	0xbe, 0x7a, 0x23, 0xb5, 0x5c, 0x85, 0xb5, 0x14, 0x37, 0x5e, 0xd1, 0x34, 0xec, 0x94, 0x37, 0x51,
	0xd1, 0xe5, 0xc7, 0xe2, 0x09, 0xac, 0xa5, 0xaa, 0x7d, 0xbd, 0xc1, 0x30, 0xe0, 0x6a, 0xcb, 0x34,
	0x77, 0xce, 0x6c, 0x63, 0x62, 0x0d, 0x92, 0xfa, 0xb3, 0x03, 0x8a, 0xc9, 0x30, 0xba, 0xcd, 0x51,
	0xbc, 0x25, 0x57, 0xa3, 0x96, 0x24, 0xcb, 0x36, 0xcc, 0x38, 0x40, 0x7d, 0x0b, 0xd6, 0xb3, 0xaa,
	0xe0, 0x3d, 0xf8, 0x0c, 0x56, 0xa8, 0x2c, 0xc9, 0xba, 0xa5, 0xe5, 0x3b, 0x17, 0x5b, 0xbe, 0xd1,
	0xdb, 0x50, 0x1f, 0x38, 0x93, 0xc9, 0xd4, 0xb6, 0x06, 0x46, 0x60, 0x39, 0x36, 0x5f, 0x1a, 0xe2,
	0x40, 0x75, 0x0d, 0x56, 0x13, 0x7c, 0x79, 0x85, 0xff, 0x26, 0x07, 0x4d, 0xd1, 0x03, 0x97, 0xaf,
	0xf5, 0x10, 0x2a, 0xa6, 0xe5, 0xe1, 0x81, 0xa8, 0x71, 0xf1, 0xc1, 0xa7, 0x51, 0x27, 0xcc, 0x62,
	0x18, 0x21, 0x76, 0xc2, 0xc2, 0x5a, 0xc4, 0x47, 0xfd, 0x10, 0x50, 0x9a, 0x00, 0x95, 0x20, 0xdf,
	0x39, 0x50, 0xe6, 0xd0, 0x02, 0x14, 0xba, 0x4f, 0xfb, 0x4a, 0x0e, 0x95, 0xa1, 0xf8, 0xa8, 0xdb,
	0x7f, 0xa2, 0xe4, 0xd5, 0x0d, 0xb8, 0x9a, 0x51, 0x15, 0x6f, 0xd9, 0x37, 0xb0, 0x76, 0x78, 0x3c,
	0x0d, 0x4c, 0xe7, 0x3b, 0xfb, 0x4d, 0xf7, 0xe6, 0x3a, 0x34, 0xd3, 0xac, 0x79, 0xb5, 0xf7, 0x61,
	0xb5, 0x4d, 0x8d, 0xef, 0xa5, 0x2b, 0x25, 0x6b, 0x59, 0xb2, 0x08, 0x67, 0xf6, 0x1c, 0xae, 0xec,
	0x58, 0xfe, 0x2b, 0x71, 0xbb, 0x64, 0x13, 0xc8, 0x2c, 0x4e, 0x72, 0xe6, 0x95, 0x4e, 0x60, 0x99,
	0x4f, 0x27, 0x67, 0x6c, 0x0d, 0xce, 0xc2, 0x1a, 0xef, 0x42, 0xd1, 0xc7, 0x41, 0xe8, 0x0f, 0xac,
	0x48, 0x2a, 0x8f, 0x87, 0x96, 0x8d, 0xcd, 0x43, 0x1c, 0x68, 0x94, 0x02, 0xbd, 0x0f, 0x65, 0x97,
	0x14, 0xb5, 0x30, 0x71, 0x36, 0x08, 0xb5, 0x22, 0x4d, 0x75, 0xc6, 0x54, 0x50, 0x90, 0x55, 0x2b,
	0x5e, 0x1d, 0x17, 0x63, 0x04, 0x0a, 0xeb, 0x95, 0x7d, 0x2f, 0x08, 0x65, 0xd8, 0x80, 0x8a, 0x39,
	0x9d, 0xb8, 0x7a, 0x70, 0xe6, 0x32, 0x8b, 0x39, 0xaf, 0x95, 0x09, 0xa0, 0x7f, 0xe6, 0x62, 0xb4,
	0x0e, 0xe5, 0xa1, 0x35, 0xc6, 0xd4, 0x73, 0x60, 0x6d, 0x16, 0xdf, 0x04, 0x67, 0xd9, 0x01, 0xf6,
	0x4e, 0x8c, 0x31, 0x35, 0x92, 0x45, 0x4d, 0x7c, 0xab, 0xcb, 0xb0, 0x24, 0x55, 0xc4, 0x6b, 0x5f,
	0x86, 0x25, 0xde, 0x3f, 0x51, 0xf5, 0xd4, 0x30, 0x4a, 0x40, 0x4e, 0xfa, 0x77, 0x40, 0xe9, 0xd8,
	0x7f, 0x13, 0x0f, 0x02, 0x49, 0xd0, 0x37, 0x64, 0xd9, 0x89, 0x13, 0x66, 0x04, 0xc7, 0x7e, 0xb3,
	0x90, 0x72, 0xc2, 0x88, 0x69, 0x66, 0x48, 0x22, 0xab, 0x24, 0x00, 0x97, 0xea, 0xdf, 0xe5, 0xa0,
	0xde, 0x32, 0xcd, 0x47, 0x13, 0xf7, 0x62, 0x95, 0x41, 0x50, 0x74, 0x1d, 0x2f, 0xe0, 0x5e, 0x18,
	0xfd, 0x8d, 0x7e, 0x08, 0x45, 0xda, 0xcb, 0x05, 0x2a, 0xfd, 0xdd, 0xa8, 0xe6, 0x18, 0xd3, 0xcd,
	0x7d, 0xc7, 0xb6, 0x02, 0xc7, 0xb3, 0xec, 0x11, 0x1f, 0x3e, 0x5a, 0x4a, 0xdd, 0x06, 0x25, 0x89,
	0x21, 0x13, 0xb8, 0xa7, 0xb5, 0x95, 0x39, 0x32, 0x81, 0x7b, 0xdd, 0xc3, 0xd8, 0x54, 0x46, 0x15,
	0x98, 0xdf, 0xeb, 0x6e, 0xb7, 0xf6, 0x94, 0x02, 0xa1, 0x6b, 0xed, 0xed, 0x29, 0x45, 0x55, 0xa1,
	0x8e, 0x1d, 0xad, 0x8c, 0x37, 0xea, 0xc7, 0xa0, 0x30, 0xdb, 0xf3, 0xba, 0xcd, 0xa2, 0xe3, 0x1a,
	0x71, 0xe0, 0x6c, 0xfb, 0xb0, 0xc4, 0xa5, 0xd5, 0xac, 0xa3, 0x90, 0xef, 0x6d, 0x98, 0x0f, 0xc8,
	0x50, 0xf3, 0x35, 0xbe, 0x11, 0xf5, 0x40, 0x9f, 0x80, 0x35, 0x86, 0x95, 0xfd, 0xd2, 0x7c, 0xdc,
	0x2f, 0x6d, 0x43, 0x59, 0xeb, 0x7d, 0xd5, 0xd9, 0x76, 0xec, 0xe1, 0x39, 0x42, 0xde, 0x80, 0xaa,
	0x87, 0x27, 0x4e, 0x80, 0x75, 0x21, 0x6b, 0x45, 0x03, 0x06, 0xea, 0x11, 0x89, 0xff, 0x49, 0x11,
	0x2a, 0x84, 0xcf, 0x61, 0x60, 0x04, 0xd4, 0x65, 0x9e, 0xba, 0x81, 0x35, 0x61, 0x62, 0x15, 0x34,
	0xfe, 0x45, 0x14, 0x9c, 0x2c, 0x47, 0x14, 0x93, 0xa7, 0x18, 0xf1, 0x8d, 0x16, 0x21, 0x3f, 0x75,
	0xe9, 0x40, 0x96, 0xb5, 0xfc, 0xd4, 0x65, 0x55, 0x0e, 0x1c, 0xcf, 0xd4, 0x2d, 0xf7, 0xe4, 0x13,
	0xea, 0x1e, 0xd6, 0x49, 0x95, 0x04, 0xd4, 0x71, 0x4f, 0x3e, 0x89, 0x13, 0x6c, 0x51, 0xdf, 0x50,
	0x26, 0xd8, 0x22, 0x04, 0xae, 0x87, 0x87, 0xd6, 0x29, 0xe3, 0x50, 0x62, 0x04, 0x0c, 0x14, 0x72,
	0x88, 0x08, 0xb6, 0x9a, 0x0b, 0x09, 0x82, 0x2d, 0xd2, 0x0e, 0x1f, 0x7b, 0x96, 0x31, 0x6e, 0x96,
	0x99, 0xcf, 0xca, 0xbe, 0xd0, 0x0f, 0xa0, 0xee, 0xe1, 0x01, 0xb6, 0x4e, 0x30, 0x97, 0xae, 0x42,
	0x1b, 0x53, 0x0b, 0x81, 0x94, 0x7b, 0x82, 0x68, 0xab, 0x09, 0x29, 0xa2, 0x2d, 0x42, 0xc4, 0x78,
	0xea, 0xb6, 0x13, 0x58, 0xc3, 0xb3, 0x66, 0x95, 0x11, 0x31, 0xe0, 0x01, 0x85, 0x11, 0x39, 0x07,
	0xc6, 0xe0, 0x18, 0x33, 0xd7, 0xa0, 0x59, 0xa3, 0x24, 0x40, 0x41, 0xd4, 0xaa, 0xa0, 0xdb, 0xb0,
	0x28, 0x08, 0xa8, 0xb2, 0x34, 0xeb, 0x94, 0xa6, 0x1e, 0xd2, 0x30, 0x3f, 0xe3, 0x3a, 0x54, 0xb1,
	0x6d, 0xea, 0xce, 0x50, 0x37, 0x8d, 0xc0, 0x68, 0x2e, 0x52, 0x9a, 0x0a, 0xb6, 0xcd, 0xee, 0x70,
	0xc7, 0x08, 0x0c, 0xb4, 0x02, 0xf3, 0xd8, 0xf3, 0x1c, 0xaf, 0xd9, 0xa0, 0x18, 0xf6, 0x81, 0x6e,
	0x01, 0x97, 0x46, 0xff, 0xf9, 0x14, 0x7b, 0x67, 0x4d, 0x85, 0x22, 0xab, 0x0c, 0xf6, 0x35, 0x01,
	0xb1, 0xa1, 0x20, 0x5e, 0x0b, 0xa3, 0x58, 0x62, 0x02, 0x52, 0x10, 0x25, 0x50, 0xbf, 0x81, 0xa2,
	0xe6, 0x7e, 0x6b, 0xa1, 0x77, 0xa0, 0x38, 0x70, 0xec, 0x21, 0xd7, 0x56, 0x79, 0xb5, 0xe1, 0x3a,
	0xa8, 0x51, 0x3c, 0x7a, 0x17, 0xe6, 0x7d, 0xa2, 0x49, 0x54, 0x4b, 0x62, 0x4e, 0x98, 0x50, 0x32,
	0x8d, 0x51, 0xa8, 0x77, 0x61, 0x71, 0x17, 0x07, 0x84, 0x7b, 0x38, 0x27, 0xa2, 0x48, 0x23, 0x27,
	0x47, 0x1a, 0xea, 0x97, 0xd0, 0x10, 0x94, 0xbc, 0x47, 0xee, 0xc2, 0x82, 0x8f, 0xbd, 0x93, 0xcc,
	0x08, 0x92, 0x12, 0x86, 0x68, 0xf5, 0xa7, 0x74, 0x9a, 0xcb, 0xd5, 0xbc, 0xda, 0x4a, 0xb5, 0x0e,
	0xe5, 0xb1, 0x35, 0xc4, 0x54, 0xf5, 0x0b, 0x4c, 0xf5, 0xc3, 0x6f, 0x75, 0x89, 0x86, 0x67, 0xb2,
	0x60, 0x6a, 0x2b, 0x5c, 0x01, 0x5e, 0xbb, 0xc6, 0x28, 0x40, 0x8a, 0x31, 0xfe, 0x20, 0xb4, 0x23,
	0x97, 0x62, 0x4c, 0x98, 0xc8, 0xe4, 0x9c, 0xc9, 0xa6, 0x30, 0x31, 0x97, 0xe3, 0xb2, 0x0a, 0xcb,
	0x31, 0x7a, 0xce, 0xe6, 0x7d, 0x50, 0xa8, 0xfe, 0x5e, 0x8e, 0xc9, 0x32, 0x2c, 0x49, 0xd4, 0x9c,
	0xc5, 0x47, 0xb0, 0x22, 0x9c, 0xab, 0xcb, 0xb1, 0x59, 0x83, 0xd5, 0x44, 0x09, 0xce, 0xea, 0xcf,
	0x72, 0x61, 0x5b, 0x7f, 0x8a, 0x8f, 0x3c, 0x23, 0xe4, 0xa4, 0x40, 0x61, 0xea, 0x8d, 0x39, 0x17,
	0xf2, 0x93, 0x6a, 0xbb, 0x33, 0x0d, 0x30, 0x35, 0xf0, 0xcc, 0x79, 0x20, 0x8b, 0x21, 0x01, 0x11,
	0x13, 0xef, 0x93, 0xca, 0x89, 0xce, 0x10, 0xb7, 0x86, 0xc5, 0xba, 0xe1, 0x27, 0xfa, 0x04, 0xae,
	0xd8, 0xf8, 0x34, 0x38, 0x76, 0x5c, 0x3d, 0xf0, 0xac, 0xd1, 0x08, 0x7b, 0x3a, 0xdb, 0x04, 0xe1,
	0xdb, 0x05, 0x2b, 0x1c, 0xdb, 0x67, 0x48, 0x26, 0x0e, 0x7a, 0x00, 0xab, 0xc9, 0x52, 0x26, 0x1e,
	0x1b, 0x67, 0x7c, 0xcd, 0x5b, 0x8e, 0x17, 0xda, 0x21, 0x28, 0xd2, 0xe5, 0xb1, 0xc6, 0xf0, 0x46,
	0x36, 0xa0, 0xbe, 0x8b, 0x83, 0x67, 0xde, 0x30, 0xf4, 0x16, 0x3e, 0xa6, 0xd3, 0x87, 0x02, 0xf8,
	0x9c, 0xb8, 0x05, 0xc5, 0x13, 0x6f, 0x18, 0x4e, 0x88, 0x7a, 0x34, 0x21, 0x08, 0x11, 0x45, 0xa9,
	0x1f, 0x51, 0xab, 0x1d, 0x71, 0x41, 0x37, 0xa0, 0x70, 0xe2, 0x85, 0xd3, 0x3a, 0x51, 0x84, 0x60,
	0xb8, 0x95, 0x94, 0xaa, 0x51, 0x3f, 0x0e, 0xad, 0xe4, 0xab, 0xb0, 0x11, 0x86, 0x51, 0xe6, 0xf4,
	0x14, 0x56, 0x76, 0x71, 0x20, 0x39, 0x78, 0x9c, 0xdb, 0xbb, 0xdc, 0x39, 0x60, 0xae, 0xcd, 0x6a,
	0xca, 0x17, 0x24, 0x83, 0xc5, 0x3c, 0x01, 0xb1, 0x97, 0x93, 0x8f, 0xf6, 0x72, 0xd4, 0x16, 0xac,
	0x26, 0xd8, 0x8a, 0x45, 0xe3, 0x92, 0x3e, 0xa6, 0xfa, 0x23, 0x1a, 0xeb, 0xa6, 0x25, 0x7b, 0x07,
	0x0a, 0x64, 0x21, 0x67, 0xed, 0xcc, 0x66, 0x40, 0x08, 0x88, 0xae, 0x26, 0xca, 0xf3, 0x26, 0x1f,
	0x86, 0xe1, 0xed, 0x6b, 0xf3, 0x26, 0x7a, 0x6d, 0x8c, 0xc7, 0xdc, 0x1d, 0x20, 0x3f, 0x49, 0xc0,
	0x90, 0x66, 0xca, 0x2b, 0x7c, 0x04, 0x4d, 0x0d, 0xbb, 0x63, 0x63, 0xf0, 0xfa, 0x35, 0x92, 0x40,
	0x28, 0x83, 0x07, 0xaf, 0x60, 0x95, 0x6e, 0xf0, 0xd1, 0x95, 0x7d, 0x82, 0x6d, 0xe1, 0xcc, 0x7e,
	0x45, 0xc7, 0x56, 0x02, 0xf3, 0x31, 0xf8, 0x18, 0xc0, 0x0f, 0x81, 0xe1, 0x48, 0x48, 0x56, 0x22,
	0x2a, 0x20, 0x91, 0xa9, 0x4f, 0xe8, 0x2e, 0x46, 0xb2, 0x0e, 0x74, 0x1f, 0x2a, 0x82, 0x28, 0x1d,
	0xf5, 0x47, 0xe4, 0x11, 0x15, 0xdf, 0xc4, 0x48, 0x89, 0xa5, 0xfe, 0x2c, 0xdc, 0xc4, 0x78, 0x03,
	0x95, 0x64, 0x8c, 0x90, 0xd8, 0xd5, 0x48, 0xd7, 0xbc, 0x07, 0x6b, 0xbc, 0x73, 0xdf, 0x44, 0xfb,
	0xd6, 0xc5, 0x70, 0xa7, 0x6b, 0x42, 0xa0, 0xec, 0xe2, 0x20, 0x16, 0x76, 0x11, 0x73, 0x25, 0xc1,
	0xf8, 0x18, 0xc9, 0x11, 0x56, 0xee, 0xc2, 0x08, 0xeb, 0x14, 0x94, 0x96, 0x69, 0x26, 0xa3, 0xb9,
	0x12, 0xc5, 0x9f, 0x71, 0xb1, 0xd3, 0xe5, 0x39, 0x1e, 0x7d, 0x01, 0x57, 0x3d, 0x3c, 0x24, 0xcb,
	0xe9, 0xa9, 0xe5, 0x07, 0x96, 0x3d, 0xd2, 0x25, 0xf5, 0x60, 0x3d, 0xb8, 0x46, 0x09, 0xda, 0x1c,
	0x7f, 0x18, 0xa9, 0xc5, 0x32, 0x2c, 0x49, 0x35, 0xf3, 0x56, 0xfe, 0x22, 0x07, 0xcb, 0x7c, 0x07,
	0xe9, 0x35, 0x45, 0xfa, 0x10, 0x96, 0x5d, 0xe2, 0x02, 0x79, 0x27, 0x38, 0x2d, 0x0c, 0x0a, 0x51,
	0x91, 0x1c, 0xe1, 0x78, 0x17, 0xa2, 0xf1, 0xbe, 0x02, 0x2b, 0x71, 0x19, 0xb8, 0x70, 0xff, 0x32,
	0x07, 0x2b, 0x7c, 0x7c, 0x7e, 0x03, 0x1d, 0x36, 0xab, 0x65, 0x85, 0x59, 0x2d, 0x63, 0x1b, 0x3b,
	0x31, 0x71, 0xc5, 0xd6, 0xc1, 0xba, 0xd0, 0x9b, 0x96, 0xef, 0x5b, 0x23, 0x5b, 0x56, 0xdc, 0x2f,
	0x00, 0x0c, 0x01, 0xe4, 0x2d, 0x5a, 0x4f, 0xb6, 0x48, 0x2a, 0x26, 0x51, 0xab, 0xdf, 0xc0, 0x46,
	0x26, 0x67, 0xae, 0x9b, 0x7f, 0x1e, 0xd6, 0xcf, 0xe9, 0xe6, 0xd8, 0xf7, 0x21, 0xf4, 0x35, 0xd8,
	0xc8, 0xe4, 0x2c, 0xf6, 0x3c, 0xae, 0xc9, 0xea, 0xf0, 0x46, 0xeb, 0xce, 0x58, 0x6d, 0x6e, 0xc2,
	0xf5, 0x59, 0xd5, 0x71, 0x81, 0x7e, 0x17, 0xae, 0xc7, 0xc6, 0xf5, 0xcd, 0xf6, 0xc6, 0x2d, 0xb8,
	0x31, 0x93, 0x7b, 0x6c, 0x2d, 0x3a, 0xa4, 0x3e, 0x7a, 0xb8, 0x16, 0x3d, 0xa4, 0x6b, 0x51, 0x08,
	0x13, 0x36, 0xbb, 0x34, 0x1a, 0x3b, 0x47, 0xc6, 0x38, 0x3d, 0x31, 0x76, 0x29, 0x5c, 0xe3, 0x78,
	0xf5, 0x47, 0x80, 0x0e, 0x03, 0xc3, 0x8b, 0x33, 0x7d, 0x85, 0xf2, 0xab, 0xb0, 0x1c, 0x2b, 0x1f,
	0x6d, 0xd5, 0x1c, 0x06, 0x8e, 0x1b, 0x17, 0x75, 0x85, 0xd4, 0x15, 0x01, 0x39, 0xe9, 0x3f, 0x2f,
	0xc0, 0x22, 0x09, 0x73, 0x9e, 0x19, 0x63, 0xcb, 0xa4, 0x1b, 0x61, 0xe8, 0x93, 0x30, 0x1e, 0x62,
	0xbe, 0xcc, 0xf5, 0x78, 0x3c, 0x14, 0x11, 0x6e, 0xca, 0xa1, 0x11, 0xfa, 0x0c, 0x4a, 0x1e, 0x36,
	0x7c, 0xb1, 0xf9, 0x79, 0x63, 0x66, 0x31, 0x8d, 0x92, 0x69, 0x9c, 0x1c, 0xdd, 0x81, 0x85, 0x89,
	0x11, 0x0c, 0x8e, 0xb1, 0xc9, 0xf7, 0x74, 0x24, 0x5f, 0x4c, 0x73, 0x0c, 0x2d, 0xc4, 0xa2, 0x8f,
	0xa0, 0x36, 0xb5, 0xf9, 0x87, 0x6e, 0xf8, 0xcd, 0x62, 0x16, 0x75, 0x55, 0x90, 0xb4, 0x7c, 0xf4,
	0x39, 0x28, 0x51, 0x89, 0x31, 0xb6, 0x47, 0xc1, 0x71, 0x73, 0x3e, 0xab, 0x54, 0x43, 0x90, 0xed,
	0x51, 0x2a, 0xb5, 0x07, 0xf3, 0x6c, 0x77, 0x61, 0x11, 0xe0, 0xb0, 0xdf, 0xea, 0xb7, 0xf5, 0x83,
	0xee, 0x41, 0x5b, 0x99, 0x43, 0xcb, 0xd0, 0x08, 0xbf, 0xfb, 0xfa, 0xe3, 0xee, 0xd3, 0x83, 0x1d,
	0x25, 0x87, 0x1a, 0x50, 0x65, 0xc0, 0x67, 0xad, 0xbd, 0xce, 0x8e, 0x92, 0x47, 0x4b, 0x50, 0x67,
	0x80, 0xce, 0x01, 0x03, 0x15, 0xd4, 0x2f, 0xa1, 0xc4, 0x1a, 0x4e, 0xa8, 0xb5, 0x76, 0xeb, 0xb0,
	0xdb, 0x0f, 0x79, 0xd6, 0xa1, 0x42, 0x01, 0x07, 0x7a, 0xeb, 0x50, 0xc9, 0x91, 0xc2, 0xfc, 0x73,
	0xaf, 0x7d, 0xb0, 0x4b, 0xb7, 0x75, 0xff, 0xcb, 0x3c, 0x14, 0x7b, 0xfc, 0x70, 0xca, 0x1e, 0x7b,
	0x56, 0x78, 0x92, 0x46, 0x7e, 0x93, 0x10, 0xd4, 0x35, 0x82, 0xc0, 0x63, 0xd1, 0x41, 0x4d, 0xe3,
	0x5f, 0x74, 0x92, 0x8d, 0xc2, 0x00, 0x90, 0xfc, 0x24, 0xa5, 0x8f, 0xb0, 0x1f, 0x1e, 0x17, 0xd2,
	0xdf, 0x24, 0xc0, 0xb0, 0x7c, 0xfd, 0x3b, 0x2b, 0x38, 0x36, 0x3d, 0xe3, 0x3b, 0xea, 0xe5, 0x97,
	0x35, 0xb0, 0xfc, 0x9f, 0x70, 0x08, 0xba, 0x0e, 0x70, 0x22, 0x06, 0x8f, 0x6e, 0x6c, 0xcc, 0x6b,
	0x12, 0x04, 0xb5, 0x61, 0x29, 0xfa, 0xd2, 0x4d, 0x1c, 0x18, 0xd6, 0x98, 0x6e, 0x6f, 0x54, 0x1f,
	0x34, 0x67, 0xe9, 0x80, 0xa6, 0x44, 0x45, 0x76, 0x68, 0x09, 0xf4, 0x11, 0xac, 0xd8, 0x8e, 0x6e,
	0x4d, 0x5c, 0x62, 0xa2, 0x83, 0x48, 0xa0, 0x32, 0x5b, 0xe8, 0x6d, 0xa7, 0xc3, 0x51, 0x42, 0xb0,
	0x28, 0xf4, 0xae, 0xc4, 0x0e, 0xf9, 0xae, 0x01, 0xb0, 0x3d, 0x44, 0xdd, 0xf0, 0x6d, 0xba, 0x11,
	0x52, 0xd7, 0x2a, 0x0c, 0xd2, 0xf2, 0x6d, 0xb4, 0x01, 0xfc, 0x43, 0xb7, 0x4c, 0xba, 0x03, 0x52,
	0xd1, 0xca, 0x0c, 0xd0, 0x31, 0xf9, 0x8e, 0x69, 0x80, 0x3d, 0x6c, 0xd2, 0xad, 0x8f, 0xb2, 0x26,
	0xbe, 0xd1, 0x0a, 0x9d, 0x17, 0x63, 0xb6, 0xdf, 0x51, 0xd6, 0xd8, 0x07, 0xba, 0x0b, 0x8a, 0xe5,
	0xeb, 0x43, 0xcf, 0x99, 0xe8, 0xf8, 0x34, 0xc0, 0x9e, 0x6d, 0x8c, 0xe9, 0x66, 0x47, 0x59, 0x5b,
	0xb4, 0xfc, 0xc7, 0x9e, 0x33, 0x69, 0x73, 0x28, 0xe9, 0xe9, 0xf0, 0x94, 0x44, 0xb7, 0x5c, 0xba,
	0xef, 0x51, 0xd1, 0x20, 0x04, 0x75, 0x5c, 0x71, 0xf2, 0xa8, 0x44, 0x27, 0x8f, 0xe8, 0x7d, 0x40,
	0x96, 0xaf, 0x87, 0x11, 0x99, 0x65, 0xd3, 0x7e, 0xa3, 0x9b, 0x1e, 0x65, 0x4d, 0xb1, 0xfc, 0x03,
	0x86, 0xe8, 0x30, 0x38, 0x19, 0x2b, 0xcb, 0xc4, 0x76, 0x60, 0x0d, 0x2d, 0xec, 0x35, 0x11, 0xdb,
	0x63, 0x8a, 0x20, 0xe8, 0x5d, 0x50, 0xc6, 0xce, 0xc0, 0x18, 0xeb, 0x12, 0xd5, 0x32, 0xa5, 0x6a,
	0x50, 0x78, 0x27, 0x22, 0xfd, 0x10, 0xca, 0x86, 0x7d, 0xa6, 0x53, 0x6d, 0x5b, 0x11, 0xde, 0xb6,
	0x33, 0x1a, 0xe3, 0xcd, 0xf0, 0x38, 0x7e, 0xb3, 0x65, 0x9f, 0x69, 0x0b, 0x86, 0x7d, 0x76, 0x40,
	0xd4, 0xf0, 0x63, 0x00, 0x52, 0x80, 0xab, 0xe2, 0xaa, 0x88, 0x57, 0xd2, 0x45, 0x2a, 0x86, 0x7d,
	0xd6, 0xa3, 0x64, 0xea, 0x3f, 0xcb, 0x41, 0x75, 0x07, 0x13, 0x9b, 0xcf, 0x94, 0x89, 0xe8, 0x32,
	0xdd, 0x12, 0xe3, 0x31, 0x30, 0xff, 0x8a, 0xb6, 0x7d, 0xf3, 0xe7, 0x6c, 0xfb, 0xa2, 0x3b, 0xd0,
	0x18, 0x3b, 0x36, 0x09, 0x59, 0x59, 0x31, 0x1c, 0xfa, 0x09, 0x8b, 0x0c, 0xdc, 0xe3, 0x50, 0xd2,
	0x0f, 0xfe, 0xb1, 0xe3, 0x05, 0x32, 0x25, 0x9b, 0x14, 0x0d, 0x0e, 0x0f, 0x49, 0xd5, 0x7f, 0x9d,
	0x83, 0x79, 0xba, 0xbd, 0x89, 0xde, 0x89, 0x85, 0x78, 0x59, 0xbb, 0xd7, 0x33, 0xe3, 0xbb, 0x99,
	0x07, 0xd2, 0xbf, 0x05, 0x35, 0x33, 0x6a, 0x7e, 0xb8, 0xa6, 0xc5, 0xc2, 0x47, 0x81, 0xd5, 0x62,
	0xa4, 0x74, 0x43, 0xd1, 0xf1, 0x03, 0x9d, 0xfb, 0x60, 0x7c, 0xe2, 0x12, 0x10, 0xb3, 0x60, 0xea,
	0x16, 0x0d, 0xbf, 0x5f, 0x79, 0xff, 0x56, 0xfd, 0x8c, 0x6d, 0x72, 0x91, 0x72, 0xdc, 0xa0, 0x5d,
	0xb2, 0xe0, 0x04, 0x96, 0xe8, 0xf7, 0x9e, 0xe3, 0x7c, 0x3b, 0x75, 0x59, 0x0f, 0xce, 0x1c, 0xd1,
	0x1f, 0x43, 0x7d, 0x4c, 0xe9, 0x74, 0xc7, 0x95, 0xce, 0xcc, 0x36, 0x12, 0xbc, 0x19, 0xaf, 0xae,
	0xcb, 0x3a, 0x60, 0x2c, 0x7d, 0xa9, 0xff, 0x34, 0x47, 0x05, 0x95, 0xaf, 0x0f, 0x7c, 0x1f, 0x43,
	0xf4, 0x19, 0x94, 0x25, 0x1d, 0x21, 0xc3, 0x93, 0x2d, 0x23, 0x6b, 0xaf, 0x26, 0x88, 0xd5, 0x31,
	0x20, 0xbe, 0xe2, 0x61, 0x69, 0x10, 0x2e, 0x2b, 0xe2, 0xac, 0x9b, 0x20, 0x51, 0x7f, 0x16, 0xe4,
	0xfe, 0x24, 0xae, 0x40, 0xac, 0x36, 0x6e, 0xdf, 0xff, 0x47, 0x11, 0x8a, 0x3d, 0x8c, 0x3d, 0xba,
	0xb2, 0x11, 0x0e, 0x61, 0x80, 0x54, 0xd7, 0xc4, 0x37, 0xfa, 0x1c, 0x6a, 0x86, 0xeb, 0x8e, 0xcf,
	0x42, 0x5d, 0x62, 0x1b, 0xa1, 0x92, 0x16, 0xb6, 0x08, 0x96, 0xbb, 0xd3, 0x55, 0x23, 0xfa, 0x10,
	0x7b, 0xac, 0x85, 0xe4, 0x1e, 0x2b, 0xa9, 0x53, 0xda, 0x63, 0xfd, 0x12, 0xea, 0xf8, 0x68, 0xe4,
	0xea, 0x93, 0xe9, 0x38, 0xb0, 0x8e, 0x1d, 0x97, 0xdf, 0xc0, 0xb8, 0x12, 0x15, 0x68, 0x1f, 0x8d,
	0xdc, 0x7d, 0x8e, 0xd5, 0x6a, 0x58, 0xfa, 0x42, 0x2d, 0x68, 0xb0, 0x3d, 0x30, 0x0f, 0x0f, 0xc7,
	0x78, 0x10, 0x38, 0x1e, 0xd5, 0xf6, 0xb8, 0x7d, 0x21, 0x04, 0x5a, 0x88, 0xd7, 0x16, 0xbd, 0xd8,
	0x37, 0xba, 0x03, 0x45, 0xcb, 0x1e, 0x3a, 0xd4, 0x7c, 0xa5, 0xce, 0xd9, 0x99, 0x1f, 0x43, 0x09,
	0x88, 0xef, 0x15, 0x58, 0x13, 0xec, 0xf9, 0xdc, 0x84, 0x49, 0xbe, 0x57, 0x9f, 0xc2, 0x35, 0x8e,
	0x27, 0x91, 0x6e, 0xe0, 0x19, 0xb6, 0x4f, 0xf7, 0x42, 0xcb, 0x49, 0xbe, 0xfd, 0x10, 0xa5, 0x45,
	0x54, 0xa4, 0x9f, 0x59, 0x43, 0xd8, 0x46, 0x2f, 0xb5, 0x5b, 0xb1, 0x7e, 0xa6, 0xad, 0xe0, 0x1e,
	0x1a, 0xdb, 0xf7, 0x63, 0x1f, 0x68, 0x07, 0x94, 0x91, 0x67, 0x0c, 0xf0, 0x70, 0x3a, 0xd6, 0x3d,
	0xec, 0x13, 0x9f, 0x8f, 0x5a, 0xb6, 0xd8, 0x49, 0xfb, 0x2e, 0xa7, 0xd0, 0x18, 0x81, 0xd6, 0x18,
	0xc5, 0x01, 0x68, 0x13, 0x2a, 0xc6, 0xd0, 0xd2, 0x7d, 0x63, 0x68, 0xf9, 0xcd, 0x2a, 0xd5, 0xe5,
	0x25, 0x69, 0x90, 0x87, 0xd6, 0xa1, 0x31, 0xb4, 0xb4, 0xb2, 0xc1, 0x7e, 0x90, 0xd8, 0xab, 0x62,
	0x98, 0xa6, 0xce, 0x56, 0xde, 0x5a, 0x72, 0x88, 0xf9, 0x2d, 0x1f, 0x5f, 0x2b, 0x1b, 0xfc, 0x97,
	0xfa, 0x7f, 0x8a, 0x50, 0x11, 0x57, 0x0e, 0xbe, 0x27, 0x95, 0x7b, 0x2f, 0xa6, 0x72, 0x6b, 0x19,
	0x57, 0x26, 0xfe, 0x3f, 0xd2, 0xbb, 0xf7, 0x63, 0x7a, 0xd7, 0xcc, 0x10, 0xf6, 0xaf, 0x94, 0xef,
	0x4d, 0x29, 0xdf, 0x13, 0x68, 0x24, 0x2e, 0x91, 0xcc, 0x34, 0x3e, 0xd7, 0x62, 0x97, 0x6f, 0x98,
	0x15, 0x90, 0x2e, 0xf4, 0xfc, 0x69, 0x0e, 0xaa, 0x92, 0xfe, 0xa1, 0xcf, 0xa0, 0x62, 0xd9, 0x7a,
	0x6c, 0xb3, 0xe3, 0xbc, 0xb8, 0xb2, 0x6c, 0xd9, 0xbc, 0xe0, 0x6f, 0x43, 0x1d, 0x9f, 0x92, 0xde,
	0x8f, 0xab, 0xf9, 0x79, 0x85, 0x6b, 0xac, 0x40, 0xc4, 0xc0, 0x9a, 0xc8, 0x0c, 0x0a, 0x17, 0x33,
	0x60, 0x05, 0xb8, 0x13, 0xf0, 0xb7, 0xa1, 0xca, 0x0c, 0xd3, 0x9e, 0x35, 0xb1, 0x66, 0x1e, 0x57,
	0xa1, 0x5b, 0x50, 0x9b, 0x18, 0xa7, 0x91, 0x33, 0xc4, 0x6c, 0x4e, 0x75, 0x62, 0x9c, 0x0a, 0x9f,
	0xe9, 0x13, 0xb8, 0xe2, 0xf3, 0x2b, 0x1e, 0x7a, 0x70, 0xec, 0x61, 0xff, 0xd8, 0x19, 0x9b, 0xba,
	0x3b, 0x08, 0xb8, 0xbd, 0x5c, 0x09, 0xb1, 0xfd, 0x10, 0xd9, 0x1b, 0x04, 0xea, 0xff, 0x9d, 0x87,
	0x72, 0x68, 0x0b, 0xd0, 0x0f, 0xa0, 0x6e, 0x4c, 0x83, 0x63, 0xdd, 0x35, 0x7c, 0xff, 0x3b, 0xc7,
	0x33, 0xf9, 0xa8, 0xd4, 0x08, 0xb0, 0xc7, 0x61, 0xe8, 0x26, 0x54, 0x4d, 0xec, 0x0f, 0x3c, 0xcb,
	0x95, 0xee, 0x6a, 0xc8, 0x20, 0x74, 0x15, 0xca, 0xcc, 0x8b, 0x35, 0xfc, 0xf0, 0xcc, 0x83, 0x7e,
	0xb7, 0xa8, 0x63, 0x27, 0x7c, 0xec, 0xf0, 0x4c, 0xa6, 0x48, 0x39, 0x34, 0x42, 0x78, 0x8b, 0x1f,
	0x63, 0xad, 0xc1, 0x02, 0xd5, 0x01, 0xc3, 0xe7, 0x47, 0x1b, 0x25, 0xf2, 0xd9, 0xf2, 0x13, 0xca,
	0x51, 0x4a, 0x28, 0x07, 0x89, 0x1f, 0x28, 0x9a, 0x5a, 0x71, 0x76, 0x8c, 0x5b, 0x26, 0x00, 0x7a,
	0xe3, 0xe2, 0x00, 0x96, 0x3c, 0x3c, 0x71, 0x4e, 0xb0, 0xee, 0x7a, 0xd6, 0x89, 0x11, 0x90, 0x18,
	0x84, 0xce, 0xcf, 0xc5, 0x07, 0x6a, 0xda, 0x38, 0x6e, 0x6a, 0x94, 0xb6, 0xc7, 0x48, 0x5b, 0xbe,
	0xd6, 0xf0, 0xe2, 0x00, 0xe2, 0xfe, 0xb3, 0x49, 0x3b, 0x1c, 0x1b, 0xae, 0x6e, 0x1a, 0x13, 0xd7,
	0xb2, 0x47, 0x74, 0xea, 0x96, 0x35, 0x85, 0x62, 0x1e, 0x8f, 0x0d, 0x77, 0x87, 0xc1, 0xd1, 0x6d,
	0x58, 0xf4, 0xb1, 0x6d, 0xea, 0xfc, 0x62, 0x4b, 0x70, 0xc6, 0xa3, 0x9f, 0x3a, 0x81, 0x6e, 0x87,
	0x40, 0xd2, 0x40, 0x7e, 0xc0, 0x3e, 0x30, 0x5c, 0x3a, 0x15, 0x6b, 0x5a, 0x85, 0x41, 0xb6, 0x0d,
	0xda, 0x40, 0xd6, 0xbd, 0x04, 0x5b, 0xa3, 0x58, 0xd6, 0xdf, 0x04, 0xb9, 0x08, 0x79, 0xcb, 0xa4,
	0x11, 0x50, 0x45, 0xcb, 0x5b, 0x26, 0xfa, 0x02, 0xea, 0xfc, 0x58, 0x7b, 0x4c, 0x14, 0xcc, 0x6f,
	0x2e, 0x26, 0x3d, 0x58, 0x49, 0xfd, 0xb4, 0x9a, 0x1b, 0x7d, 0xf8, 0x44, 0x1d, 0xf8, 0x38, 0xf2,
	0x91, 0x62, 0x21, 0x51, 0x8d, 0x0d, 0x26, 0x1f, 0xa6, 0x0f, 0x00, 0x45, 0x51, 0x93, 0x1d, 0x60,
	0x6f, 0x68, 0x0c, 0x30, 0x0d, 0x91, 0x2a, 0xda, 0x92, 0x08, 0x9e, 0x42, 0x04, 0x09, 0x7a, 0x4f,
	0xbc, 0x21, 0x0d, 0x90, 0x2a, 0xf4, 0x18, 0x07, 0xdd, 0x84, 0x9a, 0x31, 0x1e, 0x3b, 0xdf, 0xe9,
	0x44, 0x71, 0x0d, 0x3f, 0x8c, 0x8a, 0x28, 0xac, 0xfb, 0x9d, 0xdd, 0xf2, 0xd1, 0x3b, 0xd0, 0xf0,
	0xd8, 0xde, 0x8f, 0x1e, 0x6a, 0xc4, 0x32, 0xbb, 0x55, 0xc7, 0xc1, 0x3d, 0xaa, 0x18, 0xea, 0x7d,
	0x68, 0x24, 0x06, 0x0c, 0x95, 0xa1, 0xc8, 0x83, 0x78, 0x7e, 0x47, 0x23, 0x87, 0xaa, 0xb0, 0xa0,
	0xb5, 0x7b, 0x7b, 0xad, 0xed, 0xb6, 0x92, 0x57, 0xff, 0x45, 0x01, 0xea, 0x31, 0xbb, 0xf4, 0x17,
	0x30, 0x07, 0x66, 0x2a, 0xf6, 0x3b, 0xd0, 0x88, 0x14, 0x5b, 0xa7, 0x0e, 0x30, 0xd3, 0xee, 0xba,
	0xd0, 0xee, 0x03, 0xe2, 0x09, 0x9f, 0xab, 0xe1, 0x87, 0xb3, 0x35, 0xfc, 0xce, 0x0c, 0x5b, 0xfc,
	0x9b, 0x51, 0xf3, 0xd7, 0x19, 0xae, 0xff, 0x55, 0x80, 0xc5, 0xb8, 0x65, 0xfe, 0x4b, 0x3f, 0x5e,
	0xfd, 0xd9, 0xe3, 0x75, 0x77, 0x96, 0x3b, 0xf2, 0x1b, 0x5a, 0x97, 0x6e, 0x40, 0x35, 0x70, 0x02,
	0x63, 0xcc, 0x6d, 0x7e, 0x95, 0x4d, 0x54, 0x0a, 0xa2, 0x16, 0x9e, 0xf0, 0xe1, 0x04, 0xa1, 0x9d,
	0xaa, 0x31, 0x3e, 0x8c, 0x26, 0x0c, 0xbc, 0x5e, 0x63, 0xe0, 0xbf, 0x82, 0x9a, 0xec, 0x08, 0xa2,
	0x26, 0x2c, 0xb0, 0xb3, 0xf2, 0xf0, 0xfd, 0x40, 0xf8, 0x49, 0x2d, 0x25, 0xa7, 0xd2, 0x83, 0x60,
	0x2c, 0x2c, 0x25, 0x87, 0xf5, 0x83, 0xb1, 0xfa, 0x7b, 0x39, 0x58, 0x8c, 0xfb, 0x85, 0xc4, 0x78,
	0x26, 0x5c, 0x49, 0x7d, 0x30, 0xb6, 0xc2, 0x6d, 0xea, 0xb2, 0xb6, 0x12, 0xf7, 0x1b, 0xb7, 0x29,
	0x0e, 0x7d, 0x09, 0xeb, 0xe9, 0x52, 0x53, 0x3f, 0xc0, 0x5e, 0x74, 0x2f, 0x6e, 0x2d, 0x59, 0x92,
	0xe2, 0x3b, 0xa6, 0xfa, 0xaf, 0x4a, 0xcc, 0x17, 0xff, 0x8b, 0x52, 0xe3, 0x4d, 0x28, 0x4f, 0xb0,
	0xef, 0x1b, 0x23, 0xbe, 0x97, 0x12, 0x73, 0xd7, 0xf6, 0x39, 0x46, 0x13, 0x34, 0x99, 0xa6, 0x7a,
	0xfe, 0x42, 0x53, 0x5d, 0x3a, 0xc7, 0x54, 0x2f, 0x9c, 0x6b, 0xaa, 0xcb, 0x89, 0x89, 0x71, 0x17,
	0x4a, 0x3f, 0x9f, 0xe2, 0x29, 0xf6, 0xb9, 0x27, 0x2c, 0x39, 0xdb, 0x5f, 0x53, 0xb8, 0xc6, 0xf1,
	0xe8, 0x5e, 0xd6, 0x14, 0x62, 0x1a, 0x7c, 0xc9, 0x89, 0x51, 0xbd, 0xf4, 0xc4, 0xa8, 0x65, 0x4d,
	0x0c, 0x7a, 0x71, 0xcb, 0xf7, 0x2d, 0xc7, 0x66, 0x47, 0x60, 0xd4, 0xfe, 0xd6, 0xb5, 0x1a, 0x07,
	0xb2, 0x11, 0xfe, 0x14, 0xae, 0xf8, 0x53, 0x97, 0xb8, 0x7e, 0xd8, 0x24, 0xa6, 0xdb, 0x38, 0xb2,
	0xc6, 0x56, 0x40, 0x62, 0xaf, 0x45, 0x7a, 0x69, 0x64, 0x55, 0x60, 0xb7, 0x25, 0x24, 0xe9, 0x23,
	0x12, 0x20, 0x31, 0xbe, 0xcc, 0x00, 0x97, 0x8f, 0x46, 0x7c, 0xf1, 0xfb, 0x6d, 0xa8, 0x1a, 0xe6,
	0xc4, 0x0a, 0xab, 0x55, 0x92, 0x07, 0x02, 0x42, 0xbf, 0x36, 0x5b, 0x84, 0x8c, 0xc5, 0x32, 0x60,
	0x88, 0xdf, 0x24, 0x04, 0x0c, 0xaf, 0xa0, 0x51, 0x9b, 0x5c, 0xd7, 0xc4, 0x37, 0xc1, 0x19, 0x83,
	0x01, 0x76, 0x03, 0x6c, 0x72, 0xa3, 0x2c, 0xbe, 0xd1, 0x75, 0x00, 0x23, 0x7a, 0xc2, 0xb3, 0xcc,
	0x4d, 0x76, 0xf4, 0x78, 0x67, 0x19, 0xe6, 0x9d, 0x69, 0xa0, 0xff, 0x9c, 0x6e, 0x4d, 0xd6, 0xb5,
	0xa2, 0x33, 0x0d, 0xbe, 0x46, 0x2b, 0x30, 0x3f, 0x1c, 0x3b, 0xae, 0xdf, 0x5c, 0xa5, 0x40, 0xf6,
	0xa1, 0xde, 0x03, 0x88, 0x84, 0x43, 0x25, 0xc8, 0x3f, 0xed, 0xb1, 0x1b, 0x97, 0x3b, 0xdd, 0x9f,
	0x1c, 0x28, 0x39, 0x04, 0x50, 0xea, 0x3d, 0x7e, 0xae, 0x6f, 0xf7, 0x95, 0xbc, 0xfa, 0x37, 0xa0,
	0x1c, 0x6a, 0x2a, 0xfa, 0x40, 0x12, 0x9d, 0xf9, 0xfc, 0x4b, 0x29, 0x7d, 0x96, 0x5a, 0x73, 0x1b,
	0x8a, 0x7e, 0x78, 0xe5, 0x31, 0x93, 0x94, 0xa2, 0xd5, 0x3f, 0xce, 0xc1, 0x02, 0x87, 0x20, 0x15,
	0x6a, 0x07, 0xdd, 0x7e, 0xe7, 0x71, 0x67, 0xbb, 0xd5, 0xef, 0x74, 0x0f, 0x68, 0x2d, 0x45, 0x2d,
	0x06, 0x23, 0x0e, 0xfb, 0xd3, 0xde, 0x4e, 0xab, 0xdf, 0xa6, 0x8c, 0x8b, 0x1a, 0xff, 0x42, 0x08,
	0x8a, 0xdd, 0x5e, 0xfb, 0x80, 0x5f, 0xdd, 0xa5, 0xbf, 0xd1, 0x5b, 0x50, 0xf9, 0xaa, 0xdd, 0xee,
	0xb5, 0xf6, 0x3a, 0xcf, 0xda, 0x74, 0x0a, 0x16, 0xb5, 0x08, 0x40, 0x96, 0x34, 0xad, 0xfd, 0x58,
	0x6b, 0x1f, 0x3e, 0xa1, 0xd3, 0xac, 0xa8, 0x85, 0x9f, 0xa4, 0xdc, 0x4e, 0xe7, 0x70, 0xbb, 0xa5,
	0xed, 0xb4, 0x77, 0xe8, 0x04, 0x2b, 0x6a, 0x11, 0x80, 0xf4, 0x6a, 0xbf, 0xdb, 0x6f, 0xed, 0xd1,
	0xe9, 0x55, 0xd4, 0xd8, 0x87, 0xba, 0x05, 0x25, 0x36, 0x4b, 0x08, 0xde, 0xb2, 0xdd, 0x69, 0xc0,
	0x23, 0x0a, 0xf6, 0x41, 0xe4, 0x76, 0xa6, 0x01, 0x01, 0xf3, 0xed, 0x2b, 0xf6, 0xa5, 0x62, 0x28,
	0xb1, 0x50, 0x16, 0x6d, 0x42, 0x89, 0x84, 0xe8, 0xd6, 0x88, 0xf7, 0xee, 0x95, 0x64, 0xb0, 0xbb,
	0x4d, 0xb1, 0x1a, 0xa7, 0x42, 0xef, 0xc5, 0xaf, 0xe9, 0xad, 0x26, 0xc9, 0x63, 0x17, 0xf5, 0xfe,
	0x38, 0x07, 0x35, 0x99, 0x0b, 0x99, 0x42, 0x03, 0xc7, 0xb6, 0xf1, 0x20, 0xd0, 0x3d, 0x1c, 0x78,
	0x67, 0x61, 0x67, 0x73, 0xa0, 0x46, 0x60, 0x64, 0x2e, 0xd0, 0xa0, 0x46, 0xdc, 0x19, 0x2d, 0x6a,
	0x65, 0x02, 0x20, 0x9c, 0x88, 0x23, 0xfa, 0x2d, 0xc6, 0xae, 0x31, 0xb6, 0x4e, 0xb0, 0x9e, 0xb8,
	0x3a, 0xbd, 0x24, 0x30, 0x1d, 0x8e, 0x40, 0x3b, 0x70, 0x7d, 0x62, 0xd9, 0xd6, 0x64, 0x3a, 0xd1,
	0x85, 0xde, 0x92, 0xf8, 0x2c, 0x2a, 0xca, 0x46, 0xe8, 0x2d, 0x4e, 0xd5, 0x92, 0x89, 0x42, 0x2e,
	0xea, 0x1f, 0xe6, 0xa1, 0x2a, 0x35, 0xef, 0x2f, 0x69, 0x33, 0xe8, 0xe1, 0x0e, 0x1e, 0x39, 0x81,
	0x65, 0x90, 0xc5, 0x29, 0x12, 0x8e, 0x29, 0x22, 0x8a, 0x70, 0x4f, 0x42, 0x31, 0xa3, 0x5b, 0xbd,
	0x4c, 0x21, 0xb3, 0x6e, 0xf5, 0x32, 0x85, 0x14, 0xdf, 0xea, 0xff, 0xce, 0x41, 0x45, 0x6c, 0x7d,
	0xa4, 0xa3, 0x8b, 0x5c, 0x46, 0x74, 0x71, 0x0d, 0x80, 0x11, 0x49, 0x37, 0x1a, 0x59, 0xf4, 0xd3,
	0xe3, 0x3c, 0x26, 0xc1, 0x54, 0x37, 0x2d, 0x7f, 0xe0, 0x9c, 0x60, 0xef, 0x8c, 0x1f, 0x27, 0xd4,
	0x26, 0xc1, 0x74, 0x27, 0x84, 0x11, 0x8f, 0x80, 0x58, 0x55, 0xd2, 0x9f, 0x13, 0xc7, 0x0c, 0x6f,
	0xd7, 0x55, 0x39, 0x6c, 0xdf, 0x31, 0x31, 0x59, 0xe7, 0x79, 0xc4, 0x15, 0xb7, 0x74, 0x75, 0x06,
	0x6d, 0x65, 0xdf, 0x7c, 0x2e, 0x85, 0xb7, 0x8c, 0xc3, 0x9b, 0xcf, 0xc4, 0x10, 0x06, 0x03, 0x57,
	0x9f, 0xf8, 0x3e, 0xf7, 0xf3, 0x4a, 0xc1, 0xc0, 0xdd, 0xf7, 0x7d, 0xf5, 0x21, 0x54, 0xa5, 0xed,
	0x1b, 0xb4, 0x09, 0xcb, 0xf2, 0x5e, 0x4f, 0xdc, 0xd7, 0x58, 0x92, 0xf6, 0x76, 0x98, 0xa3, 0xa1,
	0xfe, 0x51, 0x01, 0x1a, 0x89, 0x0d, 0x9c, 0xf3, 0x5d, 0x20, 0xbe, 0x0d, 0x14, 0xa9, 0x58, 0x5d,
	0xab, 0x72, 0x18, 0x1d, 0xbe, 0x1b, 0x50, 0x3d, 0xc6, 0x63, 0x17, 0x7b, 0xba, 0x63, 0x8f, 0xc3,
	0x6e, 0x03, 0x06, 0xea, 0xda, 0x63, 0x6a, 0xd2, 0x4c, 0x3c, 0xc4, 0x9e, 0x67, 0x8c, 0x19, 0x13,
	0x76, 0xe7, 0xba, 0x16, 0x02, 0x29, 0x97, 0xfb, 0xb0, 0x42, 0x6f, 0x2a, 0xf3, 0x27, 0x1a, 0x7a,
	0x28, 0x0f, 0x3b, 0xeb, 0x58, 0x96, 0x71, 0x6d, 0x2e, 0xdb, 0x7b, 0xb0, 0x34, 0x76, 0xec, 0xd1,
	0x98, 0xde, 0x84, 0x0e, 0xe9, 0x4b, 0xcc, 0xfc, 0x0a, 0x44, 0x48, 0x7c, 0x0f, 0x96, 0xe8, 0x21,
	0x9e, 0x4e, 0x7b, 0xc4, 0xd7, 0x85, 0x56, 0xd5, 0xb5, 0x06, 0x45, 0xd0, 0x3e, 0xf5, 0xa9, 0x2c,
	0xf7, 0x60, 0x89, 0xfa, 0x12, 0xb1, 0x96, 0x33, 0x9f, 0x82, 0x7a, 0xe9, 0x9a, 0xd4, 0xfa, 0x3b,
	0xdc, 0x71, 0xe7, 0xb4, 0x91, 0x6b, 0xbc, 0x28, 0x51, 0x12, 0xfb, 0x2f, 0xce, 0xe3, 0x24, 0x4a,
	0x60, 0xe7, 0x50, 0x14, 0x2e, 0x91, 0x22, 0x28, 0x52, 0xed, 0x62, 0x27, 0x96, 0xf4, 0xb7, 0xfa,
	0x31, 0xac, 0xed, 0xbb, 0x89, 0x71, 0xe3, 0xeb, 0xdd, 0xcc, 0xd1, 0x53, 0xff, 0x63, 0x0e, 0xae,
	0xa4, 0x4a, 0xb1, 0xd5, 0x65, 0xf6, 0x90, 0xcb, 0x76, 0x9c, 0xdd, 0xda, 0x88, 0x2c, 0x5f, 0xdc,
	0x56, 0xf3, 0xa1, 0x96, 0x6c, 0xf5, 0x07, 0xb0, 0xcc, 0x6f, 0x82, 0x7b, 0xd6, 0x91, 0x2e, 0xd8,
	0x14, 0xc3, 0x77, 0xb9, 0x66, 0x77, 0x48, 0x4f, 0x2c, 0x84, 0x21, 0x6d, 0x48, 0xe4, 0xd4, 0xa6,
	0xb2, 0xf1, 0xae, 0x85, 0xa4, 0x87, 0x44, 0x65, 0x7f, 0x95, 0x83, 0xa5, 0x54, 0x33, 0xd0, 0x6f,
	0x25, 0x8c, 0xca, 0x2d, 0xc9, 0x0e, 0x67, 0xf7, 0x94, 0xb0, 0x2f, 0x5b, 0x71, 0xfb, 0x72, 0xf3,
	0x9c, 0x92, 0x31, 0x53, 0xd3, 0x82, 0x3a, 0xdf, 0xbc, 0xe4, 0x5d, 0x3f, 0x6b, 0x8f, 0x4d, 0xea,
	0xdd, 0x7c, 0x7c, 0x48, 0xfe, 0x5e, 0x0e, 0x6a, 0x9c, 0x87, 0x78, 0xd3, 0xf0, 0x6a, 0x2c, 0x92,
	0xb1, 0x53, 0xe1, 0x12, 0xb1, 0x53, 0x31, 0x2b, 0x76, 0xfa, 0x87, 0x05, 0xd8, 0xe0, 0x2b, 0xc9,
	0x98, 0x3d, 0x37, 0x63, 0xa7, 0x6d, 0xa1, 0x1d, 0x7d, 0x1f, 0x90, 0x31, 0xfe, 0xce, 0x38, 0xf3,
	0x89, 0xcf, 0xea, 0x1a, 0x1e, 0xd6, 0x27, 0xd1, 0x1b, 0x6b, 0x86, 0xd9, 0x66, 0x88, 0x7d, 0x6c,
	0xa2, 0xfb, 0xb0, 0x6a, 0x8d, 0x6c, 0xc7, 0x23, 0x1e, 0x33, 0x95, 0x2c, 0xbc, 0x85, 0xc1, 0x2f,
	0xa6, 0x31, 0x64, 0xcb, 0x27, 0x22, 0xb2, 0x9b, 0x17, 0x24, 0xe6, 0x09, 0xcf, 0xd1, 0x45, 0x15,
	0x74, 0x7a, 0xd2, 0x98, 0x87, 0x69, 0xd7, 0x5a, 0x48, 0xc1, 0xab, 0xa2, 0x02, 0x7b, 0x1d, 0x13,
	0x7d, 0x01, 0x57, 0x85, 0xe2, 0xe9, 0x96, 0x6d, 0x0c, 0x02, 0xb2, 0x2a, 0xb3, 0xd9, 0xcd, 0x15,
	0x6e, 0x4d, 0x10, 0x74, 0x38, 0x9e, 0x4d, 0x72, 0xd2, 0x83, 0xac, 0x33, 0x75, 0xc3, 0x1a, 0xb9,
	0xe1, 0x79, 0x2a, 0x7f, 0x36, 0x6e, 0x8d, 0x5c, 0xf4, 0x05, 0xac, 0xf3, 0xc6, 0xd8, 0xf8, 0x34,
	0xd0, 0xe9, 0x79, 0xfc, 0xc8, 0xd5, 0x27, 0x38, 0xf0, 0xac, 0x01, 0x5f, 0x63, 0xae, 0x30, 0x8a,
	0x03, 0x7c, 0x1a, 0x3c, 0x71, 0xdc, 0xce, 0xc8, 0xdd, 0xa7, 0x58, 0xf4, 0x10, 0x36, 0x4c, 0x76,
	0x29, 0x5d, 0x3f, 0xc2, 0x7e, 0xc0, 0xfa, 0xc2, 0x0f, 0xbb, 0x98, 0xae, 0x39, 0x65, 0xad, 0xc9,
	0x49, 0x1e, 0x61, 0x9f, 0x9e, 0x6a, 0x8a, 0x21, 0x50, 0xff, 0x41, 0x01, 0xd6, 0x33, 0x47, 0x85,
	0xa9, 0xcb, 0x5f, 0x0d, 0xca, 0x6f, 0x64, 0x50, 0x72, 0xb0, 0x9a, 0x39, 0x28, 0xe8, 0x61, 0x62,
	0x15, 0xba, 0x9d, 0x3a, 0x64, 0xc9, 0x9a, 0x5b, 0x62, 0x25, 0xfa, 0x22, 0xbe, 0x12, 0xbd, 0x7d,
	0x41, 0xe9, 0xd8, 0x6a, 0xf4, 0x00, 0xae, 0x3c, 0xf5, 0x31, 0xdd, 0xc7, 0x70, 0xc7, 0xf4, 0xb9,
	0xba, 0x7f, 0xa1, 0x45, 0xb8, 0x0f, 0xab, 0xc9, 0x32, 0x17, 0xd8, 0x03, 0xf5, 0x67, 0x00, 0xed,
	0xa3, 0x91, 0xcb, 0x59, 0xdf, 0x83, 0x25, 0xb6, 0xc5, 0x3a, 0xe1, 0x3c, 0x48, 0x80, 0xcc, 0x4a,
	0x34, 0x28, 0x22, 0xe4, 0xdd, 0xa2, 0x9b, 0xbe, 0x13, 0xe3, 0x94, 0x3a, 0x94, 0xe1, 0x8d, 0x0e,
	0x6a, 0xf8, 0x39, 0x90, 0x1d, 0xe5, 0xfc, 0x2e, 0x54, 0xda, 0x22, 0x08, 0x7d, 0xe3, 0xdc, 0x75,
	0x28, 0x12, 0xee, 0xe8, 0xfd, 0xc4, 0x30, 0xad, 0xc4, 0x4f, 0x05, 0x13, 0xa3, 0x32, 0xfb, 0x99,
	0x90, 0x10, 0x35, 0x1c, 0x84, 0xfb, 0x00, 0x9d, 0xa8, 0x77, 0x52, 0x32, 0xe5, 0x32, 0x64, 0xfa,
	0x08, 0x2a, 0x1d, 0xd1, 0xe2, 0x4b, 0x95, 0xd0, 0xa1, 0xd8, 0xb9, 0xa0, 0x15, 0x9d, 0x57, 0x69,
	0x45, 0x27, 0xd9, 0x8a, 0x3f, 0xcb, 0x81, 0x92, 0xd4, 0x0b, 0xf4, 0x79, 0xa2, 0x36, 0xc9, 0x4c,
	0x66, 0xeb, 0x9d, 0xa8, 0xf9, 0xd3, 0x78, 0xcd, 0x37, 0x66, 0x17, 0x8c, 0xdd, 0x2b, 0x54, 0xa1,
	0x88, 0x8f, 0x46, 0x6e, 0x3a, 0xe5, 0x04, 0xe9, 0x75, 0x8d, 0xe2, 0x08, 0x8d, 0x45, 0x68, 0x52,
	0x69, 0x1d, 0x3a, 0x94, 0x86, 0xe0, 0xd4, 0x47, 0xdc, 0xae, 0xf5, 0x0d, 0x6f, 0x84, 0x83, 0x7d,
	0x3c, 0x39, 0xc2, 0x9e, 0x7f, 0x6c, 0x49, 0x83, 0x14, 0xf7, 0x47, 0x73, 0x69, 0x7f, 0x54, 0x6d,
	0xf1, 0x55, 0x38, 0xc9, 0x43, 0x8c, 0xda, 0xc5, 0x2c, 0xc4, 0xa2, 0x91, 0xe4, 0x71, 0xe1, 0xa2,
	0x91, 0x2d, 0xf8, 0x65, 0x17, 0x8d, 0x4c, 0x91, 0xc3, 0x91, 0xfe, 0x19, 0x5c, 0xdf, 0x73, 0xec,
	0xd1, 0x1e, 0xf1, 0xbf, 0x5e, 0xd1, 0x9d, 0xbc, 0x44, 0x30, 0xa0, 0xfe, 0xd7, 0x1c, 0x5c, 0x9b,
	0xc5, 0xff, 0xfb, 0x74, 0x3c, 0x33, 0x5d, 0xf6, 0x62, 0xb6, 0xcb, 0xfe, 0x25, 0xac, 0xa7, 0x68,
	0x3d, 0x1d, 0x9f, 0xba, 0x96, 0x27, 0x02, 0x8e, 0xb5, 0x44, 0x21, 0xaf, 0xcd, 0xd0, 0xea, 0x3f,
	0xce, 0x41, 0x73, 0x56, 0x03, 0xd1, 0x8f, 0x13, 0xe3, 0x2a, 0xed, 0xba, 0x9f, 0xdf, 0xe9, 0x62,
	0x68, 0x1f, 0xc6, 0x87, 0xf6, 0xce, 0xc5, 0x0c, 0x62, 0xa3, 0xfb, 0x07, 0xf3, 0xb0, 0xc0, 0xbd,
	0x4b, 0xf4, 0x15, 0x2c, 0x4f, 0x5c, 0x3d, 0x75, 0x9a, 0xcf, 0x24, 0xdb, 0x38, 0xc7, 0xe5, 0xd5,
	0x96, 0x26, 0x29, 0x67, 0xfb, 0x43, 0xd1, 0xb2, 0x7c, 0xf2, 0x2e, 0x46, 0xcc, 0x23, 0x16, 0x0d,
	0x49, 0x5e, 0xfa, 0x28, 0x5c, 0xfa, 0xd2, 0xc7, 0x4f, 0x60, 0x2d, 0x0c, 0x68, 0xb9, 0xf1, 0xe3,
	0xd7, 0xc6, 0xc2, 0xbd, 0xe6, 0x1b, 0x17, 0x18, 0x49, 0x6d, 0xd5, 0xcb, 0x34, 0xd5, 0x4f, 0x00,
	0x4d, 0x7d, 0x1c, 0x99, 0x16, 0xb6, 0xde, 0xce, 0x27, 0x4f, 0xd9, 0x93, 0x4b, 0x94, 0xa6, 0x4c,
	0x93, 0x2b, 0x63, 0xea, 0x24, 0xb4, 0x94, 0x6c, 0xdd, 0xec, 0x93, 0x50, 0xd1, 0xbc, 0x80, 0x4e,
	0x53, 0x7d, 0x22, 0xe6, 0x29, 0xbf, 0x09, 0x72, 0xe3, 0x82, 0xe9, 0xcc, 0x9b, 0x97, 0x5a, 0x54,
	0x0c, 0xd8, 0x20, 0x51, 0xaf, 0xce, 0xe2, 0xe1, 0xd4, 0xb8, 0xb3, 0x9b, 0x23, 0xea, 0xc5, 0x0a,
	0xa5, 0x35, 0xc7, 0xb3, 0xf4, 0x3b, 0x76, 0x4f, 0xa3, 0x72, 0x89, 0x7b, 0x1a, 0x6d, 0x91, 0x9d,
	0x48, 0x72, 0x4d, 0xf8, 0xa4, 0x0e, 0xa7, 0x3f, 0xff, 0x44, 0x57, 0xa1, 0x4c, 0x37, 0xc8, 0x27,
	0xc6, 0x29, 0x5f, 0x59, 0x16, 0xc8, 0xf7, 0xbe, 0x71, 0xaa, 0xee, 0xd0, 0x77, 0x81, 0x71, 0x6f,
	0xe5, 0xd5, 0xb9, 0x7c, 0x0b, 0xe5, 0x90, 0x0b, 0xfa, 0x28, 0x31, 0x53, 0x9b, 0xe9, 0x66, 0x24,
	0x14, 0xfa, 0x83, 0xf8, 0xcc, 0x5c, 0x4b, 0x17, 0x88, 0xcd, 0xc4, 0x29, 0x94, 0xf8, 0xad, 0xc8,
	0x0d, 0xa8, 0x58, 0xae, 0x1e, 0xbb, 0x9b, 0x52, 0xb6, 0xc2, 0x2b, 0x93, 0xef, 0x40, 0x63, 0x62,
	0xf8, 0xdf, 0x72, 0xb7, 0x5c, 0x9f, 0xf0, 0x2c, 0x2f, 0x75, 0xad, 0x4e, 0xc0, 0xcc, 0x25, 0xdf,
	0xb7, 0xec, 0x14, 0x9d, 0x71, 0xca, 0xe3, 0x3e, 0x99, 0xce, 0x38, 0x55, 0xff, 0x20, 0x07, 0x10,
	0xbd, 0x82, 0xfb, 0x73, 0x3e, 0x55, 0x24, 0xb0, 0xb1, 0xe5, 0x07, 0xf4, 0xb2, 0x7e, 0x45, 0xa3,
	0xbf, 0xe9, 0xeb, 0xab, 0xf8, 0x1d, 0x49, 0x25, 0xa9, 0xf6, 0xd2, 0xc5, 0xc8, 0x5d, 0x28, 0xef,
	0x1b, 0xc1, 0xe0, 0x98, 0x08, 0x73, 0x27, 0x26, 0x8c, 0xe4, 0x8e, 0x50, 0x8a, 0x0b, 0x5e, 0x4d,
	0x3e, 0x83, 0x5a, 0x2c, 0x4c, 0xd9, 0x8c, 0x31, 0x93, 0xa6, 0xaf, 0x4c, 0x25, 0xf1, 0xbc, 0x02,
	0x25, 0x29, 0xf4, 0xa9, 0x6b, 0xfc, 0x4b, 0xfd, 0x47, 0xf3, 0x00, 0xdb, 0x8e, 0x6d, 0x5a, 0x6c,
	0x8d, 0xb8, 0x0f, 0xfc, 0x9d, 0xbe, 0x1e, 0x3d, 0x3d, 0x44, 0x09, 0x49, 0x0f, 0x71, 0xa0, 0x55,
	0x18, 0x15, 0x69, 0xd6, 0xa7, 0x50, 0x13, 0x87, 0x5b, 0xa4, 0x50, 0x7e, 0x66, 0x21, 0x71, 0x27,
	0x9c, 0x14, 0xfb, 0x21, 0x2c, 0x26, 0x62, 0xb2, 0x42, 0x72, 0x6f, 0x5c, 0x6e, 0x8a, 0x56, 0x33,
	0xe4, 0xe6, 0x3f, 0x80, 0x6a, 0x58, 0x9a, 0xd4, 0x59, 0x9c, 0x2d, 0x28, 0x2b, 0x46, 0x6a, 0xfc,
	0x4c, 0xe4, 0x46, 0x09, 0xce, 0x68, 0xa9, 0xf9, 0x99, 0xa5, 0x6a, 0x82, 0x90, 0x14, 0xfc, 0x11,
	0x2c, 0x91, 0x80, 0x2b, 0x5e, 0xb8, 0x34, 0xb3, 0x70, 0x03, 0x9f, 0x06, 0xdb, 0x72, 0xf9, 0x1b,
	0x50, 0xf5, 0xdc, 0x6f, 0x2d, 0xb2, 0x14, 0x4d, 0xc7, 0x01, 0x5d, 0xe6, 0xe6, 0x35, 0xf0, 0xd8,
	0x23, 0xe9, 0xe9, 0x38, 0x40, 0x0f, 0x01, 0xa2, 0x97, 0xcf, 0xfc, 0xc4, 0x5a, 0x3a, 0x7a, 0x8a,
	0xc6, 0x87, 0xaf, 0x88, 0x64, 0x58, 0x2b, 0xe2, 0x61, 0x34, 0x7a, 0x04, 0xcb, 0x63, 0xb2, 0x1a,
	0x26, 0x24, 0xac, 0xcc, 0x94, 0x70, 0x89, 0x92, 0xc7, 0x64, 0xbc, 0x03, 0x4a, 0x14, 0x55, 0xda,
	0x3a, 0x55, 0x7b, 0xa0, 0x6a, 0x5f, 0xb7, 0x79, 0x30, 0x69, 0xef, 0x59, 0x7e, 0xa0, 0x1e, 0x43,
	0x45, 0x08, 0x81, 0x96, 0xa1, 0xa1, 0x75, 0x9f, 0xf6, 0xdb, 0x7a, 0xff, 0x9b, 0x9e, 0x78, 0x37,
	0xb2, 0x06, 0xcb, 0x12, 0xb0, 0x73, 0xd0, 0x6f, 0x6b, 0x07, 0xad, 0x3d, 0x25, 0x97, 0x40, 0xb4,
	0x9f, 0x73, 0x44, 0x1e, 0xad, 0x80, 0x22, 0x21, 0x78, 0x2a, 0x10, 0x75, 0x08, 0x0d, 0x21, 0x62,
	0x8b, 0xa5, 0x03, 0xba, 0x1f, 0xd3, 0xfa, 0x6b, 0x72, 0x17, 0xc5, 0x08, 0x25, 0xc5, 0xbf, 0x09,
	0xd5, 0xb0, 0x5b, 0x2c, 0xf1, 0xaa, 0x5c, 0x06, 0xa9, 0x07, 0x50, 0xd9, 0xc7, 0x26, 0xaf, 0xe1,
	0xbd, 0x58, 0x0d, 0x6b, 0xf2, 0xd9, 0x96, 0x99, 0xe2, 0xbd, 0x02, 0xf3, 0x27, 0xc6, 0x78, 0x1a,
	0x26, 0xdd, 0x60, 0x1f, 0xaa, 0x0e, 0x8d, 0x96, 0xdf, 0xf3, 0xb0, 0x8b, 0xed, 0x90, 0xab, 0x02,
	0x05, 0xc3, 0xb7, 0xb9, 0x97, 0x4c, 0x7e, 0x92, 0xf9, 0x48, 0x28, 0x0c, 0x71, 0x68, 0xc4, 0xbe,
	0x90, 0x0a, 0x75, 0x62, 0xa4, 0xc7, 0x78, 0x18, 0xe8, 0x13, 0xc7, 0x0f, 0xb8, 0xaf, 0x57, 0x9d,
	0xfa, 0x78, 0x0f, 0x0f, 0x83, 0x7d, 0x87, 0xbe, 0xc4, 0xaa, 0xf3, 0xc7, 0x10, 0x9c, 0xfd, 0xb9,
	0x09, 0x0c, 0x7c, 0x3c, 0x1e, 0x72, 0x7f, 0x92, 0xfe, 0x56, 0xef, 0x40, 0x63, 0x8f, 0x6e, 0xfb,
	0x7b, 0x78, 0xc8, 0x19, 0x88, 0x86, 0xf0, 0x83, 0x2d, 0xd6, 0x90, 0xff, 0x54, 0x80, 0x05, 0x46,
	0xe0, 0x47, 0x57, 0x2a, 0x0d, 0xb6, 0x63, 0x90, 0x5a, 0x51, 0xa9, 0x52, 0x30, 0x6a, 0x7e, 0xa5,
	0x92, 0xf3, 0xfe, 0x0c, 0x2a, 0xd1, 0x99, 0x6f, 0x3e, 0x79, 0x97, 0x32, 0x31, 0x70, 0x5a, 0x44,
	0x8b, 0x6e, 0x43, 0x61, 0xc2, 0x9d, 0xdd, 0x58, 0xf4, 0x26, 0x46, 0x42, 0x23, 0x78, 0xf4, 0x39,
	0x00, 0x59, 0x0a, 0x58, 0x7f, 0xf3, 0x95, 0xe0, 0x6a, 0x6c, 0x11, 0x91, 0x87, 0x82, 0x2e, 0x08,
	0x0c, 0x80, 0x7e, 0x04, 0xf5, 0xd8, 0xbc, 0xe6, 0x0b, 0xc2, 0x39, 0xd2, 0xd5, 0xe4, 0xa9, 0x8d,
	0xee, 0xc3, 0x02, 0x7f, 0xad, 0xc2, 0x57, 0x03, 0x49, 0x5d, 0x62, 0x03, 0xa4, 0x85, 0x74, 0x44,
	0x58, 0x7e, 0x08, 0xe3, 0xe1, 0x21, 0x77, 0x78, 0xae, 0xca, 0x3e, 0x49, 0x6c, 0x5c, 0xc2, 0xf3,
	0x19, 0x0f, 0x0f, 0xd1, 0x23, 0x68, 0x24, 0x26, 0x39, 0x77, 0x69, 0xce, 0x11, 0x77, 0x31, 0x3e,
	0xcf, 0xd5, 0x5f, 0xe4, 0xa0, 0x22, 0x9e, 0x8f, 0x0a, 0x33, 0x93, 0x93, 0x2c, 0xde, 0x27, 0x00,
	0x03, 0xb1, 0xda, 0xf0, 0xd1, 0x5a, 0xc9, 0x5a, 0x89, 0x34, 0x89, 0x0e, 0xbd, 0x07, 0x0b, 0x4c,
	0x2d, 0x7c, 0x3e, 0x5a, 0xf2, 0x6d, 0x57, 0x86, 0xd0, 0x42, 0x0a, 0xf5, 0x6b, 0x28, 0x71, 0x4f,
	0x37, 0x4b, 0x80, 0xf8, 0x03, 0xf4, 0xfc, 0xe5, 0x1e, 0xa0, 0xff, 0xb7, 0x1c, 0x28, 0xc9, 0xcb,
	0xa1, 0xe8, 0x6e, 0x6c, 0x26, 0xaf, 0x24, 0xaf, 0x91, 0x4a, 0xd3, 0x58, 0xce, 0xd7, 0x94, 0xbf,
	0x44, 0xbe, 0xa6, 0xac, 0x0c, 0x95, 0xf2, 0xa3, 0xec, 0xe2, 0x45, 0x8f, 0xb2, 0xd1, 0x87, 0xb0,
	0x60, 0xe2, 0xa1, 0x41, 0xac, 0xc1, 0xfc, 0x79, 0x13, 0x29, 0xa4, 0x52, 0x7f, 0x99, 0x83, 0x3a,
	0x41, 0x44, 0x09, 0x95, 0x3e, 0x85, 0xaa, 0xc9, 0x9c, 0x18, 0x6e, 0xaa, 0x67, 0x27, 0x4d, 0x00,
	0x33, 0xf2, 0x88, 0x1e, 0xc2, 0x12, 0x8b, 0x48, 0x74, 0x0a, 0xb4, 0xf8, 0xed, 0x97, 0x6c, 0x81,
	0x15, 0x46, 0xba, 0x23, 0x28, 0xd5, 0xbf, 0x9f, 0x83, 0x82, 0xe6, 0x18, 0x68, 0x11, 0xf2, 0x46,
	0xb8, 0x57, 0x93, 0x37, 0x7c, 0xf4, 0x16, 0x70, 0x8f, 0x60, 0x8c, 0x43, 0x0f, 0x2e, 0x02, 0x90,
	0xc5, 0x6e, 0x62, 0x50, 0x14, 0x7f, 0x6f, 0xc2, 0xbe, 0xa4, 0x3b, 0xcb, 0xc5, 0xd8, 0x9d, 0xe5,
	0xf0, 0xa9, 0xc5, 0xfc, 0xf9, 0xe9, 0x6c, 0xd4, 0x3b, 0xec, 0xd9, 0x8f, 0x63, 0x5c, 0x94, 0xa2,
	0x86, 0x65, 0xe3, 0xa0, 0x84, 0x51, 0x36, 0x0e, 0xcf, 0x31, 0x32, 0xb2, 0x71, 0x10, 0x22, 0x8a,
	0x52, 0x7d, 0x28, 0x3c, 0xf3, 0x86, 0x99, 0x5a, 0xba, 0x08, 0x79, 0x8f, 0x05, 0xe9, 0x35, 0x2d,
	0xef, 0x99, 0xd4, 0xc7, 0x65, 0x77, 0x97, 0x3d, 0xe6, 0x2d, 0xd6, 0xb4, 0x32, 0x03, 0x68, 0x34,
	0x6f, 0x19, 0xbf, 0x19, 0xed, 0x05, 0x54, 0x37, 0x6a, 0x5a, 0x99, 0x01, 0xb4, 0x80, 0x5f, 0x32,
	0x65, 0x97, 0xe1, 0xf2, 0x96, 0xa9, 0xfe, 0x2a, 0x07, 0x2b, 0x3b, 0x6c, 0xd0, 0xa9, 0x22, 0xec,
	0x58, 0x7e, 0x60, 0xd8, 0x03, 0x8c, 0xb6, 0x40, 0xec, 0x3a, 0xb3, 0x0d, 0x65, 0xdd, 0xe4, 0x28,
	0xde, 0xd6, 0xd5, 0x10, 0x9d, 0x2a, 0x47, 0xcf, 0xaf, 0x33, 0xca, 0xb1, 0x71, 0x5a, 0x0d, 0xd1,
	0xb1, 0x72, 0xea, 0xbf, 0x2d, 0x42, 0x89, 0x3d, 0xc1, 0x4d, 0x0d, 0xf6, 0x06, 0x54, 0xa2, 0x1d,
	0x71, 0x9e, 0x6c, 0xcd, 0x0b, 0xb7, 0xc0, 0x6f, 0x40, 0x95, 0x38, 0x0f, 0xd8, 0x66, 0x07, 0xbb,
	0x05, 0xe6, 0xec, 0x30, 0x10, 0x3d, 0xd8, 0x7d, 0x17, 0x14, 0x4e, 0xc0, 0x8d, 0x14, 0x9f, 0x31,
	0x15, 0xad, 0xc1, 0xe0, 0xad, 0x10, 0x1c, 0x7b, 0x55, 0x31, 0x9f, 0x78, 0x55, 0xf1, 0x7e, 0x66,
	0x34, 0xcb, 0x8f, 0x3f, 0x53, 0x11, 0xeb, 0xcf, 0x66, 0x07, 0xd5, 0x0b, 0xaf, 0xb2, 0x6f, 0x3d,
	0x23, 0xb4, 0xee, 0xc3, 0x15, 0x3e, 0x53, 0x93, 0x7d, 0xcc, 0xd6, 0xe8, 0xeb, 0xb1, 0x79, 0x99,
	0x1a, 0x5c, 0x6d, 0xc5, 0xcc, 0x1a, 0xf2, 0x87, 0xf4, 0x06, 0xc4, 0x10, 0x9b, 0xd8, 0x63, 0x2f,
	0x52, 0x2b, 0x49, 0x2b, 0xb3, 0x2d, 0xa3, 0xb5, 0x38, 0xf5, 0x1b, 0x7a, 0xcb, 0x90, 0xdc, 0xc8,
	0xa8, 0x5e, 0x76, 0x23, 0x43, 0x75, 0xa0, 0x1e, 0x93, 0xef, 0x9c, 0xad, 0xaf, 0xf8, 0x63, 0xce,
	0x7c, 0xea, 0x31, 0xe7, 0xdb, 0xb0, 0xc8, 0xf6, 0x09, 0x74, 0xc3, 0xd7, 0x45, 0x48, 0x56, 0xd7,
	0x6a, 0x0c, 0xda, 0xf2, 0xa9, 0x6b, 0xfa, 0x27, 0x39, 0xa8, 0xd0, 0x57, 0x6a, 0x1d, 0x7b, 0xe8,
	0x7c, 0x2f, 0x0f, 0xe4, 0xee, 0x40, 0xc3, 0x9e, 0x4e, 0x74, 0xe9, 0x71, 0x22, 0xbf, 0x13, 0xb2,
	0x68, 0x4f, 0x27, 0xf2, 0xe3, 0xce, 0xab, 0x50, 0xb6, 0xf9, 0x96, 0x76, 0x78, 0x05, 0xc9, 0x66,
	0xbb, 0xd9, 0xe8, 0x16, 0xd4, 0x08, 0x4a, 0xdc, 0x07, 0x63, 0x97, 0x3e, 0xaa, 0xf6, 0x74, 0xd2,
	0xe2, 0x20, 0xf5, 0x87, 0xf4, 0xa9, 0xbd, 0x66, 0x1d, 0x91, 0x86, 0x84, 0x6b, 0x5b, 0xf8, 0xae,
	0x2b, 0x95, 0x69, 0x44, 0x34, 0x99, 0x3d, 0xad, 0x51, 0x1f, 0xd2, 0x7c, 0xd1, 0xa2, 0x34, 0x5f,
	0xf0, 0x2e, 0x5d, 0xdc, 0xa5, 0xd9, 0x5c, 0xb6, 0x9d, 0x31, 0x7f, 0xe7, 0x33, 0x33, 0x5f, 0xd3,
	0x1a, 0x2c, 0x98, 0x47, 0xba, 0xd4, 0x77, 0x25, 0xf3, 0x88, 0x5e, 0xd2, 0xdd, 0x84, 0x65, 0xfa,
	0x4a, 0x52, 0xa7, 0xe9, 0x1a, 0x93, 0x17, 0x6f, 0x28, 0x6a, 0x67, 0x3a, 0x71, 0xc5, 0xcd, 0x1f,
	0x96, 0xf5, 0x45, 0xaa, 0x91, 0x3f, 0xe8, 0x5b, 0x82, 0x46, 0x98, 0x69, 0x33, 0x7c, 0xd9, 0x8f,
	0x40, 0x89, 0x40, 0x8c, 0xec, 0xde, 0xef, 0x15, 0xa0, 0xf4, 0x98, 0x8d, 0x4f, 0x0d, 0xca, 0x5a,
	0xfb, 0xb0, 0xad, 0x3d, 0x6b, 0xef, 0x28, 0x73, 0x08, 0xa0, 0xd8, 0xe9, 0x9d, 0x7c, 0xa2, 0xbc,
	0x7c, 0x51, 0xe4, 0xbf, 0xb7, 0x94, 0x97, 0x2f, 0xca, 0xa8, 0x0e, 0x0b, 0x04, 0xae, 0xef, 0x6f,
	0x2b, 0xbf, 0x78, 0x51, 0xe4, 0x9f, 0x5b, 0xec, 0xb3, 0x8c, 0x1a, 0x50, 0x61, 0xd8, 0xde, 0xde,
	0xa1, 0xf2, 0xfb, 0x2f, 0x8a, 0x1c, 0xb0, 0x15, 0x02, 0xca, 0x68, 0x11, 0xca, 0x94, 0xe2, 0x59,
	0xef, 0x40, 0x79, 0xf1, 0xb2, 0xc8, 0xbf, 0xb7, 0xf8, 0x77, 0x19, 0x2d, 0x41, 0x35, 0xc4, 0x13,
	0xa6, 0x2f, 0x5f, 0x16, 0x39, 0x68, 0x2b, 0x02, 0x95, 0x89, 0x44, 0xcf, 0x08, 0xc7, 0x7f, 0xff,
	0xc2, 0x24, 0xbf, 0xdb, 0xa4, 0xf4, 0x9f, 0xbc, 0x30, 0x51, 0x05, 0x0a, 0x5a, 0x7f, 0x5b, 0xf9,
	0xfd, 0x97, 0x45, 0xa4, 0x00, 0x50, 0x46, 0xed, 0x83, 0xed, 0x56, 0x4f, 0xf9, 0xbb, 0x2f, 0x42,
	0xc8, 0x96, 0x80, 0x94, 0xd1, 0x0a, 0x2c, 0x3e, 0xde, 0xeb, 0xfe, 0x44, 0x3f, 0xec, 0xb5, 0xb7,
	0x75, 0xda, 0xdc, 0x5f, 0xbe, 0x2c, 0xa6, 0xa0, 0x5b, 0xca, 0x2f, 0x5f, 0x96, 0x51, 0x13, 0x50,
	0x9c, 0x96, 0x8a, 0xfc, 0xab, 0x97, 0xc5, 0x14, 0x66, 0x8b, 0x63, 0xca, 0xe8, 0x0a, 0x28, 0x11,
	0x66, 0xef, 0x01, 0x87, 0x9b, 0x68, 0x11, 0x4a, 0xdd, 0x5e, 0xeb, 0xeb, 0xa7, 0x6d, 0xe5, 0x7f,
	0xbe, 0xfc, 0xa3, 0x17, 0xc5, 0x7b, 0xdb, 0x50, 0x0e, 0x27, 0x16, 0x02, 0x28, 0xed, 0xee, 0x75,
	0x1f, 0xb5, 0xf6, 0x94, 0xb9, 0x28, 0xb7, 0x23, 0xbd, 0x7e, 0xd8, 0xda, 0xf9, 0x1d, 0xbd, 0x73,
	0xa0, 0xe4, 0x51, 0x15, 0x16, 0xc8, 0xef, 0xee, 0xd3, 0x3e, 0x4b, 0xfa, 0xf8, 0x4c, 0x7b, 0xac,
	0x14, 0xef, 0xed, 0xc5, 0x9e, 0xd5, 0xb2, 0xd5, 0x15, 0x29, 0x50, 0xdb, 0xeb, 0x76, 0xbf, 0x7a,
	0xda, 0xd3, 0xdb, 0xcf, 0x5b, 0xdb, 0x7d, 0x65, 0x0e, 0x2d, 0x41, 0x9d, 0x43, 0xf6, 0xba, 0x07,
	0xbb, 0x6d, 0x4d, 0xc9, 0x21, 0x04, 0x8b, 0x1c, 0x74, 0xf8, 0xa4, 0xab, 0xf5, 0xdb, 0x9a, 0x92,
	0xbf, 0xf7, 0x0b, 0xfa, 0xe2, 0x5a, 0x6c, 0xf4, 0xd0, 0xeb, 0x8f, 0x5a, 0xfb, 0x71, 0xe7, 0xb9,
	0x32, 0x47, 0x34, 0xe5, 0xa0, 0xdd, 0xd9, 0x7d, 0xf2, 0xa8, 0x4b, 0x4a, 0x2f, 0x40, 0xa1, 0xdf,
	0xda, 0xe5, 0x62, 0x1d, 0xea, 0xbd, 0x56, 0xff, 0x89, 0x52, 0x40, 0x75, 0xa8, 0x6c, 0x77, 0xf7,
	0xf7, 0x9f, 0x1e, 0x74, 0xfa, 0xdf, 0x28, 0x64, 0x0c, 0xeb, 0xed, 0xe7, 0x7d, 0x3d, 0x02, 0xcd,
	0x93, 0xf8, 0x77, 0xaf, 0xa5, 0xed, 0xb6, 0x25, 0x60, 0x89, 0xb1, 0x7e, 0xde, 0xd7, 0x9f, 0x74,
	0x7b, 0xca, 0xc2, 0xbd, 0x77, 0xa1, 0x22, 0xf6, 0x77, 0xe8, 0x8d, 0xec, 0x83, 0x6f, 0xe4, 0xab,
	0xd9, 0x00, 0xa5, 0xce, 0xc1, 0xb3, 0xb6, 0xd6, 0x57, 0xf2, 0xf7, 0xee, 0x81, 0x92, 0xdc, 0xbd,
	0x41, 0x25, 0xc8, 0xb7, 0xbf, 0x56, 0xe6, 0xc8, 0xdf, 0xdd, 0xb6, 0x92, 0x23, 0x7f, 0xf7, 0xda,
	0x4a, 0xfe, 0xde, 0x87, 0xfc, 0x16, 0x14, 0x0f, 0xb2, 0xa2, 0x4b, 0xdf, 0xa4, 0x93, 0xb7, 0xb7,
	0xdb, 0xbd, 0x3e, 0x63, 0xae, 0xb5, 0x7f, 0xa7, 0xbd, 0x4d, 0x98, 0x3f, 0x85, 0xe5, 0x8c, 0x20,
	0x99, 0x34, 0x4a, 0xc8, 0xae, 0xb7, 0x76, 0xc8, 0xb4, 0x59, 0x01, 0x25, 0x02, 0x69, 0xed, 0xfd,
	0xee, 0x33, 0x52, 0xf1, 0x2a, 0x2c, 0xc9, 0x50, 0x7e, 0x9b, 0xfc, 0xde, 0x07, 0x50, 0x8f, 0x45,
	0xc6, 0xa4, 0x07, 0xf7, 0xdb, 0x3b, 0xfa, 0x7e, 0x97, 0xb0, 0x6a, 0x40, 0x95, 0x7c, 0x84, 0xe4,
	0xb9, 0x7b, 0xef, 0x03, 0x44, 0xee, 0xb7, 0xc8, 0xee, 0x4b, 0x3a, 0x61, 0xbf, 0xd7, 0xd5, 0xb8,
	0xcc, 0xed, 0xe7, 0xf4, 0x77, 0xfe, 0xc1, 0x7f, 0xb8, 0x0d, 0xe5, 0x5d, 0xb2, 0x4e, 0xb5, 0x5c,
	0x0b, 0xed, 0x41, 0x55, 0x4a, 0x00, 0x82, 0xde, 0x8a, 0x05, 0x05, 0x89, 0xbc, 0x22, 0xeb, 0xd7,
	0x66, 0x60, 0xf9, 0xca, 0x32, 0x87, 0x3a, 0x00, 0x51, 0x8a, 0x10, 0xb4, 0x21, 0x93, 0x27, 0xb2,
	0x89, 0xac, 0xbf, 0x95, 0x8d, 0x14, 0xac, 0x1e, 0x43, 0x45, 0x24, 0x46, 0x41, 0xd2, 0x4e, 0x5c,
	0x32, 0x83, 0xca, 0xfa, 0x46, 0x26, 0x4e, 0xf0, 0xd9, 0x83, 0xaa, 0x94, 0x29, 0x5d, 0x6e, 0x60,
	0x3a, 0xf5, 0xba, 0xdc, 0xc0, 0xac, 0xf4, 0xea, 0x73, 0xe8, 0x29, 0x2c, 0xc6, 0x73, 0xa4, 0xa3,
	0x1b, 0xb2, 0x13, 0x92, 0x91, 0x7a, 0x7d, 0xfd, 0xe6, 0x6c, 0x02, 0x99, 0x6d, 0x3c, 0xf5, 0xb9,
	0xcc, 0x36, 0x33, 0xf5, 0xba, 0xcc, 0x36, 0x3b, 0x6b, 0x3a, 0x6b, 0xbb, 0xf4, 0x7f, 0x08, 0xe4,
	0xb6, 0xa7, 0xff, 0xf5, 0x81, 0xdc, 0xf6, 0x8c, 0x7f, 0x5e, 0xa0, 0xce, 0x21, 0x0d, 0xea, 0xb1,
	0xb4, 0xd0, 0xe8, 0x7a, 0xcc, 0xfa, 0xa7, 0x39, 0xde, 0x98, 0x89, 0x17, 0x3c, 0xff, 0x3a, 0x2c,
	0xa5, 0xd2, 0x4d, 0x23, 0xf5, 0xe2, 0xb4, 0xd7, 0xeb, 0x3f, 0x38, 0x97, 0x46, 0xf0, 0xff, 0x6b,
	0x91, 0x65, 0x13, 0xec, 0xa5, 0x2b, 0x5d, 0x33, 0xb2, 0x59, 0xaf, 0xab, 0xe7, 0x91, 0xc8, 0xa3,
	0x16, 0x4f, 0x32, 0x2d, 0x8f, 0x5a, 0x66, 0xc6, 0x6a, 0x79, 0xd4, 0x66, 0xe4, 0xa7, 0x9e, 0x43,
	0xcf, 0xa1, 0x91, 0xc8, 0x23, 0x8d, 0x64, 0x1d, 0xca, 0x4c, 0x5e, 0xbd, 0x7e, 0xeb, 0x1c, 0x0a,
	0xc1, 0xf9, 0x21, 0x94, 0x98, 0x0f, 0x83, 0xd6, 0x62, 0x83, 0x1d, 0x65, 0x17, 0x58, 0x6f, 0xa6,
	0x11, 0xa2, 0xf8, 0x67, 0xb0, 0xc0, 0xd3, 0x25, 0xa0, 0x38, 0x99, 0x94, 0x41, 0x61, 0x3d, 0x91,
	0x59, 0x43, 0x9d, 0xfb, 0x28, 0x47, 0xf4, 0x50, 0x4a, 0x2d, 0x20, 0xeb, 0x61, 0x3a, 0xbf, 0x81,
	0xac, 0x87, 0x59, 0xf9, 0x08, 0xe6, 0xd0, 0x8f, 0x61, 0x81, 0x1f, 0x8e, 0xa0, 0xf4, 0x01, 0x4b,
	0xc8, 0xe5, 0x6a, 0x06, 0x46, 0x5e, 0xa6, 0xa2, 0xff, 0xc6, 0x20, 0x2f, 0x53, 0xa9, 0xff, 0x27,
	0x21, 0x2f, 0x53, 0x19, 0xff, 0xc0, 0x61, 0x0e, 0xed, 0x00, 0x44, 0x79, 0x8e, 0x65, 0x56, 0xa9,
	0xec, 0xc7, 0xeb, 0xd9, 0x49, 0x39, 0x68, 0x07, 0x7d, 0x29, 0x72, 0x3b, 0x47, 0x0f, 0x6e, 0x24,
	0x67, 0x52, 0xfc, 0x3b, 0x90, 0xf5, 0xc4, 0xbf, 0x58, 0xa0, 0x85, 0x1f, 0x43, 0x45, 0x24, 0xdb,
	0x96, 0x57, 0xca, 0x64, 0xaa, 0x6f, 0x79, 0xa5, 0x4c, 0x67, 0xe7, 0x66, 0xbd, 0x22, 0x52, 0x71,
	0xc7, 0x7a, 0x25, 0x99, 0xb5, 0x3b, 0xd6, 0x2b, 0xe9, 0xec, 0xdd, 0x73, 0xe8, 0x09, 0x54, 0x44,
	0xfa, 0x6c, 0x59, 0xa4, 0x64, 0x52, 0x6f, 0x59, 0xa4, 0x74, 0xbe, 0xed, 0xb9, 0xbb, 0x39, 0xa2,
	0xb2, 0x2c, 0x61, 0x35, 0x5a, 0x9b, 0x91, 0x2f, 0x7b, 0xbd, 0x99, 0x46, 0xc8, 0x56, 0x44, 0xe4,
	0xa6, 0x96, 0x05, 0x49, 0xa6, 0xbc, 0x5e, 0xdf, 0xc8, 0xc4, 0xc9, 0x3a, 0xc7, 0xb3, 0xf1, 0x26,
	0x54, 0x5f, 0x4a, 0xe3, 0x2a, 0xeb, 0x5c, 0x22, 0x75, 0xaf, 0xd0, 0xda, 0x24, 0x87, 0x78, 0x96,
	0xde, 0x84, 0xd6, 0x26, 0x38, 0x08, 0xad, 0xa5, 0x4c, 0x52, 0x02, 0xcb, 0x7c, 0xde, 0xca, 0x46,
	0xca, 0xac, 0xa2, 0x44, 0xb9, 0x28, 0xa5, 0x17, 0x33, 0x58, 0x65, 0xe4, 0xd6, 0xa5, 0x36, 0x46,
	0xca, 0x96, 0x8b, 0xd2, 0x9a, 0x21, 0x33, 0xbb, 0x36, 0x03, 0x2b, 0x8f, 0x97, 0xc8, 0x75, 0x2b,
	0x8f, 0x57, 0x32, 0x65, 0xae, 0x3c, 0x5e, 0xe9, 0xe4, 0xb8, 0xd4, 0x56, 0xc5, 0xf2, 0xe6, 0xca,
	0xb6, 0x2a, 0x2b, 0x05, 0xaf, 0x6c, 0xab, 0xb2, 0x13, 0xee, 0x8a, 0xd5, 0xd3, 0x31, 0x92, 0xab,
	0xa7, 0xd8, 0x29, 0x4b, 0xae, 0x9e, 0xd1, 0xce, 0x18, 0xeb, 0x28, 0x29, 0xc7, 0x2d, 0x4a, 0xf5,
	0xab, 0x9c, 0xc7, 0x57, 0xee, 0xa8, 0xac, 0xc4, 0xb8, 0x73, 0x7c, 0x5e, 0x3c, 0xf3, 0x86, 0x89,
	0x79, 0x11, 0xe5, 0xa7, 0x4d, 0xcc, 0x0b, 0x39, 0x07, 0xad, 0x34, 0x2f, 0x08, 0x87, 0xd4, 0xbc,
	0x90, 0x98, 0x6c, 0x64, 0xe2, 0x12, 0x7d, 0x92, 0x10, 0x23, 0x96, 0xb3, 0x37, 0xd1, 0x27, 0xf1,
	0xe2, 0x1a, 0xdd, 0x6a, 0x94, 0x8e, 0x96, 0xaf, 0xc7, 0x88, 0x53, 0xd9, 0x5b, 0xe5, 0x61, 0xca,
	0x4c, 0x77, 0xcb, 0x78, 0xc6, 0xd2, 0xd0, 0xca, 0x3c, 0xb3, 0xf2, 0xdb, 0xca, 0x3c, 0xb3, 0xf3,
	0xd7, 0x52, 0x37, 0x22, 0x99, 0x6c, 0x56, 0x76, 0x23, 0x66, 0x64, 0xb7, 0x95, 0xdd, 0x88, 0x99,
	0xb9, 0x6a, 0xa9, 0x0f, 0x94, 0xca, 0x34, 0x2b, 0xfb, 0x40, 0xb3, 0x52, 0xd9, 0xca, 0x3e, 0xd0,
	0xec, 0x54, 0xb5, 0x73, 0xa8, 0x0b, 0x35, 0x39, 0x2b, 0x2d, 0x8a, 0x3b, 0x7a, 0xc9, 0x04, 0xac,
	0xeb, 0xd7, 0x67, 0xa1, 0x65, 0x86, 0x72, 0x3e, 0x59, 0x14, 0xf7, 0x9a, 0xcf, 0x63, 0x98, 0x99,
	0x86, 0x96, 0x79, 0x3c, 0xf1, 0x4c, 0xb1, 0x28, 0xe5, 0x35, 0xa7, 0xd8, 0xde, 0x3a, 0x87, 0x42,
	0x1e, 0xb8, 0x64, 0x6a, 0x58, 0x79, 0xe0, 0x66, 0x24, 0xa1, 0x5d, 0x57, 0xcf, 0x23, 0x49, 0x84,
	0x28, 0xfc, 0xe4, 0x20, 0x1e, 0xa2, 0xc4, 0x12, 0x9d, 0x26, 0x42, 0x94, 0x44, 0x56, 0x51, 0xca,
	0x47, 0x24, 0xd2, 0x94, 0xf9, 0x24, 0x33, 0xcc, 0xca, 0x7c, 0xd2, 0x39, 0x60, 0xe9, 0xb8, 0xc8,
	0x29, 0x30, 0xe5, 0x71, 0xc9, 0x48, 0x0e, 0xbb, 0x7e, 0x7d, 0x16, 0x3a, 0xee, 0xf1, 0x4b, 0x39,
	0x2d, 0xe3, 0x1e, 0x7f, 0x3a, 0xa3, 0x6b, 0xdc, 0xe3, 0xcf, 0x4a, 0xa1, 0x4a, 0x85, 0x94, 0xff,
	0x37, 0x89, 0x2c, 0x64, 0xc6, 0xbf, 0x48, 0x91, 0x85, 0xcc, 0xfc, 0x97, 0x26, 0x73, 0xc8, 0xa4,
	0xb9, 0x98, 0x53, 0x07, 0x55, 0x6f, 0x67, 0xf4, 0x79, 0x2a, 0xe3, 0xe7, 0xfa, 0xed, 0x0b, 0xa8,
	0xe4, 0x5a, 0x32, 0x92, 0x9d, 0xca, 0xb5, 0xcc, 0xce, 0xb2, 0x2a, 0xd7, 0x72, 0x5e, 0xc6, 0xd4,
	0x39, 0x34, 0x11, 0xff, 0x56, 0x2a, 0x59, 0xd1, 0x9d, 0xec, 0xc1, 0x4a, 0xd7, 0x75, 0xf7, 0x62,
	0x42, 0x51, 0x9d, 0x2b, 0xd2, 0x30, 0xa7, 0xcf, 0xf9, 0x66, 0x8c, 0x64, 0xba, 0xc2, 0x77, 0x2f,
	0x41, 0x29, 0x3b, 0x1e, 0xd1, 0x2e, 0x2a, 0xda, 0x48, 0x06, 0x1b, 0xd2, 0xce, 0xec, 0xfa, 0x5b,
	0xd9, 0xc8, 0xc4, 0x2a, 0x14, 0x25, 0x8b, 0x8a, 0xaf, 0x42, 0xc9, 0x7f, 0x97, 0x95, 0x58, 0x85,
	0xd2, 0xff, 0x68, 0x4b, 0x5a, 0x85, 0x22, 0x9e, 0xa9, 0x55, 0x28, 0xc5, 0xf6, 0xd6, 0x39, 0x14,
	0x32, 0xe7, 0xc4, 0x7f, 0xd3, 0x42, 0xa9, 0xf0, 0xfd, 0x3c, 0xce, 0x33, 0xfe, 0x15, 0x97, 0x3a,
	0x87, 0x0c, 0xfa, 0x1f, 0xe4, 0x92, 0x59, 0x8b, 0x7e, 0x10, 0xb7, 0x68, 0x99, 0xff, 0x7b, 0x6b,
	0xfd, 0xed, 0xf3, 0x89, 0x12, 0xfd, 0x2c, 0xf6, 0x91, 0x13, 0xfd, 0x9c, 0xdc, 0xd1, 0x4e, 0xf4,
	0x73, 0x7a, 0xfb, 0x79, 0x0e, 0x6d, 0x43, 0x39, 0x0c, 0xaa, 0xd1, 0xd5, 0x74, 0xa0, 0x1d, 0x32,
	0x5a, 0xcf, 0x42, 0x85, 0x4c, 0x1e, 0xd5, 0xfe, 0xf4, 0xd7, 0xd7, 0x73, 0xff, 0xf9, 0xd7, 0xd7,
	0x73, 0xff, 0xfd, 0xd7, 0xd7, 0x73, 0x47, 0x25, 0x9a, 0x1e, 0xf2, 0xe3, 0xff, 0x17, 0x00, 0x00,
	0xff, 0xff, 0x8b, 0x8d, 0x9d, 0xfa, 0x07, 0x72, 0x00, 0x00,
}
